Transport Layer Security (TLS,) ist ein kryptographisches Protokoll, das die Kommunikationssicherheit über ein Computernetzwerk ermöglicht. Mehrere Versionen des Protokolls sind weit verbreitet in Anwendungen wie E-Mail, Instant Messaging und Stimme über IP, aber seine Verwendung als Sicherheitsschicht in HTTPS bleibt die am meisten sichtbar. Das TLS-Protokoll zielt in erster Linie darauf ab, Datenschutz und Datenintegrität zwischen zwei oder mehr kommunizierenden Computeranwendungen bereitzustellen. Sie verläuft in der Anwendungsschicht des Internets und besteht selbst aus zwei Schichten: dem TLS-Record und den TLS-Handshake-Protokollen. TLS ist ein vorgeschlagener Internet Engineering Task Force (IETF) Standard, der erst 1999 definiert wurde, und die aktuelle Version ist TLS 1.3 definiert im August 2018. TLS baut auf den früheren SSL-Spezifikationen (1994, 1995, 1996) auf, die von Netscape Communications für das Hinzufügen des HTTPS-Protokolls zu ihrem Navigator Webbrowser entwickelt wurden. Beschreibung Client-Server-Anwendungen verwenden das TLS-Protokoll, um über ein Netzwerk in einer Weise zu kommunizieren, die entwickelt, um zu verhindern, dass Eavesdropping und Manipulation. Da Anwendungen entweder mit oder ohne TLS (oder SSL) kommunizieren können, ist es für den Client erforderlich, dass der Server eine TLS-Verbindung einstellt. Eine der wichtigsten Möglichkeiten, dies zu erreichen, ist die Verwendung einer anderen Portnummer für TLS-Verbindungen. Beispielsweise wird Port 80 typischerweise für unverschlüsselten HTTP-Verkehr verwendet, während Port 443 der gemeinsame Port für verschlüsselten HTTPS-Verkehr ist. Ein weiterer Mechanismus ist, dass der Client eine protokollspezifische Anfrage an den Server stellt, um die Verbindung zu TLS zu wechseln; zum Beispiel indem er eine STARTTLS-Anfrage bei der Verwendung der Mail- und Nachrichtenprotokolle anfertigt. Sobald der Client und der Server vereinbart haben, TLS zu verwenden, verhandeln sie eine Stateful-Verbindung mit einem Handshaking-Verfahren. Die Protokolle verwenden einen Handshake mit asymmetrischer Chiffre, um nicht nur Cipher-Einstellungen zu erstellen, sondern auch einen sitzungsspezifischen gemeinsamen Schlüssel, mit dem eine weitere Kommunikation mit einem symmetrischen Chiffre verschlüsselt wird. Während dieses Handshake stimmen der Client und der Server auf verschiedene Parameter überein, mit denen die Sicherheit der Verbindung festgelegt wird: Der Handshake beginnt, wenn ein Client sich mit einem TLS-fähigen Server verbindet, der eine sichere Verbindung anfordert und der Client eine Liste von unterstützten Chiffre-Suiten (Ciphers und Hash-Funktionen) präsentiert. Aus dieser Liste wählt der Server eine Chiffre und Hash-Funktion, die er auch den Client der Entscheidung unterstützt und benachrichtigt. Der Server stellt dann in der Regel eine Identifikation in Form eines digitalen Zertifikats bereit. Das Zertifikat enthält den Servernamen, die vertrauenswürdige Zertifikatsbehörde (CA), die für die Echtheit des Zertifikats entscheidet, und den öffentlichen Verschlüsselungsschlüssel des Servers. Der Kunde bestätigt die Gültigkeit des Zertifikats vor dem Verfahren. Um die für die sichere Verbindung verwendeten Session-Schlüssel zu erzeugen, verschlüsselt der Client entweder eine zufällige Nummer (PreMasterSecret) mit dem öffentlichen Schlüssel des Servers und sendet das Ergebnis an den Server (die nur der Server mit seinem privaten Schlüssel entschlüsseln kann); beide Parteien verwenden dann die zufällige Nummer, um einen einzigartigen Session-Schlüssel für die nachfolgende Verschlüsselung und Entschlüsselung von Daten während der Sitzung zu erzeugen. Dies schließt den Handshake und beginnt die gesicherte Verbindung, die mit dem Sitzungsschlüssel verschlüsselt und entschlüsselt wird, bis die Verbindung schließt. Wenn einer der obigen Schritte ausfällt, scheitert der TLS-Handshake und die Verbindung wird nicht erzeugt. TLS und SSL passen nicht ordentlich in jede einzelne Schicht des OSI-Modells oder des TCP/IP-Modells. TLS läuft "über eines zuverlässigen Transportprotokolls (z.B. TCP), das bedeutet, dass es über der Transportschicht liegt. Es dient der Verschlüsselung zu höheren Schichten, die normalerweise die Funktion der Präsentationsschicht ist. Anwendungen verwenden jedoch in der Regel TLS als Transportschicht, obwohl Anwendungen mit TLS die Initiierung von TLS-Handshakes und die Handhabung von ausgetauschten Authentifizierungszertifikaten aktiv kontrollieren müssen. Bei der Sicherung durch TLS sollten Verbindungen zwischen einem Client (z.B. einem Webbrowser) und einem Server (z.B. wikipedia.org) eine oder mehrere der folgenden Eigenschaften aufweisen: Die Verbindung ist privat (oder sicher), weil ein symmetrisch-Schlüssel-Algorithmus verwendet wird, um die übertragenen Daten zu verschlüsseln. Die Schlüssel für diese symmetrische Verschlüsselung werden für jede Verbindung einzigartig generiert und basieren auf einem gemeinsamen Geheimnis, das zu Beginn der Sitzung ausgehandelt wurde. Der Server und der Client verhandeln die Details, welche Verschlüsselungsalgorithmus und kryptographische Schlüssel vor dem ersten Byte der Daten übertragen werden (siehe unten). Die Verhandlung eines gemeinsamen Geheimnisses ist sowohl sicher (das ausgehandelte Geheimnis ist nicht verfügbar, um Entführer zu eavesdroppern und kann nicht erhalten werden, auch von einem Angreifer, der sich in die Mitte der Verbindung stellt) und zuverlässig (kein Angreifer kann die Kommunikation während der Verhandlungen ändern, ohne erkannt zu werden). Die Identität der kommunikativen Parteien kann mit der Public-key-Kryptographie authentifiziert werden. Diese Authentifizierung ist für den Server erforderlich und optional für den Client. Die Verbindung ist zuverlässig, da jede übermittelte Nachricht eine Nachrichtenintegritätsprüfung mit einem Nachrichtenauthentifizierungscode enthält, um einen unentdeckten Verlust oder eine Änderung der Daten bei der Übertragung zu verhindern. Zusätzlich zu den oben genannten, kann eine sorgfältige Konfiguration von TLS zusätzliche datenbezogene Eigenschaften wie Vorwärtsgeheimnis bereitstellen, um sicherzustellen, dass eine zukünftige Offenlegung von Verschlüsselungsschlüsseln nicht verwendet werden kann, um alle TLS-Kommunikationen in der Vergangenheit aufgezeichnet. TLS unterstützt viele verschiedene Methoden zum Austausch von Schlüsseln, zur Verschlüsselung von Daten und zur Authentisierung von Nachrichtenintegrität. Dadurch beinhaltet die sichere Konfiguration von TLS viele konfigurierbare Parameter, und nicht alle Wahlen bieten alle in der obigen Liste beschriebenen datenbezogenen Eigenschaften (siehe die Tabellen unter § Schlüsselaustausch, § Cipher Security und § Data Integrität). Es wurde versucht, Aspekte der Kommunikationssicherheit zu unterbinden, die TLS zu bieten versucht, und das Protokoll wurde mehrmals überarbeitet, um diese Sicherheitsbedrohungen zu lösen. Entwickler von Web-Browsern haben ihre Produkte wiederholt überarbeitet, um potenzielle Sicherheitsschwächen zu verteidigen, nachdem diese entdeckt wurden (siehe TLS/SSL-Unterstützungsgeschichte von Web-Browsern). Geschichte und Entwicklung Secure Data Network SystemDas Transport Layer Security Protocol (TLS) zusammen mit mehreren anderen grundlegenden Netzwerk-Sicherheitsplattformen wurde durch eine gemeinsame Initiative im August 1986, unter der National Security Agency, dem National Bureau of Standards, der Defense Communications Agency, und zwölf Kommunikations- und Computerunternehmen, die ein spezielles Projekt namens Secure Data Network System (SDNS) initiiert. Das Programm wurde im September 1987 auf der 10. National Computer Security Conference in einer umfangreichen Reihe von veröffentlichten Beiträgen beschrieben. Das innovative Forschungsprogramm konzentrierte sich darauf, die nächste Generation von sicheren Computerkommunikationsnetzen und Produktspezifikationen für Anwendungen im öffentlichen und privaten Internet zu entwickeln. Es sollte die sich schnell entwickelnden neuen OSI-Internetstandards ergänzen, die sowohl in den GOSIP-Profilen der US-Regierung als auch in den riesigen ITU-ISO JTC1-Internetanstrengungen international voranschreiten. Ursprünglich als SP4-Protokoll bekannt, wurde es TLS umbenannt und anschließend 1995 als internationale Norm ITU-T X.274| ISO/IEC 10736:1995 veröffentlicht. Sichere Netzwerk-Programmierung Zu den frühen Forschungsanstrengungen zur Verkehrsschichtsicherheit gehörte die Secure Network Programming (SNP) Application Programming Interface (API), die 1993 den Ansatz einer sicheren Transportschicht API erforschte, die Berkeley-Sockel genau ähnelte, um vorbestehende Netzwerkanwendungen mit Sicherheitsmassnahmen nachzurüsten. SSL 1.0, 2.0 und 3.0 Netscape entwickelten die ursprünglichen SSL-Protokolle und Taher Elgamal, Chefwissenschaftler bei Netscape Communications von 1995 bis 1998, wurde als "Vater von SSL" bezeichnet. Die SSL-Version 1.0 wurde wegen schwerwiegender Sicherheitsfehler im Protokoll nie öffentlich veröffentlicht. Version 2.0, veröffentlicht im Februar 1995, enthielt eine Reihe von Sicherheitsfehlern, die das Design der Version 3.0 erforderte. Im Jahr 1996 veröffentlichte die SSL-Version 3.0 eine vollständige Neugestaltung des Protokolls, das Paul Kocher mit Netscape-Ingenieuren Phil Karlton und Alan Freier erstellte, mit einer Referenz-Implementierung von Christopher Allen und Tim Dierks of Consensus Development. Neue Versionen von SSL/TLS basieren auf SSL 3.0. Der Entwurf von SSL 3.0 von 1996 wurde von IETF als historisches Dokument in RFC 6101 veröffentlicht. SSL 2.0 wurde 2011 von RFC 6176 abgeschrieben. Im Jahr 2014 wurde SSL 3.0 als verletzlich für den POODLE-Angriff gefunden, der alle Block-Ciphers in SSL beeinflusst; RC4, die einzige nicht-block-Cipherie, die von SSL 3.0 unterstützt wird, ist auch durchführbar gebrochen, wie in SSL 3.0 verwendet. SSL 3.0 wurde im Juni 2015 von RFC 7568 abgeschrieben. TLS 1.0 TLS 1.0 wurde im Januar 1999 erstmals in RFC 2246 als Upgrade der SSL Version 3.0 definiert und von Christopher Allen und Tim Dierks of Consensus Development geschrieben. Wie im RFC angegeben, sind "die Unterschiede zwischen diesem Protokoll und SSL 3.0 nicht dramatisch, aber sie sind signifikant genug, um die Interoperabilität zwischen TLS 1.0 und SSL 3.0 zu verhindern". Tim Dierks schrieb später, dass diese Veränderungen, und die Umbenennung von SSL zu TLS, eine face-saving Geste zu Microsoft waren, "so würde es nicht aussehen [wie] die IETF war nur Gummisamping Netscapes Protokoll". Der PCI-Rat schlug vor, dass Organisationen vor dem 30. Juni 2018 von TLS 1.0 auf TLS 1.1 oder höher wandern. Im Oktober 2018 gaben Apple, Google, Microsoft und Mozilla gemeinsam bekannt, dass sie im März 2020 TLS 1.0 und 1.1 abwerten würden. TLS 1.1 TLS 1.1 wurde im April 2006 in RFC 4346 definiert. Es ist ein Update von TLS Version 1.0. Wesentliche Unterschiede in dieser Version sind: Zusätzlicher Schutz gegen Cipher-Block-Ketten (CBC)-Angriffe. Der implizite Initialisierungsvektor (IV) wurde durch einen expliziten IV ersetzt. Änderung der Handhabung von Padding-Fehlern. Unterstützung für die IANA Registrierung von Parametern. Unterstützung für TLS-Versionen 1.0 und 1.1 wurde von Web-Seiten rund 2020 weit depreciert, den Zugriff auf Firefox-Versionen vor 24 und Google Chrome vor 29 deaktivieren. TLS 1.2 TLS 1.2 wurde im August 2008 in RFC 5246 definiert. Es basiert auf der früheren TLS 1.1 Spezifikation. Wichtige Unterschiede sind: Die MD5–SHA-1-Kombination in der Pseudorandom-Funktion (PRF) wurde durch SHA-256 ersetzt, mit einer Option zur Verwendung von Cipher Suite spezifiziert PRFs. Die MD5–SHA-1-Kombination in der fertigen Nachricht Hash wurde durch SHA-256 ersetzt, mit einer Option zur Verwendung von Cipher Suite-spezifischen Hash-Algorithmen. Die Größe der Hash in der fertigen Nachricht muss jedoch noch mindestens 96 Bit betragen. Die MD5–SHA-1 Kombination im digital signierten Element wurde durch einen einzigen Hash ersetzt, der während des Handshake ausgehandelt wurde, der SHA-1 vorgibt. Verbesserung der Fähigkeit des Clients und des Servers, welche Hashes und Signaturalgorithmen sie akzeptieren, anzugeben. Erweiterung der Unterstützung für authentifizierte Verschlüsselungsschlüssel, die hauptsächlich für Galois/Counter Mode (GCM) und CCM Modus der Advanced Encryption Standard (AES) Verschlüsselung verwendet werden. TLS Erweiterungen Definition und AES-Cipher Suiten wurden hinzugefügt. Alle TLS-Versionen wurden im März 2011 in RFC 6176 weiter verfeinert und ihre Rückwärtskompatibilität mit SSL entfernt, so dass TLS-Sitzungen nie die Verwendung von Secure Sockets Layer (SSL) Version 2.0 TLS 1.3 TLS 1.3 im August 2018 in RFC 8446 verhandeln. Es basiert auf der früheren TLS 1.2 Spezifikation. Zu den wichtigsten Unterschieden von TLS 1.2 gehören: Schlüsselvereinbarung und Authentifizierungsalgorithmen aus den Chiffre-Suiten Entfernen Unterstützung für schwache und weniger genutzte benannte elliptische Kurven Entfernen Unterstützung für MD5 und SHA-224 kryptographische Hash-Funktionen Erfüllen von digitalen Signaturen auch bei Verwendung einer vorherigen Konfiguration Integrieren von HKDF und dem semi-ephemeralen DH-Vorschlag Wiederaufnahme mit PSK und Tickets Integrieren der Verwendung von Session Hash Deprecating Verwendung der Record Layer Versionsnummer und Einfrieren der Nummer für eine verbesserte Rückwärtskompatibilität Bewegen Sie einige sicherheitsrelevante Algorithmus-Details von einem Anhang zur Spezifikation und relegieren Sie ClientKeyShare zu einem Anhang Hinzufügen des ChaCha20 Stream-Ciphers mit dem Poly1305 Nachrichten Authentifizierungscode Hinzufügen der Ed25519 und Ed448 digitalen Signatur-Algorithmus TLS 1.3-Unterstützung wurde anschließend hinzugefügt — aber aufgrund von Kompatibilitätsproblemen für eine kleine Anzahl von Benutzern, nicht automatisch aktiviert — Firefox 52.0, die im März 2017 veröffentlicht wurde. TLS 1.3 wurde im Mai 2018 standardmäßig mit dem Release von Firefox 60.0 aktiviert. Google Chrome set TLS 1.3 als Standardversion für eine kurze Zeit im Jahr 2017. Es entfernte es dann als Standard, aufgrund von inkompatiblen Middleboxen wie Blue Coat Web-Proxies. Während des IETF 100 Hackathon, der 2017 in Singapur stattfand, arbeitete die TLS Group an der Anpassung von Open-Source-Anwendungen, um TLS 1.3 zu verwenden. Die TLS Gruppe bestand aus Personen aus Japan, Großbritannien und Mauritius über das cyberstorm.mu Team. Diese Arbeit wurde im IETF 101 Hackathon in London fortgesetzt, und der IETF 102 Hackathon in Montreal.wolfSSL ermöglichte die Verwendung von TLS 1.3 ab Version 3.11.1, veröffentlicht im Mai 2017. Als erste kommerzielle TLS 1.3 Implementierung unterstützte wolfSSL 3.11.1 Draft 18 und unterstützt jetzt Draft 28, die finale Version sowie viele ältere Versionen. Eine Reihe von Blogs wurde auf der Performance-Differenz zwischen TLS 1.2 und 1.3 veröffentlicht. Im September 2018 veröffentlichte das beliebte OpenSSL-Projekt Version 1.1.1 seiner Bibliothek, in der die Unterstützung von TLS 1.3 "die neue Hauptfunktion" war. Sicherheit im Straßenverkehr Die Electronic Frontier Foundation lobte TLS 1.3 und äußerte Besorgnis über das Variantenprotokoll Enterprise Transport Security (ETS), das wichtige Sicherheitsmaßnahmen in TLS 1.3 absichtlich deaktiviert. Ursprünglich als Enterprise TLS (eTLS) bezeichnet, ist ETS ein veröffentlichter Standard, der als "ETSI TS103523-3", "Middlebox Security Protocol, Part3: Enterprise Transport Security" bekannt ist. Es ist für die Verwendung ausschließlich innerhalb proprietärer Netzwerke wie Bankensysteme gedacht. ETS unterstützt keine Vorwärtsgeheimnis, um Drittunternehmen, die mit den proprietären Netzwerken verbunden sind, in der Lage zu sein, ihren privaten Schlüssel zur Überwachung des Netzwerkverkehrs für die Erkennung von Malware zu nutzen und Audits zu vereinfachen. Trotz der beanspruchten Vorteile warnte der EFF, dass der Verlust der Vorwärtsgeheimnis es leichter machen könnte, Daten zu exponieren und zu sagen, dass es bessere Möglichkeiten gibt, den Verkehr zu analysieren. Digitale Zertifikate Ein digitales Zertifikat bescheinigt das Eigentum eines öffentlichen Schlüssels durch das benannte Subjekt des Zertifikats und gibt bestimmte erwartete Nutzungen dieses Schlüssels an. Dies ermöglicht es anderen (Anbieter) auf Unterschriften oder auf Behauptungen des privaten Schlüssels zu vertrauen, die dem zertifizierten öffentlichen Schlüssel entsprechen. Keystores und Trust Stores können in verschiedenen Formaten sein, wie z.B. .pem, .crt, .pfx und jks Certificate Authority TLS setzt typischerweise auf eine Reihe von vertrauenswürdigen Drittzertifikatsbehörden, um die Echtheit von Zertifikaten zu ermitteln. Trust wird in der Regel in einer Liste von Zertifikaten verankert, die mit User Agent Software verteilt werden, und kann von der vertrauenswürdigen Partei geändert werden. Laut Netcraft, der aktive TLS-Zertifikate überwacht, ist die marktführende Zertifizierungsbehörde (CA) seit Beginn ihrer Umfrage Symantec (oder VeriSign, bevor die Authentifizierungs-Dienste-Geschäftseinheit von Symantec gekauft wurde). Ab 2015 entfiel Symantec auf knapp ein Drittel aller Zertifikate und 44% der gültigen Zertifikate, die von den 1 Million verkehrsreichsten Websites verwendet werden, wie Netcraft. Im Jahr 2017 verkaufte Symantec sein TLS/SSL-Geschäft an DigiCert. In einem aktualisierten Bericht wurde gezeigt, dass IdenTrust, DigiCert und Sectigo seit Mai 2019 die Top-3-Zertifikatsbehörden sind. Als Folge der Auswahl von X.509-Zertifikaten sind Bescheinigungsbehörden und eine öffentliche Schlüsselinfrastruktur erforderlich, um die Beziehung zwischen einem Zertifikat und seinem Eigentümer zu überprüfen sowie die Gültigkeit von Zertifikaten zu generieren, zu unterzeichnen und zu verwalten. Während dies bequemer sein kann als die Überprüfung der Identitäten über ein Netz von Vertrauen, die 2013 Massenüberwachung Offenlegungen machte es weit verbreiteter bekannt, dass Zertifikatsbehörden sind ein Schwachpunkt aus Sicherheitsaspekten, so dass man-in-the-middle Angriffe (MITM), wenn die Bescheinigungsbehörde kooperiert (oder kompromittiert.) Algorithms Schlüsselaustausch oder Schlüsselvereinbarung Bevor ein Client und Server mit dem Austausch von durch TLS geschützten Informationen beginnen können, müssen sie sicher einen Verschlüsselungsschlüssel und eine Chiffre austauschen, um Daten zu verschlüsseln (siehe § Cipher). Unter den für Schlüsselaustausch/Vereinbarung verwendeten Methoden sind: öffentliche und private Schlüssel, die mit RSA (denotiert TLS_RSA im TLS-Handshake-Protokoll), Diffie–Hellman (TLS_DH,) ephemeral Diffie–Hellman (TLS_DHE,) elliptic-curve Diffie–Hellman (TLS_ECDH, Secure) generiert werden. Die TLS_DH_anon- und TLS_ECDH_anon-Schlüsselvereinbarungsmethoden authentifizieren den Server oder den Benutzer nicht und werden daher nur selten verwendet, weil diese für Man-in-the-Middle-Angriffe anfällig sind. Nur TLS_DHE und TLS_ECDHE sorgen für Vorwärtsgeheimnis. Öffentliche Schlüsselzertifikate, die während des Austauschs/der Vereinbarung verwendet werden, variieren auch in der Größe der öffentlichen/privaten Verschlüsselungsschlüssel während des Austauschs und damit der Robustheit der bereitgestellten Sicherheit. Im Juli 2013 kündigte Google an, dass es nicht mehr 1024-Bit öffentliche Schlüssel verwenden würde und stattdessen auf 2048-Bit-Tasten wechseln würde, um die Sicherheit der TLS-Verschlüsselung zu erhöhen, die es seinen Benutzern bietet, weil die Verschlüsselungsstärke direkt mit der Schlüsselgröße verbunden ist. Cipher Notes Datenintegrität Für die Datenintegrität wird ein Nachrichtenauthentifizierungscode (MAC) verwendet. HMAC wird für CBC-Modus von Block-Ciphers verwendet. Authenticated Verschlüsselung (AEAD) wie GCM-Modus und CCM-Modus verwendet AEAD-integriertes MAC und verwendet HMAC nicht. HMAC-basierte PRF oder HKDF wird für TLS-Handshake verwendet. Anträge und Annahme Im Anwendungsdesign wird TLS in der Regel auf den Transport Layer Protokollen implementiert und alle protokollbezogenen Daten von Protokollen wie HTTP, FTP, SMTP, NNTP und XMPP verschlüsselt. Historisch wurde TLS vor allem mit zuverlässigen Transportprotokollen wie dem Transmission Control Protocol (TCP) eingesetzt. Es wurde aber auch mit datengramorientierten Transportprotokollen, wie dem User Datagram Protocol (UDP) und dem Datagram Congestion Control Protocol (DCCP) implementiert, deren Nutzung unabhängig mit dem Begriff Datagram Transport Layer Security (DTLS) standardisiert wurde. Webseiten Eine primäre Verwendung von TLS ist die Sicherung des World Wide Web-Verkehrs zwischen einer Website und einem mit dem HTTP-Protokoll verschlüsselten Webbrowser. Diese Verwendung von TLS zur Sicherung des HTTP-Verkehrs stellt das HTTPS-Protokoll dar. Hinweise Webbrowser Ab April 2016 unterstützen die neuesten Versionen aller großen Webbrowser TLS 1.0, 1.1 und 1.2 und haben sie standardmäßig aktiviert.Allerdings unterstützen nicht alle unterstützten Microsoft-Betriebssysteme die neueste Version von IE. Darüber hinaus unterstützen viele Betriebssysteme derzeit mehrere Versionen von IE, aber dies hat sich geändert nach Microsofts Internet Explorer Support Lifecycle Policy FAQ, "ab Januar 12, 2016, nur die aktuellste Version von Internet Explorer für ein unterstütztes Betriebssystem erhalten technische Unterstützung und Sicherheitsupdates." Die Seite geht dann auf die Liste der neuesten unterstützten Version von IE zu diesem Zeitpunkt für jedes Betriebssystem. Das nächste kritische Datum wäre, wenn ein Betriebssystem das Ende der Lebensphase erreicht, das in Microsofts Windows-Lifecycle-Factsheet ist. Gegen bekannte Angriffe sind noch nicht genug: Mitigations gegen POODLE-Angriff: Einige Browser verhindern bereits Rückfall auf SSL 3.0; diese Minderung muss jedoch nicht nur von Clients, sondern auch von Servern unterstützt werden. Die Deaktivierung von SSL 3.0 selbst, die Implementierung von "Anti-POODLE Record Splitting" oder die Verweigerung von CBC-Chiffern in SSL 3.0 ist erforderlich. Google Chrome: komplett (TLS_FALLBACK_SCSV ist implementiert, da Version 33, Fallback zu SSL 3.0 deaktiviert ist, da Version 39, SSL 3.0 selbst standardmäßig seit Version 40 deaktiviert ist. Die Unterstützung von SSL 3.0 selbst wurde seit Version 44 fallen gelassen.) Mozilla Firefox: komplett (Unterstützung von SSL 3.0 selbst ist seit Version 39 fallengelassen. SSL 3.0 selbst ist standardmäßig deaktiviert und fallenback auf SSL 3.0 sind seit Version 34 deaktiviert, TLS_ FALLBACK_SCSV ist seit Version 35 implementiert. In ESR ist SSL 3.0 selbst standardmäßig deaktiviert und TLS_ FALLBACK_SCSV ist seit ESR 31.3. implementiert Internet Explorer: Teilweise (nur in Version 11, SSL 3.0 ist standardmäßig seit April 2015 deaktiviert. Version 10 und älter sind immer noch verletzlich gegen POODLE.)Opera: komplett (TLS_FALLBACK_SCSV ist implementiert, da die Version 20, "anti-POODLE Record Splitting", die nur mit der clientseitigen Implementierung wirksam ist, implementiert ist, da die Version 25, SSL 3.0 selbst standardmäßig seit der Version 27 deaktiviert ist. Die Unterstützung von SSL 3.0 selbst wird seit Version 31. fallen gelassen.Safari: komplett (nur auf OS X 10.8 und später und iOS 8, CBC-Ciphers im Fallback auf SSL 3.0 wird verleugnet, aber das bedeutet, dass es RC4 verwenden wird, was auch nicht empfohlen wird. Unterstützung von SSL 3.0 selbst wird auf OS X 10.11 und später und iOS 9.) Mitigation gegen RC4-Angriffe: Google Chrome deaktiviert RC4 außer als Rückfall seit Version 43. RC4 ist seit Chrome 48 deaktiviert. Firefox deaktiviert RC4 außer als Rückfall seit Version 36. Firefox 44 deaktiviert RC4 standardmäßig. Opera deaktiviert RC4 außer als Rückfall seit Version 30. RC4 ist seit Opera 35 deaktiviert. Internet Explorer für Windows 7 / Server 2008 R2 und für Windows 8 / Server 2012 haben die Priorität von RC4 auf den niedrigsten gesetzt und kann auch RC4 außer als Rückfall durch Registry-Einstellungen deaktivieren. Internet Explorer 11 Mobile 11 für Windows Phone 8.1 deaktivieren RC4 außer als Rückfall, wenn kein anderer aktivierter Algorithmus funktioniert. Edge und IE 11 deaktivieren RC4 komplett im August 2016. Mitiging gegen FREAK-Angriff: Der Android Browser mit Android 4.0 und älter ist immer noch anfällig für den FREAK-Angriff. Internet Explorer 11 Mobile ist noch anfällig für den FREAK-Angriff. Google Chrome, Internet Explorer (Desktop,) Safari (Desktop & Mobile,) und Opera (Mobile) haben FREAK-Abmilderungen an Ort und Stelle. Mozilla Firefox auf allen Plattformen und Google Chrome unter Windows wurden nicht von FREAK betroffen. Die meisten SSL- und TLS-Programmierbibliotheken sind frei und Open Source-Software. BoringSSL, eine Gabel von OpenSSL für Chrome/Chromium und Android sowie andere Google-Anwendungen. Botan, eine BSD-lizenzierte kryptographische Bibliothek in C++ geschrieben. BSAFE Micro Edition Suite: Multi-Plattform-Implementierung von TLS in C geschrieben mit einem FIPS-validierten kryptographischen Modul BSAFE SSL-J: eine TLS-Bibliothek, die sowohl eine proprietäre API als auch JSSE API bietet, mit FIPS-validierten kryptographischen Modulen Kryptlib: eine tragbare Open Source-Kryptographie-Bibliothek (inklusive TLS/SSL-Implementierung)Delphi Programmierer, die jetzt eine Bibliothek verwenden können. GnuTLS: eine kostenlose Implementierung (LGPL lizenziert) Java Secure Socket Extension: Eine Java-Implementierung im Java Runtime Environment unterstützte TLS 1.1 und 1.2 ab Java 7. (TLS 1.1/1.2 wurden zunächst standardmäßig für Client auf Java 7 deaktiviert, aber im Januar 2017 aktiviert.) Java 11 unterstützt TLS 1.3. LibreSSL: eine Gabel von OpenSSL durch OpenBSD-Projekt. MatrixSSL: eine dual lizenzierte Implementierung mbed TLS (vorher PolarSSL): Eine winzige SSL-Bibliothek-Implementierung für eingebettete Geräte, die für die einfache Nutzung von Network Security Services konzipiert ist: FIPS 140 validierte Open Source-Bibliothek OpenSSL: eine kostenlose Implementierung (BSD-Lizenz mit einigen Erweiterungen) SChannel: eine Implementierung von SSL und TLS Microsoft Windows als Teil seines Pakets. Secure Transport: eine Implementierung von SSL und TLS in OS X und iOS im Rahmen ihrer Pakete.wolfSSL (bisher CyaSSL): Embedded SSL/TLS Bibliothek mit einem starken Fokus auf Geschwindigkeit und Größe. Ein auf der ACM-Konferenz 2012 über Computer- und Kommunikationssicherheit vorgestelltes Papier zeigte, dass wenige Anwendungen einige dieser SSL-Bibliotheken korrekt verwendet haben, was zu Schwachstellen führt. Laut den Autoren "die Hauptursache der meisten dieser Schwachstellen ist das schreckliche Design der APIs zu den zugrunde liegenden SSL-Bibliotheken. Statt hochrangige Sicherheitseigenschaften von Netzwerktunneln wie Vertraulichkeit und Authentifizierung auszudrücken, zeigen diese APIs Low-Level-Details des SSL-Protokolls an Anwendungsentwickler. Daher verwenden Entwickler oft SSL-APIs falsch, missinterpretieren und missverstehen ihre vielfältigen Parameter, Optionen, Nebenwirkungen und Rückgabewerte." Andere Anwendungen Das Simple Mail Transfer Protocol (SMTP) kann auch durch TLS geschützt werden. Diese Anwendungen verwenden öffentliche Schlüsselzertifikate, um die Identität von Endpunkten zu überprüfen. TLS kann auch zum Tunneln eines gesamten Netzwerkstapels verwendet werden, um ein VPN zu erstellen, das bei OpenVPN und OpenConnect der Fall ist. Viele Anbieter haben inzwischen die Verschlüsselungs- und Authentifizierungsfunktionen von TLS mit Berechtigung geheiratet. Seit den späten 1990er-Jahren hat es auch eine erhebliche Entwicklung bei der Erstellung von Client-Technologie außerhalb von Web-Browsern gegeben, um die Unterstützung für Client/Server-Anwendungen zu ermöglichen. Im Vergleich zu herkömmlichen IPsec VPN-Technologien hat TLS einige inhärente Vorteile in Firewall und NAT-Traversal, die es einfacher machen, für große Remote-Access-Populationen zu verwalten. TLS ist auch ein Standardverfahren zum Schutz von Session Initiation Protocol (SIP) Application Signaling. TLS kann zur Authentifizierung und Verschlüsselung der SIP-Signalisierung im Zusammenhang mit VoIP und anderen SIP-basierten Anwendungen verwendet werden. Security SSL 2.0 SSL 2.0 wurde auf vielfältige Weise fehlerhaft: Identische kryptographische Schlüssel wurden zur Nachrichtenauthentifizierung und Verschlüsselung verwendet. (In SSL 3.0 können MAC-Geheimnisse größer sein als Verschlüsselungsschlüssel, so können Nachrichten tamper-resistent bleiben, auch wenn Verschlüsselungsschlüssel gebrochen werden.)SSL 2.0 hatte eine schwache MAC-Konstruktion, die die MD5 Hash-Funktion mit einem geheimen Präfix verwendet, so dass es empfindlich auf Längenerweiterung Angriffe. SSL 2.0 hatte keinen Schutz für den Handshake, was bedeutet, dass ein Mann-in-the-middle Downgrade-Angriff unentdeckt gehen konnte. SSL 2.0 nutzte die TCP-Verbindung, um das Ende der Daten anzuzeigen. Dies bedeutete, dass Truncation-Angriffe möglich waren: Der Angreifer schmiedet einfach eine TCP FIN, so dass der Empfänger nicht bewusst ist, dass ein unrechtmäßiges Ende der Datennachricht (SSL 3.0 behoben dieses Problem durch eine explizite Schließung Alarm). SSL 2.0 nahm einen einzigen Dienst und ein festes Domain-Zertifikat an, das mit dem Standardmerkmal der virtuellen Hosting in Webservern zusammengestoßen ist. Dies bedeutet, dass die meisten Websites von der Nutzung von SSL praktisch beeinträchtigt wurden. SSL 2.0 wurde standardmäßig deaktiviert, beginnend mit Internet Explorer 7, Mozilla Firefox 2, Opera 9.5 und Safari. Die Unterstützung für SSL 2.0 (und schwache 40-Bit- und 56-Bit-Ciphers) wurde ab Version 10 vollständig von Opera entfernt. SSL 3.0 SSL 3.0 verbesserte sich auf SSL 2.0 durch Hinzufügen von SHA-1-basierten Chiffren und Unterstützung für die Zertifizierung. Aus Sicherheitsgründen sollte SSL 3.0 als weniger wünschenswert angesehen werden als TLS 1.0. Die SSL 3.0 Chiffre Suiten haben einen schwächeren Schlüsselableitungsprozess; die Hälfte des etablierten Masterschlüssels ist vollständig abhängig von der MD5 Hash-Funktion, die nicht kollisionsbeständig ist und daher nicht als sicher gilt. Unter TLS 1.0 hängt der etablierte Master-Schlüssel sowohl von MD5 als auch von SHA-1 ab, so dass sein Ableitungsprozess derzeit nicht als schwach angesehen wird. Aus diesem Grund können SSL 3.0-Implementierungen nicht unter FIPS 140-2 validiert werden. Im Oktober 2014 wurde eine Schwachstelle bei der Gestaltung von SSL 3.0 gemeldet, wobei der CBC-Betriebsmodus mit SSL 3.0 für den Padding-Angriff anfällig wurde (siehe #POODLE-Angriff). TLS TLS hat eine Vielzahl von Sicherheitsmaßnahmen: Schutz vor Abstieg des Protokolls auf eine vorherige (weniger sichere) Version oder eine schwächere Chiffre-Suite. Nummerierung nachfolgender Applikationsprotokolle mit einer Sequenznummer und Verwendung dieser Sequenznummer in den Nachrichtenauthentifizierungscodes (MACs). Mit einem mit einem Schlüssel erweiterten Nachrichtenverdau (so kann nur ein Schlüsselhalter den MAC überprüfen). Die HMAC-Konstruktion, die von den meisten TLS-Cipher-Suiten verwendet wird, ist in RFC 2104 (SSL 3.0 verwendet eine andere Hash-basierte MAC). Die Nachricht, die den Handshake (Finished) beendet, sendet einen Hash aller ausgetauschten Handshake-Nachrichten von beiden Parteien. Die Pseudorandom-Funktion spaltet die Eingabedaten in die Hälfte und verarbeitet jeden mit einem anderen Hashing-Algorithmus (MD5 und SHA-1), dann XORs sie zusammen, um den MAC zu erstellen. Dies bietet Schutz, auch wenn einer dieser Algorithmen als verletzlich empfunden wird. Angriffe gegen TLS/SSL Signifikante Angriffe gegen TLS/SSL sind unten aufgeführt. Im Februar 2015 veröffentlichte IETF einen informationellen RFC, der die verschiedenen bekannten Angriffe auf TLS/SSL zusammenfasste. Eine Verwundbarkeit des Neuverhandlungsverfahrens wurde im August 2009 entdeckt, was zu Klartextinjektionsangriffen gegen SSL 3.0 und alle aktuellen Versionen von TLS führen kann. Zum Beispiel ermöglicht es einem Angreifer, der eine https-Verbindung entführen kann, um ihre eigenen Anfragen in den Anfang des Gesprächs zu spleiern, das der Client mit dem Webserver hat. Der Angreifer kann die Client-Server-Kommunikation nicht wirklich entschlüsseln, so ist es anders als ein typischer Man-in-the-Middle-Angriff. Ein kurzfristiger Fix ist, dass Webserver aufhören, eine Neuverhandlung zuzulassen, was in der Regel keine anderen Änderungen erfordert, es sei denn, die Client-Zertifikat-Authentifizierung wird verwendet. Um die Sicherheitslücke zu beheben, wurde für TLS eine Renegotiation Indikationserweiterung vorgeschlagen. Es erfordert den Client und den Server, um Informationen über frühere Handshakes in jeder Neuverhandlung Handshakes aufzunehmen und zu überprüfen. Diese Erweiterung ist zu einem vorgeschlagenen Standard geworden und der Nummer RFC 5746 zugeordnet. Die RFC wurde von mehreren Bibliotheken durchgeführt. Downgrade-Angriffe: FREAK-Angriff und Logjam-Angriff Ein Protokoll-Downgrade-Angriff (auch als Version Rollback-Angriff bezeichnet) trickst einen Webserver in Verhandlungsverbindungen mit früheren Versionen von TLS (wie SSLv2), die seit langem als unsicher aufgegeben wurden. Frühere Änderungen an den ursprünglichen Protokollen, wie False Start (gewählt und aktiviert durch Google Chrome) oder Snap Start, angeblich eingeführt begrenzte TLS-Protokoll Downgrade-Angriffe oder erlaubte Änderungen an der Cipher-Suite-Liste, die vom Client an den Server gesendet. Dabei kann es einem Angreifer gelingen, die Auswahl der Chiffre-Suiten zu beeinflussen, indem er versucht, die ausgehandelte Chiffre-Suite entweder einen schwächeren symmetrischen Verschlüsselungsalgorithmus oder einen schwächeren Schlüsselaustausch zu verwenden. Ein auf einer ACM-Konferenz über Computer- und Kommunikationssicherheit im Jahr 2012 vorgestelltes Papier zeigte, dass die False Start-Erweiterung gefährdet war: Unter bestimmten Umständen kann es einem Angreifer ermöglicht werden, die Verschlüsselungsschlüssel offline wiederherzustellen und die verschlüsselten Daten zuzugreifen. Verschlüsselung Downgrade-Angriffe können Server und Clients zwingen, eine Verbindung mit kryptographisch schwachen Schlüsseln zu verhandeln. 2014 wurde ein Mann-in-the-middle-Angriff namens FREAK entdeckt, der den OpenSSL-Stacks, den Standard-Android-Webbrowser und einige Safari-Browser beeinflusst. Der Angriff bestand darin, Server mit kryptographisch schwachen 512-Bit-Verschlüsselungsschlüsseln zu verhandeln. Logjam ist ein im Mai 2015 entdeckter Sicherheits-Exploit, der die Möglichkeit nutzt, Legacy-Export-Klasse 512-bit Diffie-Hellman-Gruppen aus den 1990er Jahren zu verwenden. Es zwingt anfällige Server, um kryptographisch schwache 512-Bit Diffie-Hellman-Gruppen zu schwächen. Ein Angreifer kann dann die Schlüssel, die der Client und der Server bestimmen, mit dem Diffie-Hellman-Schlüsselaustausch ableiten. Cross-Protocol-Angriffe: WEITER Der DROWN-Angriff ist ein Exploit, der Server angreift, die moderne SSL/TLS-Protokoll-Suiten unterstützen, indem sie ihre Unterstützung für das veraltete, unsichere SSLv2-Protokoll ausnutzen, um einen Angriff auf Verbindungen mit aktuellen Protokollen zu nutzen, die sonst sicher wären. DROWN nutzt eine Schwachstelle in den verwendeten Protokollen und der Konfiguration des Servers anstelle eines bestimmten Implementierungsfehlers. Alle Details von DROWN wurden im März 2016 zusammen mit einem Patch für den Exploit angekündigt. Zu dieser Zeit gehörten mehr als 81.000 der Top 1 Million der beliebtesten Websites zu den TLS-geschützten Websites, die für den DROWN-Angriff anfällig waren. BEAST-Angriff Am 23. September 2011 Forscher Thai Duong und Juliano Rizzo demonstrierten einen Konzeptnachweis mit dem Namen BEAST (Browser Exploit Against SSL/TLS) mit einem Java-Apfel, um gleiche Ursachen-Richtlinienzwänge zu verletzen, für eine lange bekannte Cipher Blockchaining (CBC) Schwachstelle in TLS 1.0: ein Angreifer beobachtet 2 aufeinanderfolgende Ciphertextblöcke C0, C1 kann testen, wenn der Klartextblock P1 gleich x ist C0 ⊕ {\displaystyle \oplus } C1; gemäß CBC-Betrieb C2 = E(C1 ⊕ {\displaystyle \oplus } P2) = E(C1 ⊕ {\displaystyle \oplus } x ⊕ {\displaystyle \oplus } C0 ⊕ {\displaystyle \oplus } C1) = E(C0 ⊕ {\displaystyle \oplus } x,), die gleich C1 sein wird, wenn x = P1.Practical Exploits bisher nicht für diese Schwachstelle nachgewiesen worden waren, die ursprünglich von Phillip Rogaway im Jahr 2002 entdeckt wurde. Die Sicherheitslücke des Angriffs war 2006 mit TLS 1.1 behoben worden, aber TLS 1.1 hatte vor dieser Angriffsdemonstration keine breite Annahme gesehen. RC4 als Stream-Cipher ist immun gegen BEAST-Angriff. Daher wurde RC4 weithin als Weg verwendet, um BEAST-Angriff auf der Serverseite zu mildern. Im Jahr 2013 fanden Forscher jedoch mehr Schwächen in RC4. Danach wurde RC4 auf Serverseite nicht mehr empfohlen. Chrome und Firefox selbst sind nicht anfällig für BEAST-Angriff, aber Mozilla aktualisiert ihre NSS-Bibliotheken, um BEAST-ähnliche Angriffe zu mindern. NSS wird von Mozilla Firefox und Google Chrome verwendet, um SSL zu implementieren. Einige Webserver, die eine defekte Implementierung der SSL-Spezifikation haben, können damit aufhören zu arbeiten. Microsoft veröffentlichte Security Bulletin MS12-006 am 10. Januar 2012, die die BEAST Schwachstelle durch Änderung der Art, dass die Windows Secure Channel (SChannel) Komponente verschlüsselte Netzwerkpakete vom Server-Ende sendet. Benutzer des Internet Explorers (vor Version 11), die auf älteren Versionen von Windows (Windows 7, Windows 8 und Windows Server 2008 R2) laufen, können die Nutzung von TLS auf 1,1 oder höher beschränken. Apple hat die Schwachstelle von BEAST behoben, indem 1/n-1 Split implementiert und standardmäßig in OS X Mavericks, veröffentlicht am 22. Oktober 2013, eingeschaltet wird. CRIME und BREACH Angriffe Die Autoren des BEAST-Angriffs sind auch die Schöpfer des späteren CRIME-Angriffs, der es einem Angreifer ermöglichen kann, den Inhalt von Web-Cookies wiederherzustellen, wenn die Datenkompression zusammen mit TLS verwendet wird. Wenn verwendet, um den Inhalt von geheimen Authentifizierungs-Cookies wiederherzustellen, ermöglicht es einem Angreifer, Sitzungs-Hijacking auf einer authentifizierten Web-Session durchzuführen. Während der CRIME-Angriff als allgemeiner Angriff präsentiert wurde, der effektiv gegen eine Vielzahl von Protokollen arbeiten konnte, einschließlich, aber nicht beschränkt auf TLS, und Anwendungs-Schicht-Protokolle wie SPDY oder HTTP, nur Exploits gegen TLS und SPDY wurden in Browsern und Servern nachgewiesen und weitgehend gemildert. Der CRIME-Exploit gegen HTTP-Kompression wurde überhaupt nicht abgemildert, obwohl die Autoren von CRIME davor gewarnt haben, dass diese Schwachstelle noch weit verbreiteter sein könnte als SPDY und TLS-Kompression kombiniert. Im Jahr 2013 wurde eine neue Instanz des CRIME-Angriffs gegen die HTTP-Komprimation, gegraben BREACH, bekannt gegeben. Basierend auf dem CRIME-Angriff kann ein BREACH-Angriff Login-Token, E-Mail-Adressen oder andere sensible Informationen von TLS verschlüsselten Web-Verkehr in nur 30 Sekunden (je nach Anzahl der zu extrahierenden Bytes) extrahieren, sofern der Angreifer das Opfer in einen Besuch einer bösartigen Web-Link trickst oder in der Lage ist, Inhalte in gültige Seiten zu injizieren, die der Nutzer besucht (zt). Alle Versionen von TLS und SSL sind von BREACH unabhängig vom verwendeten Verschlüsselungsalgorithmus oder Cipher gefährdet. Im Gegensatz zu früheren Instanzen von CRIME, die durch das Abschalten von TLS Kompression oder SPDY Header Kompression erfolgreich verteidigt werden können, nutzt BREACH die HTTP-Kompression aus, die nicht realistisch ausgeschaltet werden kann, da praktisch alle Webserver darauf vertrauen, die Datenübertragungsgeschwindigkeiten für Benutzer zu verbessern. Dies ist eine bekannte Einschränkung von TLS, da sie gegen die zu schützenden Anwendungsschichtdaten anfällig ist. Timing-Angriffe auf Padding Frühere TLS-Versionen waren gegen den 2002 entdeckten Padding-Oracle-Angriff anfällig. Eine neue Variante, genannt Lucky Thirteen-Angriff, wurde 2013 veröffentlicht. Einige Experten haben auch empfohlen, Triple-DES CBC zu vermeiden. Da die letzten unterstützten Chiffre entwickelt, um jedes Programm mit Windows XP SSL/TLS-Bibliothek wie Internet Explorer unter Windows XP zu unterstützen sind RC4 und Triple-DES, und da RC4 jetzt depreciert ist (siehe Diskussion über RC4-Angriffe,) macht es schwierig, jede Version von SSL für jedes Programm mit dieser Bibliothek auf XP zu unterstützen. Ein Fix wurde als Erweiterung Encrypt-then-MAC zur TLS-Spezifikation freigegeben, veröffentlicht als RFC 7366. Der Lucky Thirteen-Angriff kann in TLS 1.2 mit nur AES_GCM-Kiffern gemildert werden; AES_CBC bleibt verletzlich. POOD-Angriff Am 14. Oktober 2014 veröffentlichten Google-Forscher eine Schwachstelle bei der Gestaltung von SSL 3.0, was die CBC-Betriebsart mit SSL 3.0 für einen Padding-Angriff anfällig macht (CVE-2014-3566). Sie nannten diesen Angriff POODLE (Padding Oracle On Downgraded Legacy Encryption). Im Durchschnitt müssen Angreifer nur 256 SSL 3.0-Anfragen stellen, um einen Byte verschlüsselter Nachrichten zu enthüllen. Obwohl diese Schwachstelle nur in SSL 3.0 vorhanden ist und die meisten Clients und Server TLS 1.0 unterstützen und oben, alle großen Browser freiwillig auf SSL 3.0 herunterfahren, wenn die Handshakes mit neueren Versionen von TLS scheitern, es sei denn, sie bieten die Möglichkeit für einen Benutzer oder Administrator, SSL 3.0 und den Benutzer oder Administrator deaktivieren. Daher kann der Man-in-the-Middle zunächst einen Versions-Rollback-Angriff durchführen und diese Schwachstelle ausnutzen. Am 8. Dezember 2014 wurde eine Variante von POODLE angekündigt, dass Auswirkungen TLS-Implementierungen, die Padding Byte-Anforderungen nicht ordnungsgemäß durchsetzen. RC4-Angriffe Trotz der Existenz von Angriffen auf RC4, die seine Sicherheit brach, wurden Chiffre Suiten in SSL und TLS, die auf RC4 basierten, noch vor 2013 als sicher angesehen, basierend auf der Art, wie sie in SSL und TLS verwendet wurden. Im Jahr 2011 wurde die RC4-Suite als Arbeit rund um den BEAST-Angriff empfohlen. Neue Angriffsformen, die im März 2013 offenbart wurden, zeigten die Durchführbarkeit des RC4 in TLS, was darauf hindeutet, dass es für BEAST kein gutes Werk war. Ein Angriffsszenario wurde von AlFardan, Bernstein, Paterson, Poettering und Schuldt vorgeschlagen, die neu entdeckte statistische Bias in der RC4-Schlüsseltabelle verwendet, um Teile des Klartextes mit einer Vielzahl von TLS-Verschlüsselungen wiederherzustellen.Ein Angriff auf RC4 in TLS und SSL, der 13 × 220 Verschlüsselungen benötigt, um RC4 zu brechen, wurde am 8. Juli 2013 vorgestellt und später in der begleitenden Präsentation auf einem USENIX Security Symposium im August 2013 als möglich beschrieben. Im Juli 2015 machen die nachfolgenden Verbesserungen des Angriffs es immer praktischer, die Sicherheit von RC4-verschlüsselten TLS zu besiegen. Wie viele moderne Browser wurden entwickelt, um BEAST-Angriffe zu besiegen (außer Safari für Mac OSX 10.7 oder früher, für iOS 6 oder früher, und für Windows; siehe § Web-Browser,) RC4 ist nicht mehr eine gute Wahl für TLS 1.0. Die von dem BEAST-Angriff in der Vergangenheit betroffenen CC-Chiffraturen sind zu einer beliebteren Wahl zum Schutz geworden. Mozilla und Microsoft empfehlen, RC4 zu deaktivieren. RFC 7465 verbietet die Verwendung von RC4-Cipher-Suiten in allen Versionen von TLS. Am 1. September 2015 gaben Microsoft, Google und Mozilla bekannt, dass RC4-Cipher-Suiten in ihren Browsern standardmäßig deaktiviert werden würden (Microsoft Edge, Internet Explorer 11 unter Windows 7/8.1/10, Firefox und Chrome) Anfang 2016. Der Truncation-Angriff A TLS (Logout-)Truncation-Angriff blockiert die Account-Logout-Anfragen eines Opfers, so dass der Benutzer unwissentlich in einen Web-Service eingeloggt bleibt. Wenn die Anfrage zur Anmeldung gesendet wird, injiziert der Angreifer eine unverschlüsselte TCP FIN-Nachricht (keine Daten vom Absender) um die Verbindung zu schließen. Der Server erhält daher nicht die Logout-Anfrage und ist sich der abnormalen Kündigung nicht bewusst. Veröffentlicht im Juli 2013, der Angriff verursacht Web-Dienste wie Gmail und Hotmail, um eine Seite anzuzeigen, die den Benutzer informiert, dass sie erfolgreich abgeschlossen haben, während sicherzustellen, dass der Browser des Benutzers die Berechtigung mit dem Dienst behält, so dass ein Angreifer mit anschließendem Zugriff auf den Browser Zugriff und die Kontrolle über das eingeloggte Konto des Benutzers. Der Angriff basiert nicht auf der Installation von Malware auf dem Computer des Opfers; Angreifer brauchen sich nur zwischen dem Opfer und dem Webserver (z.B. durch die Einrichtung eines Rogue Wireless Hotspots). Diese Sicherheitslücke erfordert auch Zugriff auf den Computer des Opfers. Eine andere Möglichkeit besteht darin, dass bei der Verwendung von FTP die Datenverbindung eine falsche FIN im Datenstrom haben kann und wenn die Protokollregeln zum Austausch von close_notify-Benachrichtigungen nicht an einer Datei eingehalten werden können. Unholy PAC Angriff Dieser Angriff, der Mitte 2016 entdeckt wurde, nutzt Schwächen im Web Proxy Autodiscovery Protocol (WPAD) aus, um die URL, die ein Webbenutzer versucht, über einen TLS-fähigen Weblink zu erreichen. Die Weitergabe einer URL kann die Privatsphäre eines Nutzers verletzen, nicht nur wegen der aufgerufenen Website, sondern auch weil URLs manchmal verwendet werden, um Nutzer zu authentifizieren. Dokument-Sharing-Dienste, wie die von Google und Dropbox angeboten, arbeiten auch daran, einen Benutzer einen Sicherheits-Token zu senden, der in der URL enthalten ist. Ein Angreifer, der solche URLs erhält, kann den vollen Zugriff auf das Konto oder die Daten eines Opfers erhalten. Der Exploit arbeitet gegen fast alle Browser und Betriebssysteme. Sweet32 Angriff Der Sweet32-Angriff bricht alle 64-Bit-Block-Chiffren, die im CBC-Modus verwendet werden, wie in TLS verwendet, indem er einen Geburtstagsangriff und entweder einen Man-in-the-middle-Angriff oder eine Injektion eines bösartigen JavaScript in eine Webseite ausnutzt. Der Zweck des Man-in-the-Middle-Angriffs oder der JavaScript-Injektion ist es, dem Angreifer zu ermöglichen, genügend Traffic zu erfassen, um einen Geburtstagsangriff zu lagern. Implementierungsfehler: Heartbleed Bug, BERserk-Angriff, Cloudflare bugDer Heartbleed Bug ist eine ernste Schwachstelle, die für die Implementierung von SSL/TLS in der beliebten OpenSSL-Kryptographischen Software-Bibliothek, die die Versionen 1.0.1 bis 1.0.1f betrifft. Diese im April 2014 gemeldete Schwäche ermöglicht Angreifern, private Schlüssel von Servern zu stehlen, die normalerweise geschützt werden sollten. Der Heartbleed Bug ermöglicht es jedem im Internet, den Speicher der Systeme zu lesen, die durch die verletzlichen Versionen der OpenSSL-Software geschützt sind. Dies beeinträchtigt die geheimen privaten Schlüssel, die mit den öffentlichen Zertifikaten verbunden sind, die verwendet werden, um die Dienstleister zu identifizieren und den Verkehr, die Namen und Passwörter der Benutzer und die tatsächlichen Inhalte zu verschlüsseln. Dies ermöglicht Angreifern, die Kommunikation zu übertreffen, Daten direkt von den Diensten und Benutzern zu stehlen und Dienstleistungen und Benutzer zu verkörpern. Die Schwachstelle wird durch einen Puffer-Over-Lese-Bug in der OpenSSL-Software verursacht, und nicht durch einen Defekt in der SSL- oder TLS-Protokollspezifikation. Im September 2014 wurde eine Variante von Daniel Bleichenbachers PKCS#1 v1.5 RSA Signature Forgery Schwachstelle von Intel Security Advanced Threat Research bekannt gegeben. Dieser Angriff, gegraben BERserk, ist ein Ergebnis der unvollständigen ASN.1 Längenentschlüsselung der öffentlichen Schlüsselsignaturen in einigen SSL-Implementierungen und ermöglicht einen Man-in-the-middle-Angriff durch Schmieden einer öffentlichen Schlüsselsignatur. Im Februar 2015, nachdem Medien die versteckte Vorinstallation von Superfish Adware auf einigen Lenovo Notebooks berichtet, fand ein Forscher ein vertrauenswürdiges Root-Zertifikat auf betroffenen Lenovo Maschinen unsicher zu sein, da die Schlüssel leicht mit dem Firmennamen Komodia als Passphrase zugegriffen werden konnte. Die Komodia-Bibliothek wurde entworfen, um Client-Seite TLS/SSL-Verkehr für die elterliche Kontrolle und Überwachung zu abfangen, aber es wurde auch in zahlreichen Adware-Programmen, einschließlich Superfish, verwendet, die oft unbekannt am Computer Benutzer installiert wurden. Diese potenziell unerwünschten Programme installierten wiederum das korrupte Root-Zertifikat, so dass Angreifer den Web-Verkehr vollständig kontrollieren und falsche Websites als authentisch bestätigen. Im Mai 2016 wurde berichtet, dass Dutzende von dänischen HTTPS-geschützten Websites von Visa Inc. anfällig für Angriffe waren, die Hacker injizieren bösartigen Code und gefälschte Inhalte in die Browser der Besucher. Die Angriffe funktionierten, weil die TLS-Implementierung auf den betroffenen Servern unrichtig wieder verwendet Zufallszahlen (Nonces), die nur einmal verwendet werden sollen, um sicherzustellen, dass jeder TLS-Handshake einzigartig ist. Im Februar 2017 erstellte ein Implementierungsfehler, der durch ein einzelnes falsch eingegebenes Zeichen im Code verursacht wurde, der verwendet wurde, um HTML zu parseieren, einen Pufferüberlauffehler auf Cloudflare-Servern. Ähnlich wie bei seinen 2014 entdeckten Auswirkungen auf den Heartbleed Bug erlaubte dieser Überlauffehler, weithin bekannt als Cloudbleed, unbefugte Dritte, Daten im Speicher von Programmen auf den Servern zu lesen – Daten, die sonst durch TLS geschützt sein sollten. Umfrage von Websites, die gegen Angriffe verletzlich sind Ab Juli 2021 schätzte die Trustworthy Internet Movement das Verhältnis von Websites, die für TLS-Angriffe verletzlich sind. Vorwärtsgeheimnis Vorwärtsgeheimnis ist eine Eigenschaft kryptographischer Systeme, die sicherstellt, dass ein Sitzungsschlüssel, der aus einer Reihe von öffentlichen und privaten Schlüsseln abgeleitet wird, nicht beeinträchtigt wird, wenn einer der privaten Schlüssel in der Zukunft beeinträchtigt wird. Ohne Vorwärtsgeheimnis, wenn der private Schlüssel des Servers beeinträchtigt wird, werden nicht nur alle zukünftigen TLS-verschlüsselten Sitzungen mit diesem Server-Zertifikat kompromittiert, sondern auch vergangene Sitzungen, die es verwendet haben (vorgesehen natürlich, dass diese früheren Sitzungen zum Zeitpunkt der Übertragung abgefangen und gespeichert wurden). Eine Implementierung von TLS kann eine Vorwärtsgeheimnis durch die Notwendigkeit der Verwendung von ephemeral Diffie–Hellman Schlüsselaustausch, um Sitzungsschlüssel zu erstellen, und einige bemerkenswerte TLS-Implementierungen tun dies ausschließlich: z.B. Gmail und andere Google HTTPS-Dienste, die OpenSSL verwenden. Viele Clients und Server, die TLS (einschließlich Browser und Webserver) unterstützen, sind jedoch nicht dazu konfiguriert, solche Einschränkungen zu implementieren. In der Praxis, es sei denn, ein Web-Service verwendet Diffie-Hellman-Schlüsselaustausch, um Vorwärtsgeheimnis zu implementieren, alle verschlüsselten Web-Verkehr zu und von diesem Dienst kann von einem Dritten entschlüsselt werden, wenn er den Master (private) Schlüssel des Servers erhält; z.B. mittels einer gerichtlichen Bestellung. Auch wenn Diffie–Hellman Schlüsselaustausch implementiert ist, können serverseitige Session-Management-Mechanismen das Vorwärtsgeheimnis beeinflussen. Die Verwendung von TLS-Sitzungstickets (eine TLS-Erweiterung) bewirkt, dass die Sitzung durch AES128-CBC-SHA256 unabhängig von anderen ausgehandelten TLS-Parametern, einschließlich Vorwärtsgeheimnisse, geschützt wird und die langlebigen TLS-Sitzungskartenschlüssel den Versuch besiegen, das Vorwärtsgeheimnis zu implementieren. Die Stanford University-Forschung im Jahr 2014 fand auch, dass von 473,802 TLS-Servern befragt, 82,9% der Server, die ephemeral Diffie–Hellman (DHE) Schlüsselaustausch zur Unterstützung der Vorwärtsgeheimhaltung bereitstellen, waren mit schwachen Diffie–Hellman-Parametern. Diese schwachen Parameterwahlen könnten die Wirksamkeit der Vorwärtsgeheimnis, die die Server zur Verfügung stellen wollten, möglicherweise beeinträchtigen. Seit Ende 2011 hat Google die Vertrautheit mit TLS standardmäßig an die Benutzer des Gmail-Dienstes, zusammen mit Google Docs und verschlüsselte Suche, unter anderen Dienstleistungen. Seit November 2013 hat Twitter den Nutzern seines Dienstes eine Geheimhaltung mit TLS zur Verfügung gestellt. Ab August 2019 werden ca. 80% der TLS-fähigen Websites konfiguriert, um Cipher Suiten zu verwenden, die die meisten Webbrowser mit Vorwärtsgeheimhaltung versorgen. TLS-Abfang TLS-Abfang (oder HTTPS-Abfang, wenn insbesondere auf dieses Protokoll angewendet) ist die Praxis, einen verschlüsselten Datenstrom abzufangen, um ihn zu entschlüsseln, zu lesen und möglicherweise zu manipulieren, und dann wieder zu verschlüsseln und die Daten auf seinem Weg wieder zu senden. Dies geschieht über einen "transparenten Proxy": die Interception-Software beendet die eingehende TLS-Verbindung, inspiziert den HTTP-Scheintext und erstellt dann eine neue TLS-Verbindung zum Ziel. TLS / HTTPS-Interception wird als Informationssicherheitsmaßnahme von Netzbetreibern verwendet, um in der Lage sein, nach und vor dem Eindringen von schädlichen Inhalten in das Netzwerk, wie Computerviren und andere Malware zu scannen und zu schützen. Solche Inhalte konnten ansonsten nicht erkannt werden, solange sie durch Verschlüsselung geschützt ist, was aufgrund der routinemäßigen Verwendung von HTTPS und anderen sicheren Protokollen immer häufiger der Fall ist. Ein wesentlicher Nachteil der TLS / HTTPS-Abhörung ist, dass es neue Sicherheitsrisiken von sich einführt. Da es einen Punkt gibt, an dem der Netzwerkverkehr unverschlüsselt verfügbar ist, haben Angreifer einen Anreiz, diesen Punkt insbesondere anzugreifen, um Zugang zu sonst sicheren Inhalten zu erhalten. Die Abhörung ermöglicht es dem Netzbetreiber oder Personen, die Zugang zu seinem Abhörsystem erhalten, auch, Man-in-the-Middle-Angriffe gegen Netzwerknutzer durchzuführen. Eine Studie von 2017 ergab, dass "HTTPS-Interception ist anfangs weit verbreitet geworden, und dass Rezeptionsprodukte als Klasse dramatisch negative Auswirkungen auf die Verbindungssicherheit haben." Protokolldetails Das TLS-Protokoll ersetzt Datensätze, die die auszutauschenden Daten in einem bestimmten Format verkapseln (siehe unten). Jeder Datensatz kann komprimiert, gepolstert, mit einem Nachrichtenauthentifizierungscode (MAC) angehängt oder verschlüsselt werden, je nach Zustand der Verbindung. Jeder Datensatz verfügt über ein Content-Typ-Feld, das die Art der gekapselten Daten, ein Längenfeld und ein TLS-Versionsfeld bezeichnet. Die gekapselten Daten können Steuerungs- oder Verfahrensnachrichten der TLS selbst oder einfach die von TLS zu übertragenden Anwendungsdaten sein. Die zum Austausch von Anwendungsdaten durch TLS erforderlichen Spezifikationen (Cipher-Suite, Schlüssel etc.) werden im "TLS-Handshake" zwischen dem Client, der die Daten anfordert, und dem Server, der auf Anfragen reagiert, vereinbart. Das Protokoll definiert daher sowohl die Struktur der in TLS übertragenen Nutzlasten als auch das Verfahren zur Ermittlung und Überwachung der Übertragung. TLS Handshake Beim Start der Verbindung kapselt der Datensatz ein Kontrollprotokoll – das Handshake-Messaging-Protokoll (Contenttyp 22). Dieses Protokoll dient dazu, alle von beiden Seiten benötigten Informationen zum Austausch der eigentlichen Anwendungsdaten durch TLS auszutauschen. Es definiert das Format der Nachrichten und die Reihenfolge ihres Austauschs. Diese können je nach den Anforderungen des Clients und Servers variieren – d.h. es gibt mehrere mögliche Verfahren, um die Verbindung aufzubauen. Dieser erste Austausch führt zu einer erfolgreichen TLS-Verbindung (beide Parteien bereit, Bewerbungsdaten mit TLS zu übertragen) oder einer Alarmnachricht (wie unten angegeben). Basic TLS Handshake Ein typisches Verbindungsbeispiel folgt, bei dem der Server (aber nicht der Client) durch sein Zertifikat authentifiziert wird: Verhandlungsphase: Ein Client sendet eine ClientHello-Nachricht an, in der die höchste TLS-Protokollversion, eine Zufallszahl, eine Liste von vorgeschlagenen Cipher Suiten und vorgeschlagenen Kompressionsverfahren angegeben wird. Wenn der Client versucht, einen wieder aufgenommenen Handshake durchzuführen, kann er eine Sitzungs-ID senden. Wenn der Client Application-Layer Protocol Negotiation verwenden kann, kann er eine Liste unterstützter Applikationsprotokolle wie HTTP/2 enthalten. Der Server reagiert mit einer ServerHello-Nachricht, die die gewählte Protokollversion, eine Zufallszahl, eine verschlüsselte Suite und eine Kompressionsmethode aus den vom Client angebotenen Optionen enthält. Um wieder aufgenommene Handshakes zu bestätigen oder zuzulassen, kann der Server eine Session-ID senden. Die gewählte Protokollversion sollte die höchste sein, die sowohl der Client- als auch der Server-Support ist. Wenn beispielsweise der Client die TLS-Version 1.1 unterstützt und der Server die Version 1.2 unterstützt, sollte die Version 1.1 ausgewählt werden; die Version 1.2 sollte nicht ausgewählt werden. Der Server sendet seine Zertifikatsnachricht (je nach gewählter Chiffre-Suite kann dies vom Server weggelassen werden). Der Server sendet seine ServerKeyExchange-Nachricht (abhängig von der ausgewählten Chiffre-Suite, dies kann vom Server weggelassen werden). Diese Nachricht wird für alle DHE, ECDHE und DH_anon Cipher Suiten gesendet. Der Server sendet eine ServerHelloDone-Nachricht, was darauf hindeutet, dass sie mit Handshake-Verhandlungen durchgeführt wird. Der Client reagiert mit einer ClientKeyExchange-Nachricht, die einen PreMasterSecret, öffentlichen Schlüssel oder nichts enthalten kann. (Dies hängt von der ausgewählten Chiffre ab.) Dieser PreMasterSecret wird mit dem öffentlichen Schlüssel des Serverzertifikats verschlüsselt. Der Client und der Server verwenden dann die Zufallszahlen und PreMasterSecret, um ein gemeinsames Geheimnis zu berechnen, das "Master Secret" genannt wird. Alle anderen Schlüsseldaten (Sessionsschlüssel wie IV, symmetrischer Verschlüsselungsschlüssel, MAC-Schlüssel) für diese Verbindung werden aus diesem Mastergeheimnis (und den Client- und Server-generierten Zufallswerten) abgeleitet, die durch eine sorgfältig gestaltete Pseudorandom-Funktion geleitet wird. Der Client sendet nun einen ChangeCipherSpec-Datensatz, der im Wesentlichen dem Server sagt: "Alles, was ich Ihnen jetzt sage, wird authentifiziert (und verschlüsselt, wenn Verschlüsselungsparameter im Server-Zertifikat vorhanden waren). Der ChangeCipherSpec ist selbst ein Protokoll mit Inhaltstyp von 20. Der Client sendet eine authentifizierte und verschlüsselte Fertignachricht mit Hash und MAC über die vorherigen Handshake-Nachrichten. Der Server wird versuchen, die beendete Nachricht des Clients zu entschlüsseln und die Hash und MAC zu überprüfen. Wenn die Entschlüsselung oder Verifikation ausfällt, wird der Handshake als gescheitert angesehen und die Verbindung sollte abgerissen werden. Schließlich sendet der Server einen ChangeCipherSpec, der dem Client sagt: "Alles, was ich Ihnen von jetzt an sage, wird authentifiziert (und verschlüsselt, wenn Verschlüsselung ausgehandelt wurde). Der Server sendet seine authentifizierte und verschlüsselte Ended-Nachricht. Der Client führt das gleiche Entschlüsselungs- und Verifikationsverfahren wie der Server im vorherigen Schritt durch. Anwendungsphase: An dieser Stelle ist der Handshake vollständig und das Applikationsprotokoll mit Inhaltstyp 23 aktiviert. Applikationsnachrichten, die zwischen Client und Server ausgetauscht werden, werden ebenso wie in ihrer Fertignachricht authentifiziert und optional verschlüsselt. Andernfalls wird der Inhaltstyp 25 zurückgegeben und der Client wird nicht authentifizieren. Client-authenticated TLS Handshake Das folgende Vollbeispiel zeigt, dass ein Client (neben dem Server wie im obigen Beispiel, siehe gegenseitige Authentifizierung) über TLS mit zwischen beiden Peers ausgetauschten Zertifikaten authentifiziert wird. Verhandlungsphase: Ein Client sendet eine ClientHello-Nachricht, in der die höchste TLS-Protokollversion, die es unterstützt, eine Zufallszahl, eine Liste von vorgeschlagenen Chiffre-Suiten und Kompressionsmethoden angegeben wird. Der Server reagiert mit einer ServerHello-Nachricht, die die gewählte Protokollversion, eine Zufallszahl, eine verschlüsselte Suite und eine Kompressionsmethode aus den vom Client angebotenen Optionen enthält. Der Server kann auch eine Session-ID als Teil der Nachricht senden, um einen wieder aufgenommenen Handshake durchzuführen. Der Server sendet seine Zertifikatsnachricht (je nach gewählter Chiffre-Suite kann dies vom Server weggelassen werden). Der Server sendet seine ServerKeyExchange-Nachricht (abhängig von der ausgewählten Chiffre-Suite, dies kann vom Server weggelassen werden). Diese Nachricht wird für alle DHE, ECDHE und DH_anon Ciphersuits gesendet. Der Server sendet eine CertificateRequest-Nachricht, um ein Zertifikat vom Client anzufordern. Der Server sendet eine ServerHelloDone-Nachricht, was darauf hindeutet, dass sie mit Handshake-Verhandlungen durchgeführt wird. Der Client reagiert mit einer Zertifikatsnachricht, die das Zertifikat des Clients enthält. Der Client sendet eine ClientKeyExchange-Nachricht, die einen PreMasterSecret, öffentlichen Schlüssel oder nichts enthalten kann. (Dies hängt von der ausgewählten Chiffre ab.) Dieser PreMasterSecret wird mit dem öffentlichen Schlüssel des Serverzertifikats verschlüsselt. Der Client sendet eine CertificateVerify-Nachricht, die eine Signatur über die vorherigen Handshake-Nachrichten mit dem privaten Schlüssel des Clients ist. Diese Signatur kann mit dem öffentlichen Schlüssel des Kunden überprüft werden. Damit kann der Server wissen, dass der Client Zugriff auf den privaten Schlüssel des Zertifikats hat und somit das Zertifikat besitzt. Der Client und der Server verwenden dann die Zufallszahlen und PreMasterSecret, um ein gemeinsames Geheimnis zu berechnen, das "Master Secret" genannt wird. Alle anderen Schlüsseldaten ("Sitzungsschlüssel") für diese Verbindung werden aus diesem Mastergeheimnis (und den Client- und Server-generierten Zufallswerten) abgeleitet, die durch eine sorgfältig gestaltete Pseudorandom-Funktion geleitet werden. Der Client sendet nun einen ChangeCipherSpec-Datensatz, der im Wesentlichen dem Server sagt: "Alles, was ich Ihnen von jetzt an sage, wird authentifiziert (und verschlüsselt, wenn Verschlüsselung ausgehandelt wurde). Der ChangeCipherSpec ist selbst ein Record-Level-Protokoll und hat Typ 20 und nicht 22. Schließlich sendet der Client eine verschlüsselte Fertignachricht mit einem Hash und MAC über die vorherigen Handshake-Nachrichten. Der Server wird versuchen, die beendete Nachricht des Clients zu entschlüsseln und die Hash und MAC zu überprüfen. Wenn die Entschlüsselung oder Verifikation ausfällt, wird der Handshake als gescheitert angesehen und die Verbindung sollte abgerissen werden. Schließlich sendet der Server einen ChangeCipherSpec, der dem Client sagt: "Alles, was ich Ihnen von jetzt an sage, wird authentifiziert (und verschlüsselt, wenn Verschlüsselung ausgehandelt wurde). Der Server sendet seine eigene verschlüsselte Fertignachricht. Der Client führt das gleiche Entschlüsselungs- und Verifikationsverfahren wie der Server im vorherigen Schritt durch. Anwendungsphase: An dieser Stelle ist der Handshake vollständig und das Applikationsprotokoll mit Inhaltstyp 23 aktiviert. Applikationsnachrichten, die zwischen Client und Server ausgetauscht werden, werden genauso verschlüsselt wie in ihrer Fertignachricht. Resumed TLS Handshake Public Key Operationen (z.B. RSA) sind relativ teuer in Bezug auf Rechenleistung. TLS bietet eine sichere Verknüpfung im Handshake-Mechanismus, um diese Operationen zu vermeiden: wieder aufgenommene Sitzungen. Resumed Sessions werden mit Session-IDs oder Session-Tickets durchgeführt. Neben dem Leistungsvorteil können wieder aufgenommene Sitzungen auch für einzelne Anmeldungen verwendet werden, da es garantiert, dass sowohl die ursprüngliche Sitzung als auch jede wieder aufgenommene Sitzung vom gleichen Client stammen. Dies ist für das FTP über das TLS/SSL-Protokoll von besonderer Bedeutung, das ansonsten unter einem Man-in-the-middle-Angriff leiden würde, bei dem ein Angreifer den Inhalt der sekundären Datenverbindungen abfangen könnte. TLS 1.3 Handshake Der TLS 1.3 Handshake wurde im Vergleich zu den beiden Rundfahrten, die in früheren Versionen von TLS/SSL erforderlich sind, auf nur eine Rundreise kondensiert. Erst sendet der Client einen Client Hallo Nachricht an den Server, die eine Liste von unterstützten Chiffren enthält, um die Präferenz des Clients und macht eine Vermutung darüber, welche Schlüsselalgorithmus verwendet wird, so dass es einen geheimen Schlüssel senden kann, um bei Bedarf zu teilen. Durch eine Vermutung an welchem Schlüsselalgorithmus verwendet wird, eliminiert der Server eine Rundreise. Nach Erhalt des Clients Hallo, der Server sendet einen Server Hallo mit seinem Schlüssel, einem Zertifikat, der ausgewählten Chiffre Suite und der fertigen Nachricht. Nachdem der Client die fertige Nachricht des Servers erhält, wird er nun mit dem Server koordiniert, auf dem die Cipher Suite verwendet wird.Sitzungs-IDs In einem gewöhnlichen Handshake sendet der Server eine Session-ID als Teil der ServerHello-Nachricht. Der Client verbindet diese Session-ID mit der IP-Adresse des Servers und dem TCP-Port, so dass, wenn der Client sich wieder mit diesem Server verbindet, es die Session-ID verwenden kann, um den Handshake zu kürzen. Im Server kartiert die Session-ID die bisher ausgehandelten kryptographischen Parameter, insbesondere das "Master Secret". Beide Seiten müssen das gleiche "Meistergeheimnis" haben oder der wieder aufgenommene Handshake wird scheitern (dies verhindert, dass ein Eavesdropper eine Session-ID verwendet). Die zufälligen Daten in den ClientHello- und ServerHello-Nachrichten garantieren praktisch, dass die generierten Verbindungsschlüssel von der vorherigen Verbindung abweichen. Bei den RFCs wird diese Art von Handshake als verkürzter Handshake bezeichnet. Sie wird auch in der Literatur als Neustarthandshake beschrieben. Verhandlungsphase: Ein Client sendet eine ClientHello-Nachricht an, in der die höchste TLS-Protokollversion, eine Zufallszahl, eine Liste von vorgeschlagenen Cipher Suiten und Kompressionsmethoden angegeben wird. In der Nachricht enthalten ist die Session id aus der vorherigen TLS-Verbindung. Der Server reagiert mit einer ServerHello-Nachricht, die die gewählte Protokollversion, eine Zufallszahl, eine verschlüsselte Suite und eine Kompressionsmethode aus den vom Client angebotenen Optionen enthält. Wenn der Server die vom Client gesendete Session-ID erkennt, reagiert er mit der gleichen Session-ID. Der Client erkennt an, dass ein wieder aufgenommener Handshake ausgeführt wird. Wenn der Server die vom Client gesendete Session-ID nicht erkennt, sendet er einen anderen Wert für seine Session-ID. Dies sagt dem Kunden, dass ein wieder aufgenommener Handshake nicht durchgeführt wird. An dieser Stelle haben sowohl der Client als auch der Server das "Mastergeheimnis" und zufällige Daten, um die für diese Verbindung zu verwendenden Schlüsseldaten zu erzeugen. Der Server sendet nun einen ChangeCipherSpec-Datensatz, der im Wesentlichen dem Client sagt: "Alles, was ich Ihnen jetzt sage, wird verschlüsselt." Der ChangeCipherSpec ist selbst ein Record-Level-Protokoll und hat Typ 20 und nicht 22. Schließlich sendet der Server eine verschlüsselte Fertignachricht mit Hash und MAC über die vorherigen Handshake-Nachrichten. Der Client wird versuchen, die beendete Nachricht des Servers zu entschlüsseln und die Hash und MAC zu überprüfen. Wenn die Entschlüsselung oder Verifikation ausfällt, wird der Handshake als gescheitert angesehen und die Verbindung sollte abgerissen werden. Schließlich sendet der Client einen ChangeCipherSpec und sagt dem Server: "Alles, was ich Ihnen von jetzt an sage, wird verschlüsselt." Der Client sendet seine eigene verschlüsselte Fertignachricht. Der Server führt die gleiche Entschlüsselungs- und Verifikationsprozedur wie der Client im vorherigen Schritt aus. Anwendungsphase: An dieser Stelle ist der Handshake vollständig und das Applikationsprotokoll mit Inhaltstyp 23 aktiviert. Applikationsnachrichten, die zwischen Client und Server ausgetauscht werden, werden genauso verschlüsselt wie in ihrer Fertignachricht. Session-Tickets RFC 5077 erweitert TLS über die Nutzung von Session-Tickets anstelle von Session-IDs. Es definiert eine Möglichkeit, eine TLS-Session wieder aufzunehmen, ohne dass ein sitzungsspezifischer Zustand auf dem TLS-Server gespeichert wird. Beim Einsatz von Session-Tickets speichert der TLS-Server seinen sitzungsspezifischen Zustand in einem Session-Ticket und sendet das Session-Ticket zum TLS-Client zum Speichern. Der Client nimmt eine TLS-Sitzung wieder auf, indem er das Session-Ticket an den Server sendet und der Server die TLS-Sitzung gemäß dem sitzungsspezifischen Zustand im Ticket wieder aufnimmt. Das Session-Ticket wird vom Server verschlüsselt und authentifiziert und der Server überprüft seine Gültigkeit, bevor er seinen Inhalt nutzt. Eine besondere Schwäche dieser Methode mit OpenSSL ist, dass sie die Verschlüsselungs- und Authentifizierungssicherheit des übertragenen TLS-Sitzungstickets immer auf AES128-CBC-SHA256 beschränkt, egal, welche anderen TLS-Parameter für die eigentliche TLS-Sitzung ausgehandelt wurden. Dies bedeutet, dass die Zustandsinformationen (das TLS-Sitzungsticket) nicht so gut geschützt sind wie die TLS-Sitzung selbst. Von besonderem Interesse ist die Speicherung der Tasten von OpenSSL in einem anwendungsweiten Kontext (SSL_CTX), d.h. für die Lebensdauer der Anwendung, und es ist nicht möglich, die AES128-CBC-SHA256 TLS Sitzungskarten neu zu schlüsseln, ohne den anwendungsweiten OpenSSL-Kontext (der ungewöhnlich ist, fehleranfällig ist und oft manuelle administrative Intervention erfordert). TLS-Datensatz Dies ist das allgemeine Format aller TLS-Datensätze. Inhaltsart In diesem Feld wird der in diesem Datensatz enthaltene Datensatz Layer Protocol Type identifiziert. Legacy-Version Dieses Feld identifiziert die Haupt- und Minderversion von TLS vor TLS 1.3 für die enthaltene Nachricht. Für eine ClientHello-Nachricht muss dies nicht die höchste Version sein, die vom Client unterstützt wird. Für TLS 1.3 und später muss dies 0x0303 gesetzt werden und die Anwendung muss unterstützte Versionen in einem zusätzlichen Nachrichtenerweiterungsblock senden. Länge Die Länge der "Protokollnachricht(en,") MAC und Paddingfelder kombiniert (d.h. q-5,) darf 214 Bytes (16 KiB) nicht überschreiten. Protokollnachricht(en)Eine oder mehrere Meldungen, die durch das Protokollfeld gekennzeichnet sind. Beachten Sie, dass dieses Feld abhängig vom Zustand der Verbindung verschlüsselt werden kann. MAC und Polsterung Ein Nachrichtenauthentifizierungscode, der über das Feld "Protokollnachricht(e") berechnet wird, mit zusätzlichem Schlüsselmaterial. Beachten Sie, dass dieses Feld verschlüsselt oder nicht vollständig enthalten sein kann, abhängig vom Zustand der Verbindung. Keine MAC- oder Padding-Felder können am Ende von TLS-Datensätzen vorhanden sein, bevor alle Cipher-Algorithmen und Parameter ausgehandelt und handschakelt und dann durch Senden eines CipherStateChange-Datensatzes (siehe unten) bestätigt wurden, um zu signalisieren, dass diese Parameter in allen weiteren Datensätzen, die von demselben Peer gesendet werden, wirksam werden. Handshake-Protokoll Die meisten während der Einrichtung der TLS-Sitzung ausgetauschten Nachrichten basieren auf diesem Datensatz, es sei denn, ein Fehler oder eine Warnung kommt vor und muss durch einen Alert-Protokollsatz (siehe unten) signalisiert werden oder der Verschlüsselungsmodus der Sitzung wird durch einen anderen Datensatz geändert (siehe ChangeCipherSpec Protokoll unten). Kennnummer Dieses Feld identifiziert den Handshake-Nachrichttyp. Handshake Nachricht Daten Länge Dies ist ein 3-Byte-Feld, das die Länge der Handshake-Daten angibt, nicht einschließlich des Headers. Beachten Sie, dass mehrere Handshake-Nachrichten innerhalb eines Datensatzes kombiniert werden können. Alarmprotokoll Dieser Datensatz sollte normalerweise nicht während des normalen Handshakings oder des Anwendungsaustauschs gesendet werden. Diese Nachricht kann jedoch jederzeit während des Handshake und bis zum Abschluss der Sitzung gesendet werden. Wenn dies verwendet wird, um einen tödlichen Fehler zu signalisieren, wird die Sitzung sofort nach dem Senden dieser Platte geschlossen, so wird dieser Datensatz verwendet, um einen Grund für diese Schließung zu geben. Wenn der Alarmpegel als Warnung markiert ist, kann die Fernbedienung entscheiden, die Sitzung zu schließen, wenn sie entscheidet, dass die Sitzung für ihre Bedürfnisse nicht zuverlässig genug ist (vorher kann die Fernbedienung auch ihr eigenes Signal senden). Ebene Dieses Feld identifiziert die Ebene der Warnung. Wenn die Ebene tödlich ist, sollte der Absender die Sitzung sofort schließen. Andernfalls kann der Empfänger beschließen, die Sitzung selbst zu beenden, indem er seine eigene tödliche Warnung sendet und die Sitzung unmittelbar nach dem Senden beendet. Die Verwendung von Alert-Aufzeichnungen ist optional, jedoch, wenn es vor dem Sitzungsabschluss fehlt, kann die Sitzung automatisch wieder aufgenommen werden (mit seinen Handshakes). Eine normale Schließung einer Sitzung nach Beendigung der transportierten Anwendung sollte vorzugsweise mit mindestens der Close-Benachrichtigung benachrichtigt werden Alarmtyp (mit einer einfachen Warnstufe), um eine solche automatische Wiederaufnahme einer neuen Sitzung zu verhindern. Eine explizite Signalisierung des normalen Verschlusses einer sicheren Sitzung vor dem effektiven Schließen ihrer Transportschicht ist nützlich, um Angriffe zu verhindern oder zu detektieren (wie Versuche, die sicher transportierten Daten zu klopfen, wenn sie in sich keine vorbestimmte Länge oder Dauer hat, die der Empfänger der gesicherten Daten erwarten kann). Warenbezeichnung Dieses Feld identifiziert, welche Art von Alarm gesendet wird. ÄnderungCipher Protokoll CCS Protokolltyp Derzeit nur 1. Anwendungsprotokoll Länge der Anwendungsdaten (ohne Protokollkopf und einschließlich MAC- und Polsteranhänger)MAC 32 Bytes für den SHA-256-basierten HMAC, 20 Bytes für den SHA-1-basierten HMAC, 16 Bytes für den MD5-basierten HMAC. Padding Variable Länge; letzte Byte enthält die Polsterlänge. Unterstützung für namenbasierte virtuelle Server Aus Anwendungsprotokollsicht gehört TLS zu einer unteren Schicht, obwohl das TCP/IP-Modell zu grob ist, um es zu zeigen. Dies bedeutet, dass der TLS-Handshake üblicherweise (außer im STARTTLS-Fall) durchgeführt wird, bevor das Applikationsprotokoll starten kann. In der von der Anwendungsschicht bereitgestellten namenbasierten virtuellen Server-Funktion teilen alle mitgehosteten virtuellen Server das gleiche Zertifikat, da der Server unmittelbar nach der ClientHello-Nachricht ein Zertifikat auswählen und senden muss. Dies ist ein großes Problem in der Hosting-Umgebung, weil es bedeutet, entweder das gleiche Zertifikat unter allen Kunden zu teilen oder eine andere IP-Adresse für jeden von ihnen zu verwenden. Es gibt zwei bekannte Workarounds von X.509: Wenn alle virtuellen Server derselben Domäne angehören, kann ein Wildcard-Zertifikat verwendet werden. Neben der losen Host-Namensauswahl, die ein Problem sein könnte oder nicht, gibt es keine gemeinsame Vereinbarung, wie man Wildcard-Zertifikate passt. Je nach Anwendungsprotokoll oder Software werden unterschiedliche Regeln angewendet. Fügen Sie jeden virtuellen Hostnamen im Thema hinzu AltName Erweiterung. Das Hauptproblem ist, dass das Zertifikat neu ausgegeben werden muss, wenn ein neuer virtueller Server hinzugefügt wird. Um den Servernamen bereitzustellen, RFC 4366 Transport Layer Security (TLS) Erweiterungen ermöglichen es Clients, eine Server Name Indication Erweiterung (SNI) in die erweiterte ClientHello-Nachricht einzubeziehen. Diese Erweiterung deutet auf den Server hin, an den sich der Client anschließen möchte, damit der Server das entsprechende Zertifikat auswählen kann, um an die Clients zu senden. RFC 2817 dokumentiert auch ein Verfahren zur Implementierung namenbasierter virtueller Hosting, indem HTTP auf TLS über einen HTTP/1.1 Upgrade-Header aktualisiert wird. Normalerweise ist dies die sichere Implementierung von HTTP über TLS innerhalb des Haupt-http-URI-Programms (was das Forkingen des URI-Raums verhindert und die Anzahl der verwendeten Ports reduziert), aber nur wenige Implementierungen unterstützen dies derzeit. Grundnormen Die aktuelle Version von TLS ist die Version 1.3, die in: RFC 8446 angegeben ist: "The Transport Layer Security (TLS) Protocol Version 1.3". Der aktuelle Standard ersetzt diese früheren Versionen, die jetzt als veraltet gelten: RFC 2246: "The TLS Protocol Version 1.0". RFC 4346: "The Transport Layer Security (TLS) Protocol Version 1.1".RFC 5246: "The Transport Layer Security (TLS) Protocol Version 1.2". Neben den nie standardisierten SSL 2.0 und 3.0, die als veraltet gelten: Internet Draft (1995,) SSL Version 2.0 RFC 6101: "The Secure Sockets Layer (SSL) Protocol Version 3.0" Erweiterungen Andere RFCs erweiterten daraufhin TLS. Erweiterungen zu TLS 1.0 beinhalten: RFC 2595: "TLS mit IMAP, POP3 und ACAP verwenden". Gibt eine Erweiterung auf die IMAP-, POP3- und ACAP-Dienste an, die es dem Server und dem Client ermöglichen, die Transportschichtsicherheit zu nutzen, um eine private, authentifizierte Kommunikation über das Internet bereitzustellen. RFC 2712: "Addition of Kerberos Cipher Suites to Transport Layer Security (TLS)". Die in dieser Memo definierten 40-Bit-Cipher-Suiten erscheinen nur zur Dokumentation der Tatsache, dass diese Cipher-Suite-Codes bereits vergeben wurden. RFC 2817: "Upgradeing to TLS innerhalb HTTP/1.1", erklärt, wie man den Upgrade-Mechanismus in HTTP/1.1 verwendet, um Transport Layer Security (TLS) über eine bestehende TCP-Verbindung zu initiieren. Dies ermöglicht es unsecured und gesicherten HTTP-Verkehr, den gleichen bekannten Port zu teilen (in diesem Fall, http: bei 80 statt https: bei 443). RFC 2818: "HTTP Over TLS", unterscheidet gesicherten Verkehr von unsicherem Verkehr durch die Verwendung eines anderen "Server-Ports". RFC 3207: "SMTP Service Extension for Secure SMTP over Transport Layer Security". Gibt eine Erweiterung des SMTP-Dienstes an, der es einem SMTP-Server und einem Client ermöglicht, Transport-Layer-Sicherheit zu verwenden, um eine private, authentifizierte Kommunikation über das Internet bereitzustellen. RFC 3268: "AES Ciphersuits for TLS". Fügt Advanced Encryption Standard (AES) Cipher Suiten zu den bisher vorhandenen symmetrischen Chiffren hinzu. RFC 3546: "Transport Layer Security (TLS) Extensions", fügt einen Mechanismus zum Verhandeln von Protokollerweiterungen während der Session-Initialisierung hinzu und definiert einige Erweiterungen. Hergestellt von RFC 4366.RFC 3749: "Transport Layer Security Protocol Compression Methods", gibt den Rahmen für Kompressionsverfahren und die DEFLATE Kompressionsmethode an. RFC 3943: "Transport Layer Security (TLS) Protocol Compression using Lempel-Ziv-Stac (LZS)". RFC 4132: "Addition of Camellia Cipher Suites to Transport Layer Security (TLS)". RFC 4162: "Addition of SEED Cipher Suites to Transport Layer Security (TLS)". RFC 4217: "Securing FTP with TLS". RFC 4279: "Pre-Shared Key Ciphersuites for Transport Layer Security (TLS,") fügt drei Sets neuer Chiffre-Suiten für das TLS-Protokoll hinzu, um die Authentifizierung auf Basis von Pre-shared Keys zu unterstützen. Erweiterungen zu TLS 1.1 umfassen: RFC 4347: "Datagram Transport Layer Security" gibt eine TLS-Variante an, die über Datagram Protokolle (z.B. UDP) arbeitet. RFC 4366: "Transport Layer Security (TLS) Extensions" beschreibt sowohl einen Satz spezifischer Erweiterungen als auch einen generischen Erweiterungsmechanismus. RFC 4492: "Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)". RFC 4680: "TLS Handshake Message for Supplemental Data".RFC 4681: "TLS User Mapping Extension". RFC 4785: "Pre-Shared Key (PSK) Ciphersuits mit NULL Encryption for Transport Layer Security (TLS)". RFC 5054: "Mit dem Secure Remote Password (SRP) Protocol for TLS Authentication". Definiert die TLS-SRP-Ciphersuits.RFC 5077: "Transport Layer Security (TLS) Session Resumption ohne Server-Side State". RFC 5081: "Benutzen von OpenPGP-Keys für die Verkehrsschichtsicherheit (TLS) Authentication", obsoleted von RFC 6091. Erweiterungen zu TLS 1.2 umfassen: RFC 5288: "AES Galois Counter Mode (GCM)Cipher Suites for TLS".RFC 5289: "TLS Elliptic Curve Cipher Suites with SHA-256/384 and AES Galois Counter Mode (GCM)". RFC 5746: "Transport Layer Security (TLS) Renegotiation Indication Extension". RFC 5878: "Transport Layer Security (TLS) Authorization Extensions". RFC 5932: "Camellia Cipher Suites for TLS" RFC 6066: "Transport Layer Security (TLS) Erweiterungen: Erweiterungsdefinitionen", beinhaltet Servername-Indikation und OCSP-Installation. RFC 6091: "Benutzen von OpenPGP-Keys für Transport Layer Security (TLS) Authentication". RFC 6176: "Prohibiting Secure Sockets Layer (SSL) Version 2.0".RFC 6209: "Addition of the ARIA Cipher Suites to Transport Layer Security (TLS)". RFC 6347: "Datagram Transport Layer Security Version 1.2". RFC 6367: "Addition of the Camellia Cipher Suites to Transport Layer Security (TLS)". RFC 6460: "Suite B Profile for Transport Layer Security (TLS)". RFC 6655: "AES-CCM Cipher Suites for Transport Layer Security (TLS)". RFC 7027: "Elliptic Curve Cryptography (ECC) Brainpool Curves for Transport Layer Security (TLS)". RFC 7251: "AES-CCM Elliptic Curve Cryptography (ECC)Cipher Suites for TLS".RFC 7301: "Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension". RFC 7366: "Encrypt-then-MAC for Transport Layer Security (TLS) und Datagram Transport Layer Security (DTLS)". RFC 7465: "Prohibiting RC4 Cipher Suites". RFC 7507: "TLS Fallback Signaling Cipher Suite Value (SCSV) zur Vermeidung von Protokoll-Abbau-Angriffen". RFC 7568: "Deprecating Secure Sockets Layer Version 3.0".RFC 7627: "Transport Layer Security (TLS) Session Hash und Extended Master Secret Extension". RFC 7685: "A Transport Layer Security (TLS)ClientHello Padding Extension". Zu den Kapseln von TLS gehören: RFC 5216: "The EAP-TLS Authentication Protocol" Informational RFC 7457: "Summarizing Known Attacks on Transport Layer Security (TLS) and Datagram TLS (DTLS") RFC 7525: "Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS") Siehe auch Application-Layer Protocol Negotiation – eine TLS-Erweiterung für SPDY und TLS False Start Bullrun (Entschlüsselungsprogramm) – ein geheimes Anti-Verschlüsselungsprogramm, das von der US National Security Agency Certificate Authority Certificate Authority Certificate Transparency HTTP Strict Transport Security – HSTS Key Ring Datei QUIC (Quick UDP Internet Connections) betrieben wird – ." Dieser Artikel basiert auf dem Material, das vor dem 1. November 2008 aus dem Free On-line Dictionary of Computing stammt und unter den Relicensing-Bedingungen der GFDL, Version 1.3 oder später aufgenommen wurde. Weiter lesen Wagner, David; Schneier, Bruce (November 1996)."Analyse des SSL 3.0 Protokolls" (PDF). Der zweite USENIX Workshop zum elektronischen Handel. USENIX Press.pp.29–40. Eric Rescorla (2001). SSL und TLS: Designing und Building Secure Systems. Vereinigte Staaten: Addison-Wesley Pub Co.ISBN 978-0-201-61598-2.Stephen A. Thomas (2000). SSL und TLS müssen das Web.New York: Wiley sichern. ISBN 978-0-471-38354-3.Bard, Gregory (2006)."Eine herausfordernde, aber hässliche Blockweise-Adaptive Choen-Plaintext-Angriff auf SSL". International Association for Cryptologic Research (136). Retrieved 2011-09-23.Canvel, Brice. "Passwort-Interception in einem SSL/TLS-Kanal". Retrieved 2007-04-20.IETF Mehrere Autoren. "RFC of change for TLS Renegotiation". Retrieved 2009-12-11.Creating VPNs mit IPsec und SSL/TLS Linux Journal Artikel von Rami Rosen Joshua Davies (2010). Durchführung SSL/TLS.Wiley.ISBN 978-0470920411.Polk, Tim; McKay, Kerry; Chokhani, Santosh (April 2014). "Leitlinien für die Auswahl, Konfiguration und Verwendung von Transport Layer Security (TLS) Implementierungen" (PDF). Nationales Institut für Normen und Technologie. Archiviert vom Original (PDF) am 2014-05-08. Retrieved 2014-05-07.Abdou, AbdelRahman; van Oorschot, Paul (August 2017). "Server Location Verification (SLV) und Server Location Pinning: Augmenting TLS Authentication". Transaktionen über Datenschutz und Sicherheit.ACM.21 (1): 1:1–1:26.doi:10.1145/3139294.S2CID 5869541. Externe Links Spezifikationen (siehe § Normen für ältere SSL 2.0, SSL 3.0, TLS 1.0, TLS 1.1 Links) The Transport Layer Security (TLS) Protocol Version 1.2 RFC 5246 IETF (Internet Engineering Task Force)TLS WorkgroupTLS Version inleranceTLS Versionsintoleranz TLS 1.3 und Version IntoleranceOtherOWASP: Transport Layer Protection Cheat Sheet Ein Gespräch über SSL/TLS, das versucht, Dinge zu erklären, die Menschen verstehen könnten. TLS Renegotiation Vulnerability – IETF Tools Qualys SSL Labs – SSL Pulse Wie man CSR für SSL generiert Wie TLS Handshake im privaten Browser arbeitet