In der Informatik ist der selbst ändernde Code Code, der seine eigenen Anweisungen ändert, während er ausgeführt wird – in der Regel, um die Befehlspfadlänge zu reduzieren und die Leistung zu verbessern oder einfach, sonst wiederholt ähnliche Code zu reduzieren, wodurch die Wartung vereinfacht wird. Selbstmodifizierung ist eine Alternative zur Methode der "Flag-Einstellung" und der bedingten Programmverzweigung, die vor allem verwendet wird, um die Anzahl der Zeiten zu reduzieren, die eine Bedingung getestet werden muss. Der Begriff wird in der Regel nur auf Code angewendet, bei dem die Selbstmodifizierung absichtlich ist, nicht in Situationen, in denen sich Code durch einen Fehler wie einen Pufferüberlauf versehentlich verändert. Das Verfahren wird häufig zum bedingten Aufrufen von Test/Debugging-Code verwendet, ohne dass für jeden Ein-/Ausgabezyklus ein zusätzlicher rechnerischer Overhead erforderlich ist. Die Modifikationen können durchgeführt werden: nur während der Initialisierung – basierend auf Eingangsparametern (wenn der Prozess allgemeiner als Software-Konfiguration beschrieben wird und hardwaremäßig etwas analog ist, um Jumper für Leiterplatten einzustellen). Eine Änderung der Programmeintragszeiger ist eine gleichwertige indirekte Methode der Selbstmodifizierung, erfordert jedoch die Koexistenz eines oder mehrerer alternativer Befehlspfade, die Programmgröße zu erhöhen. während der Ausführung ("on the fly)" – basierend auf bestimmten Programmzuständen, die während der Ausführung erreicht wurden In beiden Fällen können die Modifikationen direkt an die Maschinencode-Anweisungen selbst vorgenommen werden, indem neue Anweisungen über die vorhandenen (z.B.: Änderung eines Vergleichs und Zweiges an einen bedingungslosen Zweig oder alternativ eine NOP) überlagert werden. Im Befehlssatz IBM/360 und Z/Architektur überlagert eine EXECUTE (EX)-Anweisung logisch den zweiten Byte seiner Zielanweisung mit den low-order 8 Bits des Registers 1. Dies bewirkt eine Selbstmodifizierung, obwohl die tatsächliche Instruktion im Speicher nicht verändert wird. Anwendung in niedrigen und hohen Sprachen Selbst-Modifikation kann in unterschiedlicher Weise erfolgen, je nach Programmiersprache und Unterstützung für Zeiger und/oder Zugriff auf dynamische Compiler- oder Dolmetschermotoren: Überlagerung bestehender Anweisungen (oder Teile von Anweisungen wie Opcode, Register, Fahnen oder Adresse) oder direkte Erstellung von ganzen Anweisungen oder Reihenfolge von Anweisungen im Speicher Erstellung oder Änderung von Quellcode-Anweisungen, gefolgt von einer "mini compile" oder einer dynamischen Interpretation. Anweisungen können im Speicher dynamisch erstellt werden (oder auch überlagert über vorhandene Codes in nicht geschützter Programmspeicherung), in einer Sequenz, die denen entspricht, die ein Standardkompilator als Objektcode erzeugen kann. Mit modernen Prozessoren können unbeabsichtigte Nebenwirkungen auf den CPU-Cache, die berücksichtigt werden müssen. Das Verfahren wurde häufig zur Prüfung der "ersten Zeit"-Bedingungen verwendet, wie in diesem entsprechend kommentierten IBM/360 Assembler Beispiel. Es verwendet Befehlsüberlagerung, um die Befehlspfadlänge um (N×1)-1 zu reduzieren, wobei N die Anzahl der Datensätze auf der Datei ist (-1 ist der Overhead, um die Overlay durchzuführen.) SUBRTN NOP FIRST TIME HIER? * Die NOP ist x'4700'<Address_of_opened> OI SUBRTN+1,X'F0 JA, CHANGE NOP TO UNCONDITIONAL BRANCH (47F0.) Öffne INPUT und öffne die INPUT FILE SINCE IT's the FIRST TIME THRU Öffnete GET INPUT NORMAL PROCESSING RESUMs HIER... Alternativer Code könnte die Prüfung einer Flagge jedes Mal durch. Der bedingungslose Zweig ist etwas schneller als eine Vergleichsanweisung und reduziert die Gesamtbahnlänge. In späteren Betriebssystemen für Programme, die in geschützter Lagerung wohnhaft sind, konnte diese Technik nicht verwendet werden, so dass ein Wechsel des Zeigers zum Unterprogramm statt dessen verwendet werden würde. Der Zeiger würde sich in der dynamischen Speicherung befinden und nach dem ersten Durchlauf den OPEN beliebig ändern (da er zunächst einen Zeiger anstelle einer direkten Verzweigung & Verbindung zum Unterprogramm lädt, würde N Anweisungen zur Weglänge hinzufügen – aber es würde eine entsprechende Reduzierung von N für den bedingungslosen Verzweigung geben, der nicht mehr erforderlich wäre). Unten ist ein Beispiel in Zilog Z80 Montagesprache. Der Code erhöht das Register B im Bereich [0,5.] Die CP-Vergleichsanweisung wird auf jeder Schleife geändert. Selbstmodifizierender Code wird manchmal verwendet, um Einschränkungen in der Anleitung eines Geräts zu überwinden. Beispielsweise kann im Intel 8080 Befehlssatz kein Byte von einem Eingangsport eingegeben werden, der in einem Register angegeben ist. Der Eingangsport ist in der Anweisung selbst als zweiter Byte einer zwei Byte-Anweisung statisch codiert. Mit einem selbstmodifizierenden Code ist es möglich, die Inhalte eines Registers in den zweiten Byte der Anweisung zu speichern, dann die geänderte Anweisung auszuführen, um den gewünschten Effekt zu erzielen. Hochrangige Sprachen Einige kompilierte Sprachen erlauben explizit selbst ändernden Code. Beispielsweise kann das ALTER-Verb in COBOL als Zweiganweisung ausgeführt werden, die während der Ausführung verändert wird. Einige Batch-Programmiertechniken beinhalten die Verwendung von selbst ändernden Code. Clipper und SPITBOL bieten auch Einrichtungen zur expliziten Selbstmodifizierung. Der Algol-Compiler auf B6700-Systemen bot dem Betriebssystem eine Schnittstelle, mit der der Code ausgeführt werden konnte, einen Textstring oder eine benannte Disc-Datei an den Algol-Compiler übergeben und dann die neue Version eines Verfahrens anrufen konnte. Mit interpretierten Sprachen ist der "Maschinencode" der Quelltext und kann für die Bearbeitung von On-the-fly anfällig sein: In SNOBOL werden die ausgeführten Quellaussagen Elemente eines Textfeldes ausgeführt. Andere Sprachen, wie Perl und Python, ermöglichen es Programmen, einen neuen Code zu Laufzeit zu erstellen und ihn mit einer Eval-Funktion auszuführen, aber nicht zulassen, dass vorhandener Code mutiert wird. Die Illusion der Modifikation (auch wenn kein Maschinencode wirklich überschrieben wird) wird durch Änderung von Funktionszeigern erreicht, wie in diesem JavaScript Beispiel: Lisp-Makros ermöglichen auch die Laufzeit-Code-Generierung, ohne einen String mit Programmcode zu parsieren. Die Programmiersprache Push ist ein genetisches Programmiersystem, das explizit für die Erstellung von selbst ändernden Programmen konzipiert ist. Während nicht eine hohe Sprache, ist es nicht so niedrig Ebene als Montagesprache. Vor dem Erscheinen mehrerer Fenster können Kommandozeilensysteme ein Menüsystem mit der Modifikation eines laufenden Befehlsskripts anbieten. Angenommen eine DOS-Skript (oder Batch)-Datei Menu.bat enthält die folgenden:StartAfresh -<A Linie, beginnend mit einem Kolon markiert ein Label. ShowMenu.exe Bei der Einleitung von Menu.bat aus der Befehlszeile stellt ShowMenu ein on-screen-Menü mit möglichen Hilfeinformationen, Beispielnutzungen und so weiter vor. Schließlich macht der Benutzer eine Auswahl, die einen Befehl benötigt, der ausgeführt werden soll: ShowMenu Ausgänge nach dem Umschreiben der Datei Menu.bat enthalten :StartAfresh ShowMenu.exe CALL C:\Befehle\somename.bat GOTO StartAfresh Da der DOS-Befehlsinterpreter keine Skriptdatei kompiliert und dann ausführt, noch die gesamte Datei vor der Ausführung in den Speicher liest, noch nicht auf den Inhalt eines Record-Puffers angewiesen ist, wenn ShowMenu austritt, findet der Befehlsinterpreter einen neuen Befehl zur Ausführung (es ist, die Skriptdatei in einem Verzeichnis-Standort und über ein Protokoll, das bekannt ist ShowMenu, anzumeldenen) und nachdem dieser Befehl die Auswahl beendet hat, geht es Sollte die Menüwahl beendet werden, würde die Datei wieder in ihren ursprünglichen Zustand geschrieben werden. Obwohl dieser Ausgangszustand für das Etikett keine Verwendung hat, ist es erforderlich, oder es wird ein entsprechender Textbetrag benötigt, weil der DOS-Befehlsinterpreter die Byte-Position des nächsten Befehls zurückruft, wenn er den nächsten Befehl starten soll, so muss die neu geschriebene Datei die Ausrichtung für den nächsten Befehlsstartpunkt beibehalten, um tatsächlich der Start des nächsten Befehls zu sein. Neben der Bequemlichkeit eines Menüsystems (und eventuelle Hilfsfunktionen) bedeutet dieses Schema, dass die ShowMenu. Ein exe-System ist nicht im Speicher, wenn der ausgewählte Befehl aktiviert ist, ein wesentlicher Vorteil, wenn der Speicher begrenzt ist. Steuertabellen Steuertabellen-Interpreter können in einem Sinne als selbstmodifiziert angesehen werden, indem aus den Tabelleneinträgen extrahierte Datenwerte (anstatt spezifisch in bedingten Ausführungen des Formulars "IF inputx = yyy.)" Kanalprogramme Einige IBM-Zugriffsmethoden verwendet traditionell selbstmodifizierende Channel-Programme, wo ein Wert, wie eine Festplattenadresse, in einem Bereich, der von einem Kanalprogramm referiert wird, gelesen wird, wo es von einem späteren Kanalbefehl verwendet wird, um auf die Festplatte zuzugreifen. Geschichte Der IBM SSEC, demonstriert im Januar 1948, hatte die Fähigkeit, seine Anweisungen zu ändern oder sie anderweitig genau wie Daten zu behandeln. Die Fähigkeit wurde jedoch in der Praxis selten genutzt. In den frühen Tagen der Computer wurde der selbst ändernde Code oft verwendet, um die Verwendung von begrenztem Speicher zu reduzieren oder die Leistung zu verbessern, oder beides. Es wurde manchmal auch verwendet, um Unterroutine-Anrufe zu implementieren und zurückzugeben, wenn der Befehlssatz nur einfache Verzweigungs- oder Übersprunganweisungen zur Variation des Steuerflusses lieferte. Diese Verwendung ist in bestimmten Ultra-RISC-Architekturen, zumindest theoretisch, noch relevant; siehe z.B. einen Instruktionsset-Computer. Donald Knuths MIX-Architektur nutzte auch selbstmodifizierenden Code, um Unterroutine-Anrufe zu implementieren. Verwendung Selbstmodifizierender Code kann für verschiedene Zwecke verwendet werden: Halbautomatische Optimierung einer zustandsabhängigen Schleife. Laufzeit-Code-Generierung oder Spezialisierung eines Algorithmus in Laufzeit oder Lastzeit (die beispielsweise in der Domäne von Echtzeit-Grafik beliebt ist) wie ein allgemeines Sorten-Dienstprogramm – Vorbereitung von Code, um den in einer bestimmten Invokation beschriebenen Schlüsselvergleich durchzuführen. Ändern des inlined Zustands eines Objekts oder Simulation des hochrangigen Aufbaus von Verschlüssen. Patchen von Subroutin (Pointer)-Adressrufen, in der Regel wie bei der Lade-/Initialisierungszeit dynamischer Bibliotheken oder auch bei jeder Invokation, Patchen der internen Referenzen des Subroutins auf seine Parameter, um ihre eigentlichen Adressen zu verwenden. (d.h. Indirekte Selbstmodifizierung.) Evolutionäre Computersysteme wie Neuroevolution, genetische Programmierung und andere evolutionäre Algorithmen. Verbergen von Code, um Reverse Engineering zu verhindern (durch den Einsatz eines Demontage- oder Debuggers) oder die Erkennung durch Viren/Spyware-Scan-Software und dergleichen zu umgehen. Füllen von 100% Speicher (in einigen Architekturen) mit einem rollenden Muster der Wiederholung von Opcodes, um alle Programme und Daten zu löschen, oder um Hardware zu verbrennen. Compressing-Code zu dekomprimieren und zu Laufzeit ausgeführt, z.B. wenn Speicher oder Festplattenraum begrenzt ist. Einige sehr begrenzte Befehlssätze lassen keine Option, sondern verwenden Sie selbst ändernden Code, um bestimmte Funktionen auszuführen. Beispielsweise kann eine ein Befehlssatz-Computer (OISC) Maschine, die nur den Subtrakt-und-Brench-if-negativen Befehl verwendet, keine indirekte Kopie (etwas wie das Äquivalent von *"a = *b" in der C-Sprache) ohne Verwendung von selbst ändernden Code. Booten. Frühe Mikrocomputer benutzten häufig selbstmodifizierenden Code in ihren Bootloadern. Da der Bootloader bei jedem Einschalten über das Frontpanel eingetastet wurde, spielt es keine Rolle, ob der Bootloader sich verändert hat. Doch auch heute sind viele Bootstrap-Lader selbstverlagernd, und einige sind sogar selbstmodifizierend. Ändern von Anweisungen für Fehlertoleranz. Optimierung eines zustandsabhängigen Schlaufe Pseudocode-Beispiel: Wiederholung N mal { wenn STATE 1 Erhöhung A durch einen anderen Rückgang A um einen etwas mit A } Selbstmodifizierender Code ist, wäre in diesem Fall einfach eine Frage, die Schlaufe wie diese neu zu schreiben: Wiederholung N mal { Erhöhung A um einen tun etwas mit A, wenn STATE muss schalten { ersetzen die opcode-Anhebung oben mit dem opcode zu verringern, oder umgekehrt }} Beachten Sie, dass 2-State-Ersatz des Opcodes leicht als 'xor var an Adresse mit dem Wert "opcodeOf(Inc) xor opcodeOf(dec)" geschrieben werden kann. Die Wahl dieser Lösung muss vom Wert N und der Frequenz des Zustandswechsels abhängen. Spezialisierung Angenommen, eine Reihe von Statistiken wie Durchschnitt, Extrema, Standort von Extrema, Standardabweichung, etc. werden für einige große Datensatz berechnet. In einer allgemeinen Situation kann es eine Möglichkeit geben, Gewichte mit den Daten zu assoziieren, so dass jede xi mit einem wi verbunden ist und anstatt auf das Vorhandensein von Gewichten bei jedem Indexwert zu testen, könnte es zwei Versionen der Berechnung, eine für die Verwendung mit Gewichten und eine nicht, mit einem Test zu Beginn. Betrachten Sie nun eine weitere Option, dass jedem Wert ein Boolean zugeordnet sein kann, um zu bestimmen, ob dieser Wert übersprungen werden soll oder nicht. Dies könnte durch die Herstellung von vier Chargen von Code, eine für jede Permutation und Code-Blut Ergebnisse behandelt werden. Alternativ könnten das Gewicht und die Sprungarrays zu einem temporären Array (mit Nullgewichten für zu überspringende Werte) zu den Kosten der Verarbeitung zusammengeführt werden und es gibt noch Blähungen. Mit der Code-Änderung könnte jedoch die Vorlage zur Berechnung der Statistiken gegebenenfalls den Code zum Überspringen unerwünschter Werte und zum Anwenden von Gewichten hinzugefügt werden. Es gäbe keine wiederholte Prüfung der Optionen und das Datenfeld würde einmal aufgerufen werden, wie auch die Gewicht- und Sprung-Arrays, wenn beteiligt. Verwendung als camouflage Self-modifying-Code wurde verwendet, um Kopierschutz-Anweisungen in 1980s scheibenbasierten Programmen für Plattformen wie IBM PC und Apple II zu verbergen. Beispielsweise würde auf einem IBM-PC (oder kompatiblen) die Diskette-Laufwerk-Zugriffsanweisung 'int 0x13' nicht im Bild des ausführbaren Programms erscheinen, sondern nach dem Ausführen des Programms in das ausführbare Speicherbild geschrieben werden. Selbstmodifizierender Code wird auch manchmal von Programmen verwendet, die ihre Anwesenheit nicht zeigen wollen, wie Computerviren und einige Shellcodes. Viren und Shellcodes, die selbstmodifizierenden Code verwenden, tun dies meist in Kombination mit polymorphem Code. Eine Änderung eines laufenden Codes wird auch bei bestimmten Angriffen, wie Pufferüberläufen, verwendet. Übliche maschinelle Lernsysteme haben einen festen, vorprogrammierten Lernalgorithmus, um ihre Parameter anzupassen. Seit den 1980er Jahren veröffentlichte Jürgen Schmidhuber jedoch mehrere selbstmodifizierende Systeme mit der Fähigkeit, ihren eigenen Lernalgorithmus zu ändern. Sie vermeiden die Gefahr katastrophaler Selbstrewrite, indem sie sicherstellen, dass Selbst-Modifikationen nur überleben, wenn sie nach einer benutzergeprüften Fitness-, Fehler- oder Belohnungsfunktion nützlich sind. Betriebssysteme Aufgrund der Sicherheitsbeeinträchtigungen des selbst ändernden Codes, sind alle großen Betriebssysteme vorsichtig, solche Schwachstellen zu entfernen, wie sie bekannt werden. Die Sorge ist in der Regel nicht, dass Programme sich absichtlich ändern, aber dass sie durch einen Exploit schädlich geändert werden könnte. Als Folge der Probleme, die durch diese Exploits verursacht werden können, wurde eine OS-Funktion namens W^X (für "schreiben xor ausführen)" entwickelt, die ein Programm verbietet, jede Seite des Speichers sowohl schreibbar als auch ausführbar zu machen. Einige Systeme verhindern, dass eine schreibbare Seite jemals geändert wird, um ausführbar zu sein, auch wenn die Schreibberechtigung entfernt wird. Andere Systeme bieten eine 'Hintertür' von Arten, so dass mehrere Mappings einer Seite von Speicher verschiedene Berechtigungen haben. Ein relativ tragbarer Weg, um W^X zu umgehen, ist, eine Datei mit allen Berechtigungen zu erstellen, dann die Datei zweimal in den Speicher abbilden. Auf Linux kann man ein ungeschädigtes SysV-Gegenspeicher-Flag verwenden, um ausführbaren gemeinsamen Speicher zu erhalten, ohne eine Datei zu erstellen. Unabhängig davon, auf einer Meta-Ebene, können Programme immer noch ihr eigenes Verhalten ändern, indem Daten anderswo gespeichert werden (siehe Metaprogrammierung) oder durch Verwendung von Polymorphismus. Interaktion von Cache und selbstmodifizierendem Code Auf Architekturen ohne gekoppelten Daten- und Befehlscache (einige ARM- und MIPS-Kerne) muss die Cache-Synchronisation explizit durch den Modifizierungscode (Flussdatencache und ungültiger Befehlscache für den modifizierten Speicherbereich) durchgeführt werden. In einigen Fällen führen kurze Abschnitte des selbstmodifizierenden Codes langsamer auf modernen Prozessoren aus. Dies ist, weil ein moderner Prozessor in der Regel versuchen, Blöcke von Code in seinem Cache-Speicher zu halten. Jedes Mal, wenn das Programm einen Teil von sich selbst neu schreibt, muss das neu geschriebene Teil wieder in den Cache geladen werden, was zu einer leichten Verzögerung führt, wenn das modifizierte Codelet dieselbe Cachezeile mit dem modifizierenden Code teilt, wie es der Fall ist, wenn sich die geänderte Speicheradresse innerhalb von wenigen Bytes zum einen des modifizierenden Codes befindet. Die Cache-Invalidierung bei modernen Prozessoren bedeutet in der Regel, dass selbstmodifizierender Code noch schneller sein würde, nur wenn die Modifikation selten auftritt, wie bei einem Zustandswechsel innerhalb einer inneren Schleife. Die meisten modernen Prozessoren laden den Maschinencode, bevor sie ihn ausführen, was bedeutet, dass, wenn eine Befehl, die zu nah am Befehlszeiger ist, wird der Prozessor nicht bemerken, sondern den Code ausführen, wie es war, bevor es geändert wurde. Siehe Eingabewarteschlange (PIQ.) PC-Prozessoren müssen aus Gründen der Rückwärtskompatibilität den selbstmodifizierenden Code korrekt behandeln, aber sie sind damit weit davon entfernt. Synthesis Kernel von Massalin Der Synthesis-Kernel, der in der Ph.D-Thesis von Alexia Massalin präsentiert wird, ist ein winziger Unix-Kernel, der einen strukturierten oder sogar objektorientierten Ansatz zur Selbst-Modifikations-Code, in dem Code für einzelne Quajekte erstellt wird, wie Filehandles. Durch die Generierung des Codes für bestimmte Aufgaben kann der Synthesis-Kernel (als JIT-Interpreter könnte) eine Reihe von Optimierungen wie konstante Faltung oder gemeinsame Subexpressionsbeseitigung anwenden. Der Synthesis-Kernel war sehr schnell, wurde aber vollständig in der Montage geschrieben. Die daraus resultierende mangelnde Portabilität verhinderte, dass die Optimierungsideen von Massalin von jedem Produktionskern übernommen werden. Die Struktur der Techniken deutet jedoch darauf hin, dass sie von einer höheren Sprachstufe erfasst werden können, wenn auch eine komplexere als bestehende Mittelsprachen. Eine solche Sprache und Compiler könnten die Entwicklung schnellerer Betriebssysteme und Anwendungen ermöglichen. Paul Haeberli und Bruce Karsh haben sich gegen die Marginalisierung des selbstmodifizierenden Codes und die Optimierung im Allgemeinen zugunsten reduzierter Entwicklungskosten ausgesprochen. Vorteile Schnelle Pfade können für die Ausführung eines Programms festgelegt werden, wodurch einige sonst repetitive bedingte Zweige reduziert werden. Selbstmodifizierender Code kann die algorithmische Effizienz verbessern. Nachteile Selbstmodifizierender Code ist schwerer zu lesen und zu pflegen, weil die Anweisungen in der Quellprogrammliste nicht unbedingt die Anweisungen sind, die ausgeführt werden. Selbstmodifikation, die aus der Substitution von Funktionszeigern besteht, kann nicht als kryptisch sein, wenn klar ist, dass die Namen der zu nennenden Funktionen Platzhalter für später zu identifizierende Funktionen sind. Selbstmodifizierender Code kann als Code neu geschrieben werden, der eine Flagge und Zweige auf alternative Sequenzen basierend auf dem Ergebnis der Prüfung testet, aber selbstmodifizierender Code läuft typischerweise schneller. Bei modernen Prozessoren mit einer Befehlspipeline kann der Code, der sich häufig verändert, langsamer laufen, wenn er Anweisungen modifiziert, die der Prozessor bereits aus dem Speicher in die Pipeline gelesen hat. Auf einigen solchen Prozessoren ist der einzige Weg, um sicherzustellen, dass die geänderten Anweisungen korrekt ausgeführt werden, die Pipeline zu spülen und viele Anweisungen erneut zu lesen. Selbstmodifizierender Code kann in einigen Umgebungen überhaupt nicht verwendet werden, wie zum Beispiel: Anwendungssoftware, die unter einem Betriebssystem mit strenger W^X-Sicherheit läuft, kann keine Anweisungen auf Seiten ausführen, auf die es schreiben darf – nur das Betriebssystem darf sowohl Schreibbefehle zum Speichern schreiben als auch diese Anweisungen später ausführen. Viele Harvard-Architektur-Mikrocontroller können keine Anweisungen im Schreib-Lese-Speicher ausführen, sondern nur Anweisungen im Speicher, die es nicht schreiben kann, ROM oder nicht-selbstprogrammierbare Flash-Speicher. Eine mehrgängige Anwendung kann mehrere Fäden aufweisen, die den gleichen Abschnitt des selbstmodifizierenden Codes ausführen, was möglicherweise zu Rechenfehlern und Anwendungsausfällen führt. Siehe auch Polymorpher Code Polymorphic Engine Persistent Datenstruktur AARD-Code Algorithmic Effizienz eval Statement IBM 1130 (Beispiel) Just-in-time-Compilation: Diese Technik kann den Benutzern oft viele der Vorteile von selbst ändernden Code (außer Speichergröße) ohne die Nachteile geben. Dynamische Totcode Eliminierung Homoiconicity PCASTL Quine (computing) Selbstreplikation Reflexion (Computerwissenschaft) Affen-Patch: eine Änderung des Laufzeitcodes, die den ursprünglichen Quellcode eines Programms nicht beeinflusst Erweiterbare Programmierung: ein Programmierparadigma, in dem eine Programmiersprache seine eigene Syntax Computer Virus Selbst-Hosting Referenzen Externe Links Verwenden Selbst-Modifizierung Code unter Linux Selbst-modifizieren C-Code Certified Selbst-Modifying CodeJohn Bosley Ziegler (ca. 1920–1983) - bekannt als John Ziegler und Montana Jack - war der amerikanische Arzt, der ursprünglich die anabole Steroid Metabolstenolone entwickelt hat. Er bahnte seine sportliche Verwendung als Hilfe für Muskelwachstum durch Bodybuilder, Verwaltung es an US-Gewichtslifting-Champion Bill March des York Barbell Club 1959, als er der Arzt der US-Gewichtlifting-Team war. Es wurde von der Food and Drug Administration (FDA) unter dem Kontrollierten Substanzgesetz verboten. Im späteren Leben war er gegen seinen Einsatz im Sport ausgesprochen und sagte: "Es ist schlecht genug, um mit Drogenabhängigen umzugehen, aber jetzt setzen sich gesunde Athleten in die gleiche Kategorie. Es ist eine Schande. Wer spielt Sport? Ziegler litt an Herzerkrankungen, die er teilweise zu seinem Experimentieren mit Steroiden be schrieb, und er starb 1983 an Herzinsuffizienz. Biographie Frühes Leben Ziegler wurde in den Midwestern USA geboren, aber er kehrte zu seiner Familie Wurzeln in Süd Pennsylvania und Absolvent der Gettysburg College in 1942. Er stammte von drei Generationen von Ärzten, die in den amerikanischen Bürgerkrieg zurückgingen, und sein Vater war sowohl Arzt als auch Wissenschaftler gewesen, die die Salztablette entdeckt hatten. Er diente im Zweiten Weltkrieg als Offizier im Marine Corps der Vereinigten Staaten im Pazifik, wo er umfangreiche Kugeln erlitten. Seine Erfahrung in der Chirurgie und Rekonvaleszenz führt zu einer Spezialität in der rekuperativen Medizin an der University of Maryland Medical School. Er diente seinem Praktikum und Aufenthalt in Marine Krankenhäusern in Norfolk Virginia und Mobile Alabama, bevor er eine zweijährige Residenz in der Neurologie an der Tulane University School of Medicine in New Orleans absolvierte. 1954, nachdem er sich in Olney, Maryland, spezialisierte er sich auf die Behandlung von behinderten und schwer verletzten Patienten während der Durchführung der Teilzeit-Chemie-Forschung bei Ciba Pharmaceuticals auf Summit, N.J.Er wurde ein begeisterter Gewichtheber, der Eisen im York Barbell Club gepumpt, die im Zentrum von American Fitness Training dank seines Besitzers Bob Hoffman. Hoffman hatte mit Joe Weider und Charles Atlas für den Titel von Herrn Amerika konkurrieren und schrieb das Buch Weight Lifting 1939. Zieglers wissenschaftliche Anmeldeinformationen ergänzten Hoffmans Bodybuilding Theorien. Ziegler befreundet Gewichtheber und Bodybuildermeister John Grimek, der von Hoffman eingesetzt wurde. Entwicklung von anabolen Steroiden Im Oktober 1954, Ziegler, ging nach Wien mit dem amerikanischen Gewichtheben Team. Dort traf er einen russischen Physiker, der über "ein paar Drinks" wiederholt fragte: "Was gibst du deinen Jungs?" Als Ziegler die Frage zurückkehrte, sagte der Russe, dass seine eigenen Athleten erhalten Testosteron. Zurück nach Amerika, Ziegler versuchte schwache Dosen von Testosteron auf sich, auf dem amerikanischen Trainer Bob Hoffman und auf drei Lifter, John Grimek, Jim Park und Yaz Kuzahara. Alle hatten mehr Gewicht und Stärke als jedes Trainingsprogramm, aber es gab Nebenwirkungen. Mit der Forschungshilfe von Ciba Pharmaceuticals begann Ziegler, nach synthetischen Substanzen zu suchen, die Testosteron imitieren würden. Die Arbeiten an der CIBA erlaubten Ziegler Zugang zu Büchern und Aufzeichnungen aus Deutschland, wo Experimente mit Testosteron von den Nazis durchgeführt wurden und die nach dem Krieg von den Vereinigten Staaten beschlagnahmt worden waren. Ziegler suchte ein Medikament ohne Nachwirkungen und traf auf ein anaboles Steroid, methandrostenolone (Dianabol, DBOL,) in den USA im Jahr 1958 von Ciba. Ziegler gab Dianabol an das gesamte US-Olympische Gewichtheben-Team in Rom 1960, aber sie verloren noch an die Sowjets. Er gab Experimente mit Sportlern auf, als er erfuhr, dass einige, die 20 mal die empfohlene Dosis von Dianabol genommen hatte eine Leber Zustand entwickelt. Er wurde 1972 in Science zitiert und sagte: "Ich habe Interesse daran verloren, mit IQs dieses Kalibers zu täuschen. Jetzt geht es um so weit unter diesen Idioten wie Marihuana." In späteren Jahren bedauerte Ziegler die Einführung von AAS zu Sportlern. Er erinnerte sich "aber ich wünschte Gott jetzt würde ich es nie getan. Ich möchte zurück und das ganze Kapitel aus meinem Leben herausnehmen." Siehe auch Ergogene Verwendung von anabolen Steroiden Doping in Sport Referenzen Externe Links Der Mann Hinter dem Saft - vor fünfzig Jahren, ein Arzt brachte Steroide nach Amerika. Von Justin Peters Doc Ziegler Von Bill Starr