Extensible Markup Language (XML) ist eine Markup-Sprache, die eine Reihe von Regeln für die Codierung von Dokumenten in einem Format definiert, das sowohl menschlesbar als auch maschinenlesbar ist. Die XML 1.0-Spezifikation des World Wide Web Consortiums von 1998 und mehrere andere verwandte Spezifikationen – alle von ihnen freien offenen Standards – definieren XML. Die Designziele von XML betonen Einfachheit, Allgemeinheit und Usability im gesamten Internet. Es ist ein Textformat mit starker Unterstützung über Unicode für verschiedene menschliche Sprachen. Obwohl sich das Design von XML auf Dokumente konzentriert, wird die Sprache für die Darstellung willkürlicher Datenstrukturen, wie sie in Webdiensten verwendet werden, weit verbreitet. Es gibt mehrere Schemasysteme, die bei der Definition von XML-basierten Sprachen helfen, während Programmierer viele Anwendungs-Programmierschnittstellen (APIs) entwickelt haben, um die Verarbeitung von XML-Daten zu unterstützen. Anwendungen Das Wesen, warum erweiterbare Markup-Sprachen erforderlich sind, wird in Markup-Sprache (z.B. Markup-Sprache § XML) und bei Standard Generalized Markup Language erläutert. Hunderte Dokumentformate mit XML-Syntax wurden entwickelt, darunter RSS, Atom, SOAP, SVG und XHTML. XML-basierte Formate sind die Standardeinstellung für viele Office-Produktivitätstools, darunter Microsoft Office Open XML, OpenOffice.org und LibreOffice (OpenDocument) und Apples iWork. XML hat auch die Basissprache für Kommunikationsprotokolle wie XMPP zur Verfügung gestellt. Anwendungen für den Microsoft .NETFramework verwenden XML-Dateien für die Konfiguration, und Eigenschaftslisten sind eine Implementierung des Konfigurationsspeichers auf XML. Viele Branchendatenstandards wie Health Level 7, OpenTravel Alliance, FpML, MISMO und National Information Exchange Model basieren auf XML und den reichen Funktionen der XML-Schemaspezifikation. Viele dieser Standards sind ziemlich komplex und es ist nicht ungewöhnlich, dass eine Spezifikation mehrere tausend Seiten umfassen. Darwin Information Typing Architecture ist ein XML-Industriedatenstandard. XML wird verwendet, um verschiedene Verlagsformate zu unterstützen. XML wird in einer Service-orientierten Architektur (SOA) weit verbreitet. Disparate Systeme kommunizieren miteinander, indem XML-Nachrichten ausgetauscht werden. Das Nachrichtenaustauschformat wird als XML-Schema (XSD) standardisiert. Dies wird auch als canonisches Schema bezeichnet. XML ist für den Datenaustausch über das Internet häufig genutzt worden. IETF RFC:3023, jetzt überholt von RFC:7303, gab Regeln für den Bau von Internet-Media-Typen für den Einsatz beim Senden von XML. Es definiert auch die Medientypen Applikation/xml und Text/xml, die nur sagen, dass die Daten in XML sind, und nichts über ihre Semantik. RFC 7303 empfiehlt auch, dass XML-basierte Sprachen in +xml endenden Medientypen erhalten werden; zum Beispiel Image/svg+xml für SVG. Weitere Richtlinien für die Verwendung von XML in einem vernetzten Kontext erscheinen in RFC 3470, auch bekannt als IETF BCP 70, ein Dokument, das viele Aspekte der Gestaltung und Bereitstellung einer XML-basierten Sprache abdeckt. Schlüsselterminologie Das Material in diesem Abschnitt basiert auf der XML-Spezifikation. Dies ist keine vollständige Liste aller Konstrukte, die in XML erscheinen; es bietet eine Einführung in die wichtigsten Konstrukte am häufigsten im täglichen Gebrauch begegnet. Charakter Ein XML-Dokument ist eine Zeichenfolge. Fast jedes rechtliche Unicode-Zeichen kann in einem XML-Dokument erscheinen. Prozessor und Anwendung Der Prozessor analysiert das Markup und übermittelt strukturierte Informationen an eine Anwendung. Die Spezifikation stellt Anforderungen an das, was ein XML-Prozessor tun muss und nicht, aber die Anwendung ist außerhalb ihres Umfangs. Der Prozessor (wie die Spezifikation ruft es) wird oft als XML-Parser bezeichnet. Markup und Inhalt Die Zeichen, die ein XML-Dokument bilden, sind in Markup und Inhalt unterteilt, die durch die Anwendung einfacher syntaktischer Regeln unterschieden werden können. Generell beginnen Strings, die ein Markup darstellen, entweder mit dem Zeichen < und enden mit einem >, oder sie beginnen mit dem Zeichen & und enden mit einer .;Strings von Zeichen, die nicht markiert sind, sind Inhalte. In einem CDATA-Abschnitt werden jedoch die Abgrenzer !<CDATA und ]> als Markup eingestuft, während der Text zwischen ihnen als Inhalt eingestuft wird. Zusätzlich wird der Weißraum vor und nach dem äußersten Element als Markup eingestuft. Tag A Tag ist ein Markup-Konstrukt, das mit < beginnt und endet mit .>Tags kommen in drei Aromen: Start-tag, wie <section;> End-tag, wie </section;> Leer-Element-Tag, wie <line-break .>/Element Ein Element ist eine logische Dokumentkomponente, die entweder mit einem Starttag beginnt und mit einem passenden Endtag endet oder nur aus einem leeren Element-Tag besteht. Die Zeichen zwischen Start-Tag und End-Tag, falls vorhanden, sind der Inhalt des Elements und können Markup enthalten, einschließlich anderer Elemente, die als Child-Elemente bezeichnet werden. Ein Beispiel ist <greeing> Hallo, Welt!</greeting>. Ein anderer ist <line-break .>/Attribute Ein Attribut ist ein Markup-Konstrukt, bestehend aus einem Namen-Wert-Paar, das innerhalb eines Start-Tags oder leeren Element-Tags existiert. Ein Beispiel ist <img src="madonna.jpg alt="Madonna />, wo die Namen der Attribute src und alt sind, und ihre Werte sind madonna.jpg bzw. Madonna. Ein weiteres Beispiel ist <step number="3">Connect A to B.</step,>, wobei der Name des Attributs die Zahl ist und dessen Wert 3" ist. Ein XML-Attribut kann nur einen einzigen Wert haben und jedes Attribut kann maximal einmal auf jedem Element erscheinen. In der gemeinsamen Situation, in der eine Liste von mehreren Werten gewünscht wird, muss dies geschehen, indem die Liste in ein gut gebildetes XML-Attribut mit einem bestimmten Format über das, was XML selbst definiert, kodiert wird. Üblicherweise ist dies entweder eine Komma- oder Semikolon-Begrenzte Liste oder, wenn die einzelnen Werte bekannt sind, Leerzeichen nicht enthalten, kann eine raumbegrenzte Liste verwendet werden.<div class="inner gring-box"> Willkommen!</div, wo die Attributklasse sowohl den Wert "innere Grußbox" hat als auch die beiden CSS-Klassennamen inner und grüßend anzeigt. XML-Deklaration XML-Dokumente können mit einer XML-Deklaration beginnen, die einige Informationen über sich selbst beschreibt. Ein Beispiel ist ?<xml version="1.0 encoding="UTF-8.?> Charaktere und auslaufende XML-Dokumente bestehen ausschließlich aus Zeichen aus dem Unicode-Repertoire. Außer einer kleinen Anzahl von speziell ausgeschlossenen Kontrollzeichen kann jedes durch Unicode definierte Zeichen innerhalb des Inhalts eines XML-Dokuments erscheinen. XML umfasst Einrichtungen zur Identifizierung der Kodierung der Unicode-Zeichen, die das Dokument bilden, und zum Ausdrucken von Zeichen, die aus einem oder anderen Grund nicht direkt verwendet werden können. Gültige Zeichen Unicode-Code-Punkte in den folgenden Bereichen sind in XML 1.0 Dokumenten gültig: U+0009 (Horizontal Tab,) U+000A (Line Feed,) U+000D (Carriage Return): Dies sind die einzigen C0-Kontrollen, die in XML 1.0 akzeptiert werden; U+0020–U+D7FF, U+E000–U+FFFD: dies schließt einige nicht-Kennzeichen in der BMP ein XML 1.1 erweitert den Satz der erlaubten Zeichen, um alle oben, plus die restlichen Zeichen im Bereich U+0001–U+001F. Gleichzeitig schränkt sie jedoch die Verwendung von C0- und C1-Steuerzeichen außer U+0009 (Horizontal Tab,) U+000A (Line Feed,) U+000D (Carriage Return,) und U+0085 (Next Line) ein, indem sie in entgangener Form geschrieben werden müssen (z.B. U+0001 muss als #&x01 oder sein Äquivalent geschrieben werden). Bei C1-Zeichen ist diese Einschränkung eine rückständige Unvereinbarkeit; sie wurde eingeführt, um gemeinsame Kodierungsfehler zu erkennen. Der Codepunkt U+0000 (Null) ist das einzige Zeichen, das in keinem XML 1.0 oder 1.1 Dokument erlaubt ist. Kodierungserkennung Der Unicode-Zeichensatz kann in Bytes für die Speicherung oder Übertragung in unterschiedlicher Weise codiert werden, sogenannte Codierungen". Unicode selbst definiert Kodierungen, die das gesamte Repertoire abdecken; bekannte sind UTF-8 und UTF-16. Es gibt viele andere Textcodierungen, die Unicode vorschreiben, wie ASCII und ISO/IEC 8859; ihre Charakterrepertoires sind in fast jedem Fall Teilmengen des Unicode-Zeichensatzes. XML ermöglicht die Verwendung einer der Unicode-definierten Codierungen und jeder anderen Codierung, deren Zeichen auch in Unicode erscheinen. XML stellt auch einen Mechanismus zur Verfügung, bei dem ein XML-Prozessor ohne vorheriges Wissen zuverlässig bestimmen kann, welche Codierung verwendet wird. Andere Kodierungen als UTF-8 und UTF-16 werden nicht unbedingt von jedem XML-Parser erkannt. Escaping XML bietet Escape-Einrichtungen für einschließlich Zeichen, die problematisch sind, direkt einschließen. Zum Beispiel: Die Zeichen "<" und "&" sind Schlüssel-Syntax-Marker und können nie in Inhalten außerhalb eines CDATA-Abschnitts erscheinen. Es ist erlaubt, aber nicht empfohlen, "<" in XML-Entity-Werten zu verwenden. Einige Zeichencodierungen unterstützen nur eine Untergruppe von Unicode. Zum Beispiel ist es legal, ein XML-Dokument in ASCII zu kodieren, aber ASCII fehlt Code-Punkte für Unicode-Zeichen wie é". Es könnte nicht möglich sein, den Charakter auf der Maschine des Autors einzutragen. Einige Zeichen haben Glyphen, die nicht visuell von anderen Zeichen unterschieden werden können, wie der nicht brechende Raum #(&xa0;) " und der Raum #(&x20;) ", und der kyrillische Kapitalbrief A #(&x410;) А und der lateinische Kapitalbrief A #(&x41;) A".Es gibt fünf vordefinierte Einheiten: &lt; repräsentiert ">"; &gt; Betrachten Sie den chinesischen Charakter 中, dessen numerischer Code in Unicode hexadezimal 4E2D oder Dezimal 20,013 ist. Ein Benutzer, dessen Tastatur keine Methode zur Eingabe dieses Zeichens bietet, könnte ihn noch in ein XML-Dokument einfügen, das entweder als #&20013 oder #&x4e2d codiert ist. Ebenso könnte der String "I <3Jörg" für die Aufnahme in ein XML-Dokument kodiert werden, wie I &lt;3 J&#xF6;rg. #&0; ist jedoch nicht zulässig, da das Nullzeichen eine der von XML ausgeschlossenen Kontrollzeichen ist, auch wenn eine numerische Zeichenreferenz verwendet wird. Zur Darstellung solcher Zeichen ist ein alternativer Kodierungsmechanismus wie Base64 erforderlich. Kommentare Kommentare Kommentare können irgendwo in einem Dokument außerhalb anderer Markup erscheinen. Kommentare können nicht vor der XML-Deklaration erscheinen. Kommentare beginnen mit <!- und end mit .>-Für die Kompatibilität mit SGML ist der String "-" (doppel-hyphen) nicht innerhalb Kommentare erlaubt; das bedeutet, dass Kommentare nicht geschachtelt werden können. Der Ampersand hat keine besondere Bedeutung in Kommentaren, so dass Entitäts- und Charakterreferenzen nicht als solche erkannt werden, und es gibt keine Möglichkeit, Zeichen außerhalb des Zeichensatzes der Dokumentencodierung darzustellen. Ein Beispiel für einen gültigen Kommentar: !<-no need to fl <code> & solche in comments>- Die internationale Verwendung von XML 1.0 (Fifth Edition) und XML 1.1 unterstützt die direkte Verwendung von nahezu jedem Unicode-Zeichen in Elementnamen, Attributen, Kommentaren, Zeichendaten und Verarbeitungsanweisungen (ausgenommen diejenigen, die in XML selbst eine besondere symbolische Bedeutung haben, wie z.B. das weniger-als-Zeichen, .)<Das folgende ist ein gut gebildetes XML-Dokument, einschließlich chinesischer, armenischer und kyrillischer Zeichen: Die XML-Spezifikation definiert ein XML-Dokument als gut ausgebildeter Text, was bedeutet, dass es eine Liste von Syntax-Regeln in der Spezifikation erfüllt. Einige Schlüsselpunkte in der ziemlich langen Liste beinhalten: Das Dokument enthält nur richtig kodierte juristische Unicode-Zeichen. Keine der speziellen Syntax-Zeichen wie < und & erscheinen außer bei der Durchführung ihrer Markup-Delineation Rollen. Der Start-Tag, End-Tag und Leer-Element-Tag, die Elemente begrenzen, sind richtig geschachtelt, ohne fehlt und keine Überlappung. Tag-Namen sind case-sensitive; Start-tag und End-tag müssen genau übereinstimmen. Tag-Namen können keine der Zeichen enthalten !#$%&'()*+,/;<=>?@[\]^`{|}~, noch ein Raumzeichen, und können nicht mit "-", ", oder einer numerischen Ziffer beginnen. Ein einziges Wurzelelement enthält alle anderen Elemente. Die Definition eines XML-Dokuments schließt Texte aus, die Verstöße gegen gut formulierte Regeln enthalten; sie sind einfach nicht XML. Ein XML-Prozessor, der eine solche Verletzung auftritt, ist erforderlich, um solche Fehler zu melden und die normale Verarbeitung einzustellen. Diese Politik, gelegentlich als "drakonische Fehlerbehandlung" bezeichnet, steht in bemerkenswertem Gegensatz zu dem Verhalten von Programmen, die HTML verarbeiten, die entworfen sind, um ein vernünftiges Ergebnis auch in Gegenwart von schweren Markup-Fehlern zu erzeugen. XMLs Politik in diesem Bereich wurde als Verstoß gegen Postels Gesetz kritisiert ("Be konservative in what you send; seien Sie liberal in was Sie akzeptieren"). Die XML-Spezifikation definiert ein gültiges XML-Dokument als gut ausgebildetes XML-Dokument, das auch den Regeln einer Document Type Definition (DTD) entspricht. Schemas und Validierung Ein XML-Dokument kann neben einer guten Form auch gültig sein. Dies bedeutet, dass es einen Verweis auf eine Definition des Dokumenttyps (DTD) enthält und dass seine Elemente und Attribute in diesem DTD erklärt werden und den grammatischen Regeln für sie folgen, die der DTD angibt. XML-Prozessoren werden als Validierung oder Nichtvalidierung eingestuft, je nachdem, ob sie XML-Dokumente für Gültigkeit überprüfen. Ein Prozessor, der einen Gültigkeitsfehler entdeckt, muss in der Lage sein, ihn zu melden, kann aber die normale Verarbeitung fortsetzen. Ein DTD ist ein Beispiel eines Schemas oder einer Grammatik. Seit der ersten Veröffentlichung von XML 1.0 gibt es im Bereich der Schemasprachen für XML erhebliche Arbeiten. Solche Schemasprachen schränken typischerweise den Satz von Elementen ein, die in einem Dokument verwendet werden können, die Attribute können auf sie angewendet werden, die Reihenfolge, in der sie auftreten können, und die zulässigen Eltern-Kind-Beziehungen. Definition des Typs Die älteste Schemasprache für XML ist die Dokumenttypdefinition (DTD), die von SGML geerbt wird. DTDs haben folgende Vorteile: Die DTD-Unterstützung ist aufgrund ihrer Einbeziehung in den XML 1.0 Standard allgegenwärtig. DTDs sind terse im Vergleich zu elementbasierten Schemasprachen und stellen somit weitere Informationen in einem einzigen Bildschirm vor. DTDs ermöglichen die Erklärung von Standard-Publicity-Sets für die Veröffentlichung von Zeichen. DTDs definieren einen Dokumenttyp anstatt die Typen, die von einem Namensraum verwendet werden, und gruppieren somit alle Einschränkungen für ein Dokument in einer einzigen Sammlung. DTDs haben folgende Einschränkungen: Sie haben keine ausdrückliche Unterstützung für neuere Funktionen von XML, vor allem Namespaces. Sie haben keinen Ausdruck. XML DTDs sind einfacher als SGML DTDs und es gibt bestimmte Strukturen, die nicht mit regelmäßigen Grammatiken ausgedrückt werden können. DTDs unterstützen nur rudimentäre Datentypen. Sie haben keine Lesbarkeit. DTD-Designer nutzen typischerweise Parametereinheiten (die sich im Wesentlichen als Textmakros verhalten), die es einfacher machen, komplexe Grammatiken zu definieren, aber auf Kosten der Klarheit. Sie verwenden eine Syntax basierend auf einer regelmäßigen Expressions-Syntax, die von SGML geerbt wurde, um das Schema zu beschreiben. Typische XML APIs wie SAX versuchen nicht, Anwendungen eine strukturierte Darstellung der Syntax anzubieten, so dass es für Programmierer weniger zugänglich ist als eine elementare Syntax. Zwei Besonderheiten, die DTDs von anderen Schematypen unterscheiden, sind die syntaktische Unterstützung zur Einbettung eines DTD in XML-Dokumente und zur Definition von Entitäten, die willkürliche Fragmente von Text oder Markup sind, die der XML-Prozessor in der DTD selbst und in dem XML-Dokument einfügen, wo immer sie referiert werden, wie Zeichen entweicht. Die DTD-Technologie wird aufgrund ihrer Ubiquity immer noch in vielen Anwendungen eingesetzt. Schema Eine neuere Schemasprache, die von der W3C als Nachfolger von DTDs beschrieben wird, ist XML-Schema, oft vom Initialismus für XML-Schema-Instanzen, XSD (XML-Schemadefinition). XSDs sind viel leistungsfähiger als DTDs bei der Beschreibung von XML-Sprachen. Sie verwenden ein reiches Datatyping-System und ermöglichen detailliertere Zwänge auf der logischen Struktur eines XML-Dokuments. XSDs verwenden auch ein XML-basiertes Format, das es ermöglicht, gewöhnliche XML-Tools zur Verarbeitung zu verwenden. xs:Schemaelement, das ein Schema definiert: RELAX NG RELAX NG (Regular Language for XML Next Generation) wurde ursprünglich von OASIS spezifiziert und ist jetzt ein Standard (Teil 2: Regular-Gramm-basierte Validierung von ISO/IEC 19757 – DSDL). RELAX NG-Schemas können entweder in einer XML-basierten Syntax oder einer kompakteren Non-XML-Syntax geschrieben werden; die beiden Syntaxen sind isomorph und James Clarks Konvertierungstool - Trang - kann zwischen ihnen ohne Informationsverlust umwandeln. RELAX NG hat ein einfacheres Definitions- und Validierungs-Framework als XML-Schema, wodurch es einfacher zu bedienen und umzusetzen ist. Es hat auch die Möglichkeit, Datatype-Framework-Plugins zu verwenden; ein RELAX NG-Schema-Autor kann beispielsweise Werte in einem XML-Dokument benötigen, um den Definitionen in XML-Schema-Datentypen zu entsprechen. Schematron Schematron ist eine Sprache, um Aussagen über die Anwesenheit oder Abwesenheit von Mustern in einem XML-Dokument zu machen. Es verwendet typischerweise XPath-Ausdrücke. Schematron ist jetzt ein Standard (Teil 3: Regelbasierte Validierung der ISO/IEC 19757 – DSDL.) DSDL und andere Schemasprachen DSDL (Document Schema Definition Languages) ist ein mehrteiliger ISO/IEC-Standard (ISO/IEC 19757), der eine umfassende Reihe kleiner Schemasprachen zusammenbringt, die jeweils auf spezifische Probleme ausgerichtet sind. DSDL umfasst RELAX NG vollständige und kompakte Syntax, Schematron-Behauptungssprache und Sprachen zur Definition von Datentypen, Charakterrepertoirezwängen, Umbenennung und Entity-Erweiterung sowie namenraumbasiertes Routing von Dokumentenfragmenten an verschiedene Validierungsmitglieder. Die DSDL-Schemasprachen haben noch nicht die Anbieterunterstützung von XML-Schemas und sind in gewissem Maße eine Basisreaktion von Industrieverlegern in der fehlenden Verwendung von XML-Schemas für die Veröffentlichung. Einige Schemasprachen beschreiben nicht nur die Struktur eines bestimmten XML-Formats, sondern bieten auch begrenzte Einrichtungen, um die Verarbeitung einzelner XML-Dateien zu beeinflussen, die diesem Format entsprechen. DTDs und XSDs haben beide diese Fähigkeit; sie können zum Beispiel die Infoset-Augmentation-Einrichtung und Attribut-Standards bereitstellen. RELAX NG und Schematron liefern diese absichtlich nicht. Weitere Spezifikationen Ein Cluster von Spezifikationen, die eng mit XML zusammenhängen, wurde entwickelt, beginnend bald nach der ersten Veröffentlichung von XML 1.0. Es ist häufig der Fall, dass der Begriff XML verwendet wird, um XML zusammen mit einer oder mehreren dieser anderen Technologien zu beziehen, die als Teil des XML-Kerns zu sehen sind. XML-Namespaces ermöglichen das gleiche Dokument, XML-Elemente und Attribute aus verschiedenen Vokabeln zu enthalten, ohne dass es zu Namenskollisionen kommt. Obwohl XML Namespaces sind nicht Teil der XML-Spezifikation selbst, praktisch alle XML-Software unterstützt auch XML Namespaces. XML Base definiert das xml:base Attribut, das verwendet werden kann, um die Basis für die Auflösung von relativen URI Referenzen im Rahmen eines einzigen XML-Elements festzulegen. XML Information Set oder XML Infoset ist ein abstraktes Datenmodell für XML-Dokumente in Bezug auf Informationen. Der Infoset wird häufig in den Spezifikationen von XML-Sprachen verwendet, um Einschränkungen auf dem XML-Konstrukt zu beschreiben, die diese Sprachen zulassen. XSL (Extensible Stylesheet Language) ist eine Familie von Sprachen, die verwendet werden, um XML-Dokumente zu transformieren und zu rendern, aufgeteilt in drei Teile:XSLT (XSL Transformations,) eine XML-Sprache für die Umwandlung von XML-Dokumenten in andere XML-Dokumente oder andere Formate wie HTML, Klartext oder XSL-FO. XSLT ist sehr eng mit XPath gekoppelt, die es verwendet, um Komponenten des XML-Eingabedokuments zu adressieren, hauptsächlich Elemente und Attribute. XSL-FO (XSL Formating Objects) eine XML-Sprache für die Wiedergabe von XML-Dokumenten, die oft für die Erstellung von PDFs verwendet werden. XPath (XML Path Language) eine nicht-XML-Sprache zur Adressierung der Komponenten (Elemente, Attribute usw.) eines XML-Dokuments. XPath ist weit verbreitet in anderen Core-XML-Spezifikationen und in Programmierbibliotheken für den Zugriff auf XML-codierte Daten. XQuery (XML Query) ist eine XML-Abfrage-Sprache, die in XPath und XML Schema stark verwurzelt ist. Es bietet Methoden, um XML zuzugreifen, zu manipulieren und zurückzugeben, und wird hauptsächlich als Abfragesprache für XML-Datenbanken konzipiert. XML Signature definiert Syntax- und Verarbeitungsregeln für die Erstellung digitaler Signaturen auf XML-Inhalte. XML Encryption definiert Syntax- und Verarbeitungsregeln für die Verschlüsselung von XML-Inhalten.xml-Modell (Teil 11: Schema Association of ISO/IEC 19757 – DSDL) definiert ein Mittel zur Zuordnung jedes xml-Dokuments mit einem der oben genannten Schematypen. Einige andere Spezifikationen, die im Rahmen des "XML Core" konzipiert wurden, haben es nicht geschafft, eine breite Adoption zu finden, darunter XInclude, XLink und XPointer. Programmierschnittstellen Die Designziele von XML beinhalten: "Es ist einfach, Programme zu schreiben, die XML-Dokumente bearbeiten." Trotzdem enthält die XML-Spezifikation fast keine Informationen darüber, wie Programmierer diese Verarbeitung durchführen können. Die XML Infoset-Spezifikation bietet einen Wortschatz, um sich auf die Konstrukte innerhalb eines XML-Dokuments zu beziehen, bietet jedoch keine Anleitung zum Zugriff auf diese Informationen. Eine Vielzahl von APIs für den Zugriff auf XML wurden entwickelt und verwendet, und einige wurden standardisiert. Vorhandene APIs für die XML-Verarbeitung fallen in diese Kategorien: Streamorientierte APIs, die aus einer Programmiersprache zugänglich sind, zum Beispiel SAX und StAX. Tree-traversal APIs aus einer Programmiersprache, zum Beispiel DOM, zugänglich. XML-Datenbindung, die eine automatisierte Übersetzung zwischen einem XML-Dokument und programmgesteuerten Objekten liefert. Deklarative Transformationssprachen wie XSLT und XQuery. Syntax-Erweiterungen auf allgemeine Programmiersprachen, beispielsweise LINQ und Scala. Streamorientierte Einrichtungen benötigen weniger Speicher und für bestimmte Aufgaben, die auf einer linearen Traversal eines XML-Dokuments basieren, sind schneller und einfacher als andere Alternativen. Baum- und Datenbindung APIs benötigen in der Regel die Verwendung von viel mehr Speicher, aber werden oft bequemer für die Verwendung von Programmierern gefunden; einige beinhalten declarative Retrieval von Dokumentenkomponenten über die Verwendung von XPath-Ausdrücken. XSLT ist für die deklarative Beschreibung von XML-Dokument-Transformationen konzipiert und ist sowohl in serverseitigen Paketen als auch in Webbrowsern weit verbreitet. XQuery überschneidet XSLT in seiner Funktionalität, ist aber eher für die Suche nach großen XML-Datenbanken konzipiert. Einfache API für XML Simple API für XML (SAX) ist eine lexische, ereignisgesteuerte API, in der ein Dokument seriell gelesen wird und deren Inhalte als Rückrufe an verschiedene Methoden an einem Handlerobjekt des Benutzerdesigns gemeldet werden. SAX ist schnell und effizient zu implementieren, aber schwierig zu verwenden, um Informationen zufällig aus dem XML zu extrahieren, da es tendenziell dazu neigt, den Anwendungsautor zu belasten, um zu verfolgen, was Teil des Dokumentes verarbeitet wird. Es ist besser geeignet für Situationen, in denen bestimmte Arten von Informationen immer gleich behandelt werden, egal wo sie im Dokument vorkommen. Pull parsing Pull parsing behandelt das Dokument als eine Reihe von nacheinander gelesenen Artikeln mit dem Iterator Design Muster. Dies erlaubt es, wiederkehrende Abstiegszähler zu schreiben, bei denen die Struktur des Codes, der die Parsing-Spiegel ausführt, die Struktur des XMLs parsiert, und Zwischenparsed-Ergebnisse als lokale Variablen innerhalb der Funktionen, die das Parsing durchführen, verwendet und aufgerufen werden können (als Funktionsparameter) in untergeordnete Funktionen oder zurückgegeben (als Funktion-Return-Werte). Beispiele für Zugscheren sind Daten: Bearbeiten::Xml in Perl, StAX in der Java Programmiersprache, XMLPullParser in Smalltalk, XMLReader in PHP, ElementTree.iterparse in Python, System. Xml.XmlReader im .NET Framework und die DOM-Traversal-API (NodeIterator und TreeWalker). Ein Pull Parser erstellt einen Iterator, der die verschiedenen Elemente, Attribute und Daten in einem XML-Dokument sequentiell besucht. Der Code, der diesen Iterator verwendet, kann den aktuellen Punkt testen (um z.B. zu sagen, ob es sich um einen Start- oder End-Tag oder Text handelt), und seine Attribute (lokaler Name, Namespace, Werte von XML-Attributen, Textwert usw.) inspizieren und den Iterator auch auf den nächsten Punkt verschieben. Der Code kann somit Informationen aus dem Dokument entnehmen, wie er es durchläuft. Der rekursive-descent-Ansatz neigt dazu, Daten als eingegebene lokale Variablen im Code zu halten, der die Parsierung durchführt, während SAX beispielsweise typischerweise einen Parser benötigt, um Zwischendaten innerhalb eines Stapels von Elementen, die Elternelemente des Elements sind, manuell aufrechtzuerhalten. Pull-Pasing-Code kann einfacher zu verstehen und zu pflegen als SAX-Pasing-Code. Document Object Document Document Document Object Model (DOM) ist eine API, die die Navigation des gesamten Dokuments ermöglicht, als wäre es ein Baum von Knotenobjekten, die den Inhalt des Dokuments repräsentieren. Ein DOM-Dokument kann von einem Parser erstellt oder manuell von Benutzern (mit Einschränkungen) erzeugt werden. Datentypen in DOM-Knoten sind abstrakt; Implementierungen bieten ihre eigenen Programmiersprache-spezifischen Bindungen. DOM-Implementierungen sind tendenziell speicherintensiv, da sie in der Regel das gesamte Dokument in den Speicher laden und als Baum von Objekten ausgeführt werden müssen, bevor der Zugriff erlaubt ist. Die Datenbindung von XML-Daten ist die Bindung von XML-Dokumenten an eine Hierarchie von benutzerdefinierten und stark eingegebenen Objekten im Gegensatz zu den generischen Objekten, die von einem DOM-Parser erstellt wurden. Dieser Ansatz vereinfacht die Codeentwicklung, und in vielen Fällen können Probleme zu kompilieren Zeit anstatt Laufzeit identifiziert werden. Es eignet sich für Anwendungen, bei denen die Dokumentenstruktur zum Zeitpunkt der Anmeldung bekannt und fixiert ist. Beispieldatenbindungssysteme umfassen die Java Architecture for XML Binding (JAXB), XML Serialization in .NET Framework. und XML Serialisierung in gSOAP. XML als Datentyp XML ist in anderen Sprachen als erstklassiger Datentyp erschienen. Die Extension ECMAScript for XML (E4X) in die ECMAScript/JavaScript-Sprache definiert explizit zwei spezifische Objekte (XML und XMLList) für JavaScript, die XML-Dokument-Knoten und XML-Knotenlisten als verschiedene Objekte unterstützen und eine Punkt-Notation zur Angabe von Eltern-Kind-Beziehungen verwenden. E4X wird von den Mozilla 2.5+ Browsern (obwohl jetzt depreciert) und Adobe Actionscript unterstützt, wurde aber nicht allgemeiner angenommen. Ähnliche Meldungen werden in Microsofts LINQ-Implementierung für Microsoft .NET 3.5 und oben, und in Scala (die die Java VM verwendet). Die Open-Source xmlsh-Anwendung, die eine Linux-ähnliche Shell mit speziellen Funktionen für die XML-Manipulation bietet, behandelt ebenfalls XML als Datentyp unter Verwendung der <[ ]>-Notation. Das Resource Description Framework definiert einen Datentyp rdf:XMLLiteral, um gewickelt zu halten, canonical XML. Facebook hat Erweiterungen zu den PHP- und JavaScript-Sprachen erstellt, die XML zur Kernsyntax in ähnlicher Weise E4X, nämlich XHP und JSX, hinzufügen. History XML ist ein Anwendungsprofil von SGML (ISO 8879). Die Vielseitigkeit von SGML für dynamisches Informationsdisplay wurde von frühen digitalen Medienverlegern in den späten 1980er Jahren vor dem Anstieg des Internets verstanden. Mitte der 1990er-Jahre hatten einige Praktizierende von SGML Erfahrungen mit dem damals neuen World Wide Web gesammelt und glaubten, dass SGML Lösungen für einige der Probleme bot, denen das Web ausgesetzt war, wie es wuchs. Dan Connolly fügte SGML zur Liste der Aktivitäten von W3C hinzu, als er 1995 dem Personal beitrat; Mitte 1996 begann die Arbeit, als der Ingenieur von Sun Microsystems Jon Bosak einen Charter- und Rekrutierungskollegen entwickelte. Bosak war gut in der kleinen Gemeinschaft von Menschen verbunden, die Erfahrungen sowohl in SGML als auch im Web hatten. XML wurde von einer Arbeitsgruppe von elf Mitgliedern erstellt, die von einer (roughly) 150-köpfigen Interessengruppe unterstützt wurde. Die technische Debatte fand in der Mailingliste der Interessengruppen statt und Fragen wurden durch Konsens oder, wenn dies nicht der Fall war, Mehrheitsentscheidung der Arbeitsgruppe gelöst. Am 4. Dezember 1997 erstellte Michael Sperberg-McQueen eine Aufzeichnung von Designentscheidungen und deren Rationalitäten. James Clark diente als technischer Leiter der Arbeitsgruppe, insbesondere als Beitrag zum leeren Element <empty /> Syntax und dem Namen XML". Weitere Namen, die zur Berücksichtigung vorgelegt wurden, waren MAGMA (Minimal Architecture for Generalized Markup Applications,) SLIM (Structured Language for Internet Markup) und MGML (Minimal Generalized Markup Language). Die Mitherausgeber der Spezifikation waren ursprünglich Tim Bray und Michael Sperberg-McQueen. Auf halbem Weg durch das Projekt Bray akzeptierte ein Beratungsgespräch mit Netscape und provozierte vocifersüchtige Proteste von Microsoft. Bray wurde vorübergehend gebeten, die Redaktion zurückzutreten. Dies führte zu einem intensiven Streit in der Arbeitsgruppe, schließlich durch die Ernennung von Microsofts Jean Paoli als dritter Co-Editor gelöst. Die XML Working Group hat sich nie mit Face-to-face getroffen; das Design wurde mit einer Kombination aus E-Mail und wöchentlichen Telekonferenzen durchgeführt. Die wichtigsten Entwurfsentscheidungen wurden in kurzer Zeit intensiver Arbeit zwischen August und November 1996 getroffen, als der erste Arbeitsentwurf einer XML-Spezifikation veröffentlicht wurde. Weitere Designarbeiten wurden bis 1997 fortgesetzt und XML 1.0 wurde am 10. Februar 1998 zu einer W3C-Empfehlung. Sources XML ist ein Profil einer ISO-Norm SGML, und die meisten XML stammen von SGML unverändert. Von SGML kommt die Trennung von logischen und physikalischen Strukturen (Elemente und Entitäten), die Verfügbarkeit von grammar-basierten Validierung (DTDs,) die Trennung von Daten und Metadaten (Elemente und Attribute,) gemischten Inhalten, die Trennung von Verarbeitung von Darstellung (Verarbeitungsanweisungen,) und der Standardwinkel-Band-Syntax. Die SGML-Deklaration wurde entfernt; XML hat also einen festen Abgrenzersatz und nimmt Unicode als Belegzeichen an. Andere Technologiequellen für XML waren die TEI (Text Encoding Initiative), die ein Profil von SGML für die Verwendung als "Transfer-Syntax" definierte, und HTML, in denen Elemente mit ihrer Ressource synchron waren, Dokument-Zeichensätze getrennt von der Ressourcencodierung waren, das Attribut xml:lang erfunden wurde, und (wie HTTP) Metadaten begleiteten die Ressource anstatt bei der Erklärung eines Links benötigt zu werden. Das ERCS(Extended Reference Concrete Syntax) Projekt des SPREAD (Standardization Project in Bezug auf East Asian Documents) Projekts der ISO-bezogenen China/Japan/Korea Document Processing-Expertengruppe war die Grundlage der Namensregeln von XML 1.0; SPREAD führte auch hexadezimal numerische Zeichenreferenzen und das Konzept von Referenzen ein, um alle Unicode-Zeichen zur Verfügung zu stellen. Um ERCS, XML und HTML besser zu unterstützen, wurde der SGML-Standard IS 8879 1996 und 1998 mit WebSGML Adaptations überarbeitet. Der XML-Header folgte dem von ISO HyTime. Ideen, die während der Diskussion entwickelt wurden, die in XML neu sind, enthalten den Algorithmus für die Codierung Erkennung und die Codierung Header, das Verarbeitungsanweisungs-Ziel, das xml:space-Attribut und die neue enge Begrenzung für leere Element-Tags. Der Begriff der gut-formedness im Gegensatz zu der Gültigkeit (die ermöglicht Parsing ohne Schema) wurde zunächst in XML formalisiert, obwohl es erfolgreich in der Electronic Book Technology Dynatext Software implementiert wurde; die Software der University of Waterloo New Oxford English Dictionary Project; der RISP LISP SGML Textprozessor an Uniscope, Tokyo; das US Army Missile Command IADS Hypertextsystem; Mentor Graphics Conox; Interleaf Publishing System Versionen Es gibt zwei aktuelle Versionen von XML: XML 1.0 Die erste (XML 1.0) wurde zunächst 1998 definiert. Sie hat seitdem kleinere Revisionen vorgenommen, ohne eine neue Versionsnummer zu erhalten, und ist derzeit in ihrer fünften Ausgabe, wie am 26. November 2008 veröffentlicht. Es ist weit verbreitet und immer noch für den allgemeinen Gebrauch empfohlen. XML 1.1The second (XML 1.1) wurde am 4. Februar 2004, am selben Tag wie XML 1.0 Third Edition, veröffentlicht und ist derzeit in seiner zweiten Ausgabe, wie am 16. August 2006 veröffentlicht. Es enthält Funktionen (einige zufriedene), die XML in bestimmten Fällen einfacher zu bedienen. Die wichtigsten Änderungen sollen die Verwendung von auf EBCDIC-Plattformen verwendeten Line-End-Zeichen ermöglichen und die Verwendung von Skripten und Zeichen, die von Unicode 3.2.XML 1.1 fehlt, ist nicht sehr weit verbreitet und wird nur von denjenigen empfohlen, die ihre Besonderheiten benötigen. Gültige Unicode-Zeichen in XML 1.0 und XML 1.1 Vor seiner fünften Ausgabe unterscheidet sich XML 1.0 von XML 1.1 mit strengeren Anforderungen an Zeichen, die für die Verwendung in Element- und Attributnamen und eindeutigen Identifikatoren verfügbar sind: In den ersten vier Editionen von XML 1.0 wurden die Zeichen ausschließlich mit einer bestimmten Version des Unicode-Standards (Unicode 2.0 bis Unicode 3.2) aufgezählt. Die fünfte Ausgabe ersetzt den Mechanismus von XML 1.1, der zukunftssicherer ist, aber Redundanz reduziert. Der Ansatz in der fünften Ausgabe von XML 1.0 und in allen Editionen von XML 1.1 ist, dass nur bestimmte Zeichen in Namen verboten sind und alles andere erlaubt ist, geeignete Namenszeichen in zukünftigen Unicode-Versionen aufzunehmen. In der fünften Ausgabe können XML-Namen Zeichen in den Balinesen, Cham oder Phoenician-Skripten enthalten, unter anderem hinzugefügt Unicode seit Unicode 3.2. Fast jeder Unicode-Codepunkt kann in den Zeichendaten und Attributwerten eines XML 1.0 oder 1.1 Dokuments verwendet werden, auch wenn das dem Codepunkt entsprechende Zeichen nicht in der aktuellen Version von Unicode definiert ist. In Zeichendaten und Attributwerten erlaubt XML 1.1 die Verwendung von mehr Kontrollzeichen als XML 1.0, aber für Robustheit müssen die meisten in XML 1.1 eingeführten Kontrollzeichen als numerische Zeichenreferenzen ausgedrückt werden (und #x7F durch #x9F, die in XML 1.0 erlaubt waren, sind in XML 1.1 sogar als numerische Zeichenreferenzen angegeben). Unter den unterstützten Kontrollzeichen in XML 1.1 sind zwei Zeilenumbruchcodes, die als Whitespace behandelt werden müssen. Whitespace-Zeichen sind die einzigen Steuercodes, die direkt geschrieben werden können. XML 2.0 Es wurde ein XML 2.0 diskutiert, obwohl keine Organisation Pläne für die Arbeit an einem solchen Projekt angekündigt hat. XML-SW (SW for skunkworks), geschrieben von einem der ursprünglichen Entwickler von XML, enthält einige Vorschläge, wie ein XML 2.0 aussehen könnte: Beseitigung von DTDs aus Syntax, Integration von Namespaces, XML Base und XML Information Set in den Basisstandard. Binär XML Das World Wide Web Consortium verfügt außerdem über eine XML Binary Characterization Working Group, die vorläufige Untersuchungen zu Anwendungsfällen und Eigenschaften für eine binäre Kodierung von XML Information Set durchführt. Die Arbeitsgruppe ist nicht zur Herstellung offizieller Standards verpflichtet. Da XML per Definition textbasiert ist, verwenden ITU-T und ISO den Namen Fast Infoset für ihren eigenen binären Infoset, um Verwirrung zu vermeiden (siehe ITU-T Rec.X.891 und ISO/IEC 24824-1). Criticism XML und seine Erweiterungen wurden regelmäßig für Verbosität, Komplexität und Redundanz kritisiert. Das Mapping des Stammbaummodells von XML zu Typsystemen von Programmiersprachen oder Datenbanken kann schwierig sein, insbesondere wenn XML zum Austausch hoch strukturierter Daten zwischen Anwendungen verwendet wird, was nicht sein primäres Designziel war. XML-Datenbindungssysteme ermöglichen es jedoch, auf XML-Daten direkt von Objekten zuzugreifen, die eine Datenstruktur der Daten in der verwendeten Programmiersprache darstellen, die die Typsicherheit sicherstellt, anstatt mit dem DOM oder SAX Daten aus einer direkten Darstellung des XML selbst abzurufen. Dies wird dadurch erreicht, dass automatisch eine Zuordnung zwischen Elementen des XML-Schema XSD des Dokuments und Mitgliedern einer im Speicher darzustellenden Klasse erstellt wird. Andere Kritiken versuchen, den Anspruch zu widerlegen, dass XML eine selbst beschreibende Sprache ist (obwohl die XML-Spezifikation selbst keinen solchen Anspruch macht). JSON, YAML und S-Expressionen werden häufig als einfachere Alternativen vorgeschlagen (siehe Vergleich der Data Serialization-Formate), die sich auf die Darstellung hoch strukturierter Daten anstatt von Dokumenten konzentrieren, die sowohl hoch strukturierte als auch relativ unstrukturierte Inhalte enthalten können. W3C standardisierte XML-Schema-Spezifikationen bieten jedoch eine breitere Palette strukturierter XSD-Datentypen im Vergleich zu einfacheren Serialisierungsformaten und bieten Modularität und Wiederverwendung durch XML-Namespaces. Siehe auch Liste der XML-Markup-Sprachen Liste der XML-Schemas Erweiterbare Programmierung Vergleich der Layout-Engines (XML)Vergleich der Daten-Synchronisierungsformate Binary XML EBML WBXML XML Protocol Notes Referenzen Weiter lesen Anhang A der ISO 8879:1986 (SGML)Lawrence A. Cunningham (2005). "Sprache, Angebote und Standards: Die Zukunft der XML-Kontrakte". Washington University Law Review.SSRN 900616. Bosak, Jon; Bray, Tim (Mai 1999)."XML und das Second-Generation Web".Wissenschaftliche American.280 (5): 89.Bibcode:1999SciAm.280e..89B doi:10.1038/scientificamerican0599-89.Archiviert aus dem Original am 1. Oktober 2009. Kelly, Sean (6. Februar 2006). "Fehler mit XML machen". Entwickler.com. Erschienen am 26. Oktober 2010.St Laurent, Simon (12. Februar 2003). "Fünf Jahre später, XML."O'Reilly XML Blog. O'Reilly Media.Retrieved 26 October 2010. "W3C XML is Ten!". World Wide Web Consortium.12 Februar 2008.Retrieved 26 October 2010."Introduction to XML" (PDF). Kurs Slides. Pierre Geneves. Oktober 2012.Archiviert vom Original auf 2015-10-16.CS1 maint: bot: original URL status unknown (link) Externe Links W3C XML Homepage XML 1.0 Spezifikation Retrospektive zu Extended Reference Concrete Syntax von Rick Jelliffe XML, Java und der Zukunft des Web (1997) von Jon Bosak http://validator.w3.org/ Der offizielle [W3C] Markup Validation ServiceDie XML FAQ ursprünglich für den XML-SIG des W3C von Peter Flynn