Bei der objektorientierten Programmierung ist Vererbung der Mechanismus, ein Objekt oder eine Klasse auf einem anderen Objekt (prototypbasierte Vererbung) oder Klasse (Klassen-basierte Vererbung) zu legen, die eine ähnliche Umsetzung beibehalten. Auch als Ableitung neuer Klassen (Unterklassen) aus bestehenden wie Super- oder Basisklasse definiert und dann in eine Hierarchie von Klassen. In den meisten klassenbasierten objektorientierten Sprachen erwirbt ein durch Erbschaft geschaffenes Objekt, ein "Kind-Objekt", alle Eigenschaften und Verhaltensweisen des "Elent-Objekts", mit Ausnahme von: Konstrukteure, Destruktor, überlastete Bediener und Freundfunktionen der Basisklasse. Inheritance ermöglicht es Programmierern, Klassen zu erstellen, die auf bestehenden Klassen aufgebaut sind, eine neue Implementierung unter Beibehaltung der gleichen Verhaltensweisen (Erarbeitung einer Schnittstelle), um Code wiederzuverwenden und die ursprüngliche Software über öffentliche Klassen und Schnittstellen unabhängig zu erweitern. Die Zusammenhänge von Objekten oder Klassen durch Erbschaft führen zu einem gerichteten Diagramm. Erbschaft wurde 1969 für Simula erfunden und wird nun in vielen objektorientierten Programmiersprachen wie Java, C,+ PHP und Python eingesetzt. Eine geerbte Klasse wird als Unterklasse ihrer Elternklasse oder Superklasse bezeichnet. Der Begriff Vererbung wird lose für die klassen- und prototypenbasierte Programmierung verwendet, aber in engem Gebrauch ist der Begriff für die klassenbasierte Programmierung reserviert (ein Klassenvererbung von einem anderen), wobei die entsprechende Technik in der Prototyp-basierten Programmierung stattdessen als Delegation (ein Objekt Delegierter zum anderen) bezeichnet wird. Erbschaft sollte nicht mit Subtyping verwechselt werden. In einigen Sprachen stimmen Vererbung und Subtypisierung überein, während sie sich in anderen unterscheiden; im allgemeinen stellt Subtypisierung eine is-a-Beziehung fest, während Vererbung nur die Implementierung wiederverwendet und eine syntaktische Beziehung herstellt, nicht notwendigerweise eine semantische Beziehung (Vererbung sichert nicht die Verhaltenssubtypisierung). Um diese Konzepte zu unterscheiden, wird die Subtypisierung auch als Schnittstellenerbenheit bezeichnet, während die hier definierte Erbschaft als Implementierungserbenschaft oder Codeerbenschaft bezeichnet wird. Dennoch ist Vererbung ein häufig verwendeter Mechanismus zur Herstellung von Subtyp-Beziehungen. Die Erbschaft wird mit der Objektzusammensetzung kontrastiert, wobei ein Objekt ein weiteres Objekt enthält (oder Objekte einer Klasse Objekte einer anderen Klasse enthalten); siehe Zusammensetzung über Erbschaft. Die Zusammensetzung implementiert eine Übereinkunft, im Gegensatz zu der is-a-Beziehung der Subtypisierung. Arten Es gibt verschiedene Arten von Erbschaft, basierend auf Paradigmen und spezifische Sprache. Einzigartige Erbschaft, in der Unterklassen die Merkmale einer Superklasse erben. Eine Klasse erwirbt die Eigenschaften einer anderen Klasse. Mehrere Vererbungen, bei denen eine Klasse mehr als eine Superklasse haben kann und Eigenschaften aus allen Elternklassen erben kann." Mehrere Vererbung ... sollte weithin sehr schwierig sein, effizient zu implementieren. Zum Beispiel behauptete Brad Cox in einer Zusammenfassung von C+ in seinem Buch über Ziel C, dass das Hinzufügen mehrerer Vererbung zu C+ unmöglich sei. So schienen mehrere Vererbungen eher eine Herausforderung. Seit Ich hatte bereits 1982 mehrfache Erbschaft in Betracht gezogen und 1984 eine einfache und effiziente Umsetzungstechnik gefunden, konnte ich der Herausforderung nicht widerstehen. Ich vermute, dass dies der einzige Fall ist, in dem die Reihenfolge der Ereignisse beeinflusst wurde. " Mehrstufige Erbschaft, bei der eine Unterklasse von einer anderen Unterklasse geerbt wird. Es ist nicht ungewöhnlich, dass eine Klasse von einer anderen abgeleiteten Klasse abgeleitet wird, wie in der Figur "Multilevel Erbschaft" gezeigt. Die Klasse A dient als Basisklasse für die abgeleitete Klasse B, die wiederum als Basisklasse für die abgeleitete Klasse C dient. Die Klasse B ist als Zwischenbasisklasse bekannt, da sie eine Verbindung für die Erbschaft zwischen A und C bietet. Die Kette ABC ist als Erbpfad bekannt. Eine abgeleitete Klasse mit mehrstufiger Erbschaft wird wie folgt erklärt: Dieser Prozess kann auf jede Anzahl von Ebenen erweitert werden. Hierarchisches Erbe Hier dient eine Klasse als Superklasse (Basisklasse) für mehr als eine Subklasse. Beispielsweise kann eine Elternklasse A zwei Unterklassen B und C aufweisen. Die Elternklasse B und C ist A, aber B und C sind zwei getrennte Unterklassen. Hybride Erbschaft Hybride Erbschaft ist, wenn eine Mischung aus zwei oder mehreren der oben genannten Erbarten auftritt. Ein Beispiel hierfür ist, wenn Klasse A eine Unterklasse B aufweist, die zwei Unterklassen C und D aufweist. Dies ist eine Mischung aus sowohl mehrstufiger Erbschaft als auch hierarchischer Erbschaft. Unterklassen und Superklassen Unterklassen, abgeleitete Klassen, Erbklassen oder Kinderklassen sind modulare Ableitungsklassen, die eine oder mehrere Spracheinheiten aus einer oder mehreren anderen Klassen (so genannte Superklasse, Basisklassen oder Elternklassen) erben. Die Semantik des Klassenerbens variiert von Sprache zu Sprache, aber gewöhnlich erbt die Unterklasse automatisch die Instanzvariablen und Mitgliederfunktionen seiner Superklassen. Die allgemeine Form der Definition einer abgeleiteten Klasse ist: Der Kolon zeigt an, dass die Unterklasse von der Superklasse erbt. Die Sichtbarkeit ist optional und kann, falls vorhanden, entweder privat oder öffentlich sein. Die Standardsichtbarkeit ist privat. Die Sichtbarkeit gibt an, ob die Merkmale der Basisklasse privat oder öffentlich abgeleitet werden. Einige Sprachen unterstützen auch das Erbe anderer Konstrukte. Zum Beispiel werden in Eiffel Verträge, die die Spezifikation einer Klasse definieren, auch von Erben geerbt. Die Superclass schafft eine gemeinsame Schnittstelle und grundlegende Funktionalität, die spezialisierte Unterklassen erben, modifizieren und ergänzen können. Die von einer Unterklasse geerbte Software wird als wiederverwendet in der Unterklasse betrachtet. Ein Verweis auf einen Fall einer Klasse kann sich eigentlich auf eine ihrer Unterklassen beziehen. Die tatsächliche Klasse des zu referierenden Objekts ist nicht kompilierbar. Mit einer einheitlichen Schnittstelle werden die Elementfunktionen von Objekten verschiedener Klassen aufgerufen. Subclasses kann Superclass-Funktionen durch völlig neue Funktionen ersetzen, die dieselbe Methodensignatur teilen müssen. Nicht untergliederbare Klassen In einigen Sprachen kann eine Klasse als nicht untergliederbar erklärt werden, indem bestimmte Klassenmodifikatoren der Klassenerklärung hinzugefügt werden. Beispiele sind das endgültige Keyword in Java und C++11 onwards oder das versiegelte Keyword in C#.Such Modifier werden der Klassenerklärung vor dem Klassenwort und der Klassenkennung hinzugefügt. Solche nicht untergeordneten Klassen beschränken die Wiederverwendbarkeit, insbesondere wenn Entwickler nur Zugriff auf vorkompilierte Binäre und nicht Quellcode haben. Eine nicht untergeordnete Klasse hat keine Unterklassen, so kann es leicht zu kompilieren Zeit, dass Referenzen oder Zeiger auf Objekte dieser Klasse tatsächlich Referenzen Instanzen dieser Klasse und nicht Instanzen von Unterklassen (sie nicht existieren) oder Instanzen von Superklassen (upcasting a Reference Type verletzt das Typ System). Da die genaue Art des Objekts vor der Ausführung bekannt ist, kann anstelle einer Spätbindung (auch dynamischer Versand genannt) eine frühe Bindung (auch statischer Versand genannt) verwendet werden, die je nachdem, ob mehrere Vererbungen oder nur einzelne Vererbungen in der verwendeten Programmiersprache unterstützt werden. Nicht übertragbare Methoden Ebenso wie Klassen nicht untergliederbar sein können, können Methodendeklarationen Methodenmodifikatoren enthalten, die verhindern, dass das Verfahren übergeordnet wird (d.h. durch eine neue Funktion ersetzt mit dem gleichen Namen und Typsignatur in einer Unterklasse). Eine private Methode ist einfach nicht übersteuerbar, weil sie nicht durch andere Klassen als die Klasse zugänglich ist, von der sie Mitgliedsfunktion ist (das gilt jedoch nicht für C,+). Eine endgültige Methode in Java, eine versiegelte Methode in C# oder ein gefrorenes Feature in Eiffel kann nicht übergeordnet werden. Virtuelle Methoden Ist die Superclass-Methode eine virtuelle Methode, so werden Aufrufe der Superclass-Methode dynamisch versendet. Einige Sprachen erfordern, dass Methoden speziell als virtuelle (z.B. C,+) angegeben werden und in anderen sind alle Methoden virtuelle (z.B. Java). Eine Invokation einer nicht-virtuellen Methode wird immer statisch versandt (d.h. die Adresse des Funktionsaufrufs wird zur Kompilierungszeit bestimmt). Der statische Versand ist schneller als der dynamische Versand und ermöglicht Optimierungen wie Inline-Erweiterung. Sichtbarkeit geerbter Mitglieder Die folgende Tabelle zeigt, welche Variablen und Funktionen in Abhängigkeit von der Sichtbarkeit beim Ableiten der Klasse geerbt werden. Applikationen Die Erbschaft wird verwendet, um zwei oder mehr Klassen miteinander zu verbinden. Viele objektorientierte Programmiersprachen erlauben es einer Klasse oder einem Objekt, die Implementierung eines Aspekts - typischerweise eines Verhaltens - zu ersetzen, das er geerbt hat. Dieser Prozess wird als Überschreiben bezeichnet. Overriding führt eine Komplikation ein: Welche Version des Verhaltens verwendet eine Instanz der geerbten Klasse – diejenige, die Teil ihrer eigenen Klasse ist, oder die von der Eltern (Basis) Klasse? Die Antwort variiert zwischen Programmiersprachen, und einige Sprachen bieten die Möglichkeit, anzugeben, dass ein bestimmtes Verhalten nicht übergeordnet sein soll und sich wie von der Basisklasse definiert verhalten sollte. So kann beispielsweise in C,# die Basismethode oder -eigenschaft nur dann in einer Unterklasse übergeordnet werden, wenn sie mit dem virtuellen, abstrakten oder übergeordneten Modifikator gekennzeichnet ist, während in Programmiersprachen wie Java verschiedene Methoden aufgerufen werden können, um andere Methoden zu überschreiben. Eine Alternative zum Überschreiben verbirgt den geerbten Code. Code-Wiederverwendung Implementierung Erbe ist der Mechanismus, bei dem ein Unterklasse-Wiederverwendungscode in einer Basisklasse verwendet wird. Standardmäßig behält die Unterklasse alle Operationen der Basisklasse bei, aber die Unterklasse kann einige oder alle Operationen überschreiben, wodurch die Basisklasse-Implementierung durch eigene ersetzt wird. In dem folgenden Python Beispiel, subclasses SquareSumComputer und CubeSumComputer überschreiben die transform() Methode der Basisklasse SumComputer. Die Basisklasse umfasst Operationen, um die Summe der Quadrate zwischen zwei Ganzzahlen zu berechnen. Die Unterklasse nutzt alle Funktionalitäten der Basisklasse mit Ausnahme der Operation, die eine Anzahl in ihr Quadrat verwandelt, und ersetzt sie durch eine Operation, die eine Zahl in ihr Quadrat bzw. Würfel verwandelt. Die Unterklassen berechnen daher die Summe der Quadrate/Körper zwischen zwei Ganzzahlen. Unten ist ein Beispiel von Python. In den meisten Quartalen ist Klassenerbenheit für den alleinigen Zweck der Code-Wiederverwendung aus Gefallen. Die primäre Sorge ist, dass die Durchführungserinnerung keine Gewähr für die polymorphe Substituierbarkeit bietet – ein Beispiel der Wiederverwendungsklasse kann nicht notwendigerweise für einen Fall der ererbten Klasse ersetzt werden. Eine alternative Technik, explizite Delegation, erfordert mehr Programmieraufwand, vermeidet aber das Problem der Substitutionsfähigkeit. In C+ kann private Erbschaft als eine Form der Implementierung Erbschaft ohne Substituierbarkeit verwendet werden. Während die öffentliche Erbschaft eine Beziehung darstellt und die Delegation eine Beziehung darstellt, kann die private (und geschützte) Erbschaft als "in Bezug auf" Beziehung umgesetzt werden. Eine andere häufige Verwendung von Vererbung ist zu gewährleisten, dass Klassen eine bestimmte gemeinsame Schnittstelle halten; d.h. sie implementieren die gleichen Methoden. Die Elternklasse kann eine Kombination aus implementierten Operationen und Operationen sein, die in den Kinderklassen implementiert werden sollen. Oft gibt es keine Schnittstellenänderung zwischen Supertyp und Subtyp - das Kind implementiert das beschriebene Verhalten anstelle seiner Elternklasse. Erbschaft vs Subtyping Erbschaft ist ähnlich, aber von Subtyping unterscheidet. Die Subtypisierung ermöglicht es, einen bestimmten Typ für einen anderen Typ oder eine Abstraktion zu ersetzen und soll je nach Sprachunterstützung eine is-a-Beziehung zwischen dem Subtyp und einer vorhandenen Abstraktion herstellen. Die Beziehung kann explizit durch Vererbung in Sprachen ausgedrückt werden, die Vererbung als Subtypisierungsmechanismus unterstützen. Beispielsweise stellt der folgende C+-Code eine explizite Vererbungsbeziehung zwischen den Klassen B und A fest, wobei B sowohl eine Unterklasse als auch ein Subtyp von A ist und als A verwendet werden kann, wo immer a B angegeben ist (über eine Referenz, einen Zeiger oder das Objekt selbst). In Programmiersprachen, die die Erbschaft nicht als Subtypisierungsmechanismus unterstützen, ist die Beziehung zwischen einer Basisklasse und einer abgeleiteten Klasse nur eine Beziehung zwischen Implementierungen (ein Mechanismus zur Code-Wiederverwendung), verglichen mit einer Beziehung zwischen Typen. Vererbung, auch in Programmiersprachen, die Vererbung als Subtypisierungsmechanismus unterstützen, erfordert nicht unbedingt eine verhaltensbezogene Subtypisierung. Es ist durchaus möglich, eine Klasse abzuleiten, deren Objekt sich bei Verwendung in einem Kontext, in dem die Elternklasse erwartet wird, falsch verhalten wird; siehe das Liskov Substitutionsprinzip. (Compare connotation/denotation.) In einigen OOP-Sprachen fallen die Begriffe der Code-Wiederverwendung und Subtypisierung zusammen, weil der einzige Weg, um einen Subtyp zu erklären ist, eine neue Klasse zu definieren, die die Umsetzung einer anderen erbt. Die Verwendung von Vererbung bei der Gestaltung eines Programms führt zu gewissen Einschränkungen. Betrachten Sie beispielsweise eine Klasse Person, die den Namen, das Geburtsdatum, die Adresse und die Telefonnummer einer Person enthält. Wir können eine Unterklasse von Person namens Student definieren, die den Grad-Punkt-Durchschnitt und Klassen eingenommen enthält, und eine andere Unterklasse von Person namens Mitarbeiter, die den Job-Titel, Arbeitgeber und Gehalt enthält. Bei der Definition dieser Erbhierarchie haben wir bereits bestimmte Einschränkungen definiert, die nicht alle wünschenswert sind: Einheitlichkeit Mit einem einzigen Erbe kann eine Unterklasse nur von einer Superklasse erben. Fortsetzung des oben genannten Beispiels kann die Person entweder Student oder Mitarbeiter sein, aber nicht beide. Mit Mehrfacher Erbschaft löst dieses Problem teilweise, da man dann eine StudentEmployee-Klasse definieren kann, die sowohl von Student und Mitarbeiter erbt. In den meisten Implementierungen kann sie jedoch nur einmal von jeder Superklasse geerbt werden, und unterstützt daher nicht Fälle, in denen ein Student zwei Jobs hat oder zwei Institutionen besucht. Das im Eiffel zur Verfügung stehende Erbschaftsmodell ermöglicht dies durch Unterstützung wiederholter Erbschaft. Statische Die Erbhierarchie eines Objekts wird zum Zeitpunkt der Auswahl des Objekttyps fixiert und ändert sich nicht mit der Zeit. Beispielsweise erlaubt das Erbgut-Diagramm nicht, dass ein Student-Objekt ein Mitarbeiter-Objekt wird, während der Zustand seiner Person Superclass.( Diese Art von Verhalten kann jedoch mit dem Dekoratormuster erreicht werden.) Einige haben die Erbschaft kritisiert, indem sie behaupten, dass sie Entwickler in ihre ursprünglichen Designstandards einsperrt. Sichtbarkeit Wenn Client-Code Zugriff auf ein Objekt hat, hat es in der Regel Zugriff auf alle Superclass-Daten des Objekts. Auch wenn die Superklasse nicht öffentlich erklärt worden ist, kann der Kunde das Objekt immer noch seinem Superclass-Typ zuwerfen. Zum Beispiel gibt es keine Möglichkeit, eine Funktion als Zeiger für den Grade Punkt Durchschnitt und Transkript eines Schülers zu geben, ohne diese Funktion auch Zugriff auf alle in der Person Superclass des Schülers gespeicherten personenbezogenen Daten zu geben. Viele moderne Sprachen, darunter C+ und Java, bieten einen geschützten Access Modifier, der es Unterklassen ermöglicht, auf die Daten zuzugreifen, ohne dass ein Code außerhalb der Kette der Erbschaft auf sie zugreifen kann. Das Komposit-Reuse-Prinzip ist eine Alternative zur Erbschaft. Diese Technik unterstützt Polymorphismus und Code-Wiederverwendung, indem sie Verhaltensweisen von der primären Klassenhierarchie trennt und bestimmte Verhaltensklassen, wie sie in jeder Business-Domain-Klasse erforderlich sind, einschließt. Dieser Ansatz vermeidet die statische Natur einer Klassenhierarchie, indem er Verhaltensänderungen zu Laufzeit erlaubt und eine Klasse erlaubt, Verhaltens-Buffet-Stil zu implementieren, anstatt auf die Verhaltensweisen seiner Vorfahrenklassen beschränkt zu sein. Die Umsetzungsvererbung ist in den Programmierern und Theoretikern der objektorientierten Programmierung seit mindestens den 1990er Jahren umstritten. Unter ihnen sind die Autoren von Design Patterns, die anstelle von Interface Erbschaft befürworten, und bevorzugen Komposition über Erbschaft. Beispielsweise wurde das Dekoratormuster (wie oben erwähnt) vorgeschlagen, die statische Natur der Erbschaft zwischen Klassen zu überwinden. Als eine fundamentalere Lösung für das gleiche Problem führt die rollenorientierte Programmierung eine ausgeprägte Beziehung ein, gespielt, die Eigenschaften von Erbschaft und Zusammensetzung zu einem neuen Konzept kombiniert. Nach Allen Holub ist das Hauptproblem bei der Implementierungserbung, dass es unnötige Kopplung in Form des "fragilen Basisklasse-Problems" einführt: Änderungen an der Basisklasse-Implementierung können versehentliche Verhaltensänderungen in Unterklassen verursachen. Die Verwendung von Schnittstellen vermeidet dieses Problem, weil keine Implementierung geteilt wird, nur die API. Eine andere Möglichkeit, dies zu sagen, ist, dass "Erinnerung bricht Verkapselung". Das Problem besteht klar in offenen objektorientierten Systemen wie Frameworks, bei denen der Client-Code von systemversorgten Klassen geerbt und dann in seinen Algorithmen für die Klassen des Systems ersetzt wird. Reportedly, Java Erfinder James Gosling hat gegen die Umsetzung Vererbung gesprochen, indem er feststellt, dass er es nicht einschließen würde, wenn er Java neu gestalten würde. Sprachdesigns, die die Erbschaft aus Subtypisierung (Interface-Erblichkeit) entkoppeln, erschienen bereits 1990; ein modernes Beispiel hierfür ist die Go-Programmiersprache. Komplexe Erbschaft oder Erbschaft, die in einem unzureichend reifen Design verwendet wird, kann zu dem Yo-yo-Problem führen. Als die Erbschaft in einem System in den späten 1990er Jahren als primärer Ansatz für Strukturcode verwendet wurde, begannen Entwickler natürlich, Code in mehrere Schichten der Erbschaft zu brechen, da die Systemfunktionalität wuchs. Wenn ein Entwicklungsteam mehrere Vererbungsschichten mit dem einzigen Verantwortungsprinzip kombinierte, erstellte es viele super dünne Schichten von Code, viele, die nur 1 oder 2 Zeilen Code in jeder Schicht haben würden. Zu viele Schichten machen Debugging eine wichtige Herausforderung, da es schwierig wird, zu bestimmen, welche Schicht debugged werden muss. Ein weiteres Problem mit Erbschaft ist, dass Unterklassen im Code definiert werden müssen, was bedeutet, dass Programmnutzer keine neuen Unterklassen zur Laufzeit hinzufügen können. Andere Design-Muster (wie Entity–Komponente–System) ermöglichen es Programmnutzern, Änderungen eines Unternehmens zu Laufzeiten zu definieren. Siehe auch Archetype Muster Circle-ellipse Problem Defeasible Argumenting –Reasoning, das rational zwingend ist, obwohl nicht deduktiv gültig Interface (computing) – Konzept der Informatik; Punkt der Interaktion zwischen zwei Dinge Methode übergeordnet Mixin Polymorphism (Computer Science)Protocol Role-orientierte Programmierung – Programmierung Paradigma basierend auf konzeptionellem Verständnis von Objekten The Third Manifesto Trait (Computer-Programmierung)Virtual inheritance Notes Referenzen Weiter lesen Object-Oriented Software Construction, Second Edition, von Bertrand Meyer, Prentice Hall, 1997, ISBN 0-13-629155-4, Kapitel 24: Verwendung von Erbe Well.Implementation Inheritance is Evil