Sicher durch Design, in der Software-Engineering, bedeutet, dass Software-Produkte und -fähigkeiten konzipiert wurden, um fundamental sicher zu sein. Alternate Sicherheitsstrategien, Taktiken und Muster werden zu Beginn eines Software-Designs betrachtet, und die besten werden von der Architektur ausgewählt und durchgesetzt, und sie werden als Leitprinzipien für Entwickler verwendet. Es wird auch dazu ermutigt, strategische Designmuster zu verwenden, die günstige Auswirkungen auf die Sicherheit haben, obwohl diese Designmuster ursprünglich nicht mit Sicherheit im Kopf entwickelt wurden. Secure by Design wird zunehmend zum Mainstream-Entwicklungsansatz, um Sicherheit und Privatsphäre von Softwaresystemen zu gewährleisten. Bei diesem Ansatz wird die Sicherheit in jedem Layer betrachtet und in das System eingebaut und beginnt mit einem robusten Architekturdesign. Sicherheitsarchitektur-Entscheidungen basieren auf bekannten Sicherheitsstrategien, Taktiken und Mustern, die als wiederverwendbare Techniken zur Erreichung bestimmter Qualitätsbelange definiert sind. Sicherheitstaktiken/Pattern bieten Lösungen für die Durchsetzung der erforderlichen Authentifizierungs-, Autorisierungs-, Vertraulichkeits-, Datenintegrität, Privatsphäre, Rechenschaftspflicht, Verfügbarkeit, Sicherheit und Nicht-Repudiation Anforderungen, auch wenn das System unter Angriff ist. Um die Sicherheit eines Softwaresystems zu gewährleisten, ist es nicht nur wichtig, eine robuste Sicherheitsarchitektur zu entwickeln, sondern es ist auch notwendig, aktualisierte Sicherheitsstrategien, Taktiken und Muster für die Softwareentwicklung zu ordnen, um die Sicherheit zu erhalten. Erwarten Sie Angriffe Malicious Angriffe auf Software sollte angenommen werden, um Auswirkungen zu minimieren. Sicherheitslücken werden erwartet, zusammen mit ungültiger Benutzereingabe. Nahezu verwandt ist die Praxis, gute Software-Design, wie z.B. Domänen-getriebenes Design oder Cloud-Native, zu verwenden, um die Sicherheit zu erhöhen, indem das Risiko von Verwundbarkeits-Öffnungsfehlern verringert wird – auch wenn die verwendeten Design-Prinzipien nicht ursprünglich für Sicherheitszwecke konzipiert wurden. Vermeiden Sie die Sicherheit durch Ungenauigkeit In der Regel sind Designs, die gut funktionieren, nicht auf geheim zu sein. Oft reduziert die Geheimhaltung die Zahl der Angreifer, indem sie eine Teilmenge der Bedrohungspopulation demotiviert. Die Logik ist, dass, wenn es eine Erhöhung der Komplexität für den Angreifer gibt, der erhöhte Angreiferaufwand, um das Ziel zu kompromittieren, sie entmutigen wird. Während diese Technik reduzierte Eigenrisiken impliziert, wird ein nahezu unendliches Maß an Bedrohungsakteure und -techniken, die im Laufe der Zeit angewandt werden, dazu führen, dass die meisten Geheimhaltungsmethoden scheitern. Zwar nicht zwingend, bedeutet die richtige Sicherheit in der Regel, dass jeder das Design kennen und verstehen darf, weil es sicher ist. Dies hat den Vorteil, dass viele Menschen den Computercode betrachten, was die Chancen verbessert, dass Fehler früher gefunden werden (siehe Linus Gesetz). Nachteilig ist, dass Angreifer auch den Code erhalten können, was es ihnen erleichtert, Schwachstellen auszunutzen. Es wird jedoch allgemein angenommen, dass der Vorteil des offenen Computercodes den Nachteil überwiegt. Fewest Privilegien Auch ist es wichtig, dass alles mit den wenigen Privilegien möglich ist (siehe das Prinzip der Mindestberechtigung). Beispielsweise kann ein Webserver, der als administrativer Benutzer (root oder admin) läuft, das Privileg haben, Dateien und Benutzer zu entfernen. Ein Fehler in einem solchen Programm könnte daher das gesamte System in Gefahr bringen, während ein Webserver, der innerhalb einer isolierten Umgebung läuft, und nur die Privilegien für benötigte Netzwerk- und Dateisystemfunktionen hat, das System nicht gefährden kann, das es läuft, es sei denn, die Sicherheit um sich herum ist auch fehlerhaft. Methoden Secure Design sollte an allen Stellen des Entwicklungslebenszyklus (je nachdem, welche Entwicklungsmethodik gewählt wird) eine Überlegung sein. Einige vorgefertigt Secure By Design-Entwicklungsmethoden existieren (z.B. Microsoft Security Development Lifecycle.) Microsoft Security Development Lifecycle Microsoft veröffentlichte Methodik und Anleitung auf Basis des klassischen Spiralmodells. Standards und Legislation Standards und Legislation existieren, um sicheres Design zu unterstützen, indem die Definition von Secure kontrolliert wird und konkrete Schritte zur Prüfung und Integration sicherer Systeme bereit gestellt werden. Einige Beispiele von Standards, die sich auf Secure By Design-Prinzipien abdecken oder berühren: ETSI TS 103 645, die zum Teil in der britischen Regierung enthalten ist "Proposals for Regulation Consumer Smart Product Cyber Security" ISO/IEC 27000-Serie umfasst viele Aspekte des sicheren Designs. Server/Client Architekturen In Server-Client-Architekturen kann das Programm auf der anderen Seite kein autorisierter Client sein und der Server des Clients darf kein autorisierter Server sein. Selbst wenn sie es sind, könnte ein Man-in-the-Middle-Angriff die Kommunikation beeinträchtigen. Oft ist der einfachste Weg, um die Sicherheit eines Client / Server-Systems zu brechen, nicht zu den Sicherheitsmechanismen zu gehen, sondern um sie herum zu gehen. Ein Mann im mittleren Angriff ist ein einfaches Beispiel dafür, weil Sie es verwenden können, um Details zu sammeln, um einen Benutzer zu verkörpern. Aus diesem Grund ist es wichtig, Verschlüsselung, Hashing und andere Sicherheitsmechanismen in Ihrem Design zu berücksichtigen, um sicherzustellen, dass Informationen, die von einem potenziellen Angreifer gesammelt werden, keinen Zugriff erlauben. Eine weitere wichtige Funktion für das Client-Server-Sicherheitsdesign ist die gute Codierung Praktiken. Beispielsweise kann nach einer bekannten Software-Design-Struktur, wie Client und Broker, bei der Gestaltung einer gut gebauten Struktur mit einer soliden Grundlage helfen. Darüber hinaus ist es, wenn die Software künftig geändert werden soll, noch wichtiger, dass sie einer logischen Grundlage der Trennung zwischen Client und Server folgt. Denn wenn ein Programmierer kommt und die Dynamik des Programms nicht klar verstehen kann, können sie am Ende etwas hinzufügen oder ändern, das einen Sicherheitsfehler hinzufügen kann. Auch bei bestem Design ist dies immer eine Möglichkeit, aber je besser die Standardisierung des Designs ist, desto geringer ist dies. Siehe auch Computer-Sicherheit Cyber-Sicherheitsstandards Härten mehrerer unabhängiger Sicherheitsstufen Sichere durch Sicherheit der Datensicherheit Software-Sicherheitsüberwachung Referenzen Externe Links Sichere Programmierung für Linux und Unix HOWTO Secure UNIX Programmierung FAQ Top 10 Secure Coding Practices Sicherheit durch Design-Prinzips