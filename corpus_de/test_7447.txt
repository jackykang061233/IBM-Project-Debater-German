In der Kryptographie ist scrypt (ausgesprochen "ess crypt") eine passwortbasierte Schlüsselableitungsfunktion, die von Colin Percival erstellt wurde, ursprünglich für den Tarsnap Online-Backup-Service. Der Algorithmus wurde speziell entwickelt, um es kostspielig zu machen, um großformatige benutzerdefinierte Hardware-Angriffe durchzuführen, indem große Mengen. 2016 wurde der Scrypt-Algorithmus von IETF als RFC 7914 veröffentlicht. Eine vereinfachte Version von Scrypt wird als Beleg-of-work-Schema von einer Reihe von Kryptowährungen verwendet, zuerst von einem anonymen Programmierer ArtForz in Tenebrix umgesetzt und anschließend Fairbrix und Litecoin bald danach. Einführung Eine passwortbasierte Schlüsselableitungsfunktion (Passwortbasiertes KDF) ist in der Regel rechnerisch intensiv ausgelegt, so dass es relativ lange Zeit braucht, um zu berechnen (Schaubild in der Größenordnung von mehreren hundert Millisekunden). Legitimierte Benutzer müssen nur einmal pro Betrieb (z.B. Authentifizierung) die Funktion ausführen, so dass die benötigte Zeit vernachlässigbar ist. Allerdings würde ein brutaler Angriff wahrscheinlich die Operation Milliarden von Zeiten durchführen müssen, zu welchem Zeitpunkt die Anforderungen signifikant werden und idealerweise verbieten. Bisherige passwortbasierte KDFs (wie die beliebte PBKDF2 von RSA Laboratories) haben relativ geringe Ressourcenanforderungen, was bedeutet, dass sie keine aufwendige Hardware oder sehr viel Speicher zur Ausführung benötigen. Sie sind daher einfach und günstig in Hardware implementiert (z.B. auf einem ASIC oder sogar einem FPGA). Dies ermöglicht es einem Angreifer mit ausreichenden Ressourcen, einen großflächigen Parallelangriff zu starten, indem er Hunderte oder sogar Tausende von Implementierungen des Algorithmus in Hardware baut und jede Suche eine andere Teilmenge des Schlüsselraums hat. Dies teilt die Zeit, die erforderlich ist, um einen brutalen Angriff durch die Anzahl der verfügbaren Implementierungen abzuschließen, sehr wahrscheinlich, dass es auf einen angemessenen Zeitrahmen. Die Scrypt-Funktion ist dazu ausgelegt, solche Versuche durch Erhöhung der Ressourcenanforderungen des Algorithmus zu behindern. Konkret ist der Algorithmus dazu ausgelegt, eine große Menge Speicher im Vergleich zu anderen passwortbasierten KDFs zu verwenden, wodurch die Größe und die Kosten einer Hardware-Implementierung viel teurer sind und somit die Menge an Parallelismus ein Angreifer verwenden kann, für eine bestimmte Menge an finanziellen Ressourcen. Überblick Die großen Speicheranforderungen an Scrypt stammen aus einem großen Vektor von Pseudorandom-Bit-Strings, die als Teil des Algorithmus erzeugt werden. Sobald der Vektor erzeugt wird, werden die Elemente davon in einer pseudo-zufälligen Reihenfolge aufgerufen und zur Erzeugung des abgeleiteten Schlüssels zusammengefasst. Eine einfache Implementierung müsste den gesamten Vektor in RAM behalten, so dass er bei Bedarf zugegriffen werden kann. Da die Elemente des Vektors algorithmisch erzeugt werden, könnte jedes Element bei Bedarf auf der Fliege erzeugt werden, nur ein Element im Speicher zu einem Zeitpunkt speichern und damit die Speicheranforderungen deutlich schneiden. Die Erzeugung jedes Elements soll jedoch rechnerisch aufwendig sein, und die Elemente werden während der Ausführung der Funktion vielfach zugegriffen. So gibt es einen erheblichen Abtrieb in der Geschwindigkeit, um die großen Speicheranforderungen loszuwerden. Diese Art von Zeit-Memory-Trade-off gibt es oft in Computeralgorithmen: Geschwindigkeit kann zu den Kosten der Verwendung von mehr Speicher erhöht werden, oder Speicheranforderungen verringert zu den Kosten für die Durchführung von mehr Operationen und länger. Die Idee hinter Scrypt ist, diesen Trade-off bewusst in beide Richtungen teuer zu machen. So könnte ein Angreifer eine Implementierung verwenden, die nicht viele Ressourcen benötigt (und kann daher massiv parallelisiert mit begrenztem Aufwand), sondern läuft sehr langsam, oder eine Implementierung verwenden, die schneller läuft, aber sehr große Speicheranforderungen hat und daher teurer ist, parallel zu arbeiten. Algorithm Funktion scrypt Inputs: Dieser Algorithmus enthält die folgenden Parameter: Passphrase: Bytes string von Zeichen zu hashed Salt: Bytes string von Zufallszeichen, die die Hash zum Schutz gegen Rainbow-Tischangriffe CostFactor (N): Integer CPU/Memory-Kostenparameter - Muss eine Leistung von 2 (z.B. 1024) BlockSizeFactor (r): Integer blockiert Parameter, die Feineinstellungen sequentielle Speicherlese Größe und Leistung(8) 1) * hLen.) hLen: Integer Die Länge in Oktetten der Hashfunktion (32 für SHA256.) MFlen: Integer Die Länge in Oktetten der Ausgabe der Mischfunktion (SMix unten). Definiert als r * 128 in RFC7914. Ausgang: DerivedKey: Bytes-Array von Bytes, DesiredKeyLen lange Schritt 1. Erzeugen Sie teuren SalzblockGröße ← 128*BlockSizeFactor // Länge (in Bytes) des SMix-Mischfunktionsausgangs (z.B. 128*8 = 1024 Bytes) Verwenden Sie PBKDF2, um initial 128*BlockSizeFactor*p Bytes von Daten zu erzeugen (z.B. 128*8*3 = 3072 Bytes) Behandeln Sie das Ergebnis als eine Reihe von p-Elementen, wobei jeder Eintrag Bytes blockieren (z.B. 3 Elemente, jeweils 1024 Bytes) [B0...Bp-1] ← PBKDF2HMAC-SHA256(Passphrase, Salz, 1, BlockSize*ParallelizationFactor) Mischen Sie jeden Block in B Costfactor-Zeiten mit ROMix-Funktion (jeder Block kann parallel gemischt werden) für i ← 0 zu p-1 do Bi ROMix(Bi, CostFactor) Alle Elemente von B ist unser neues teures Salz teuerSalt ← B0 ERTB1 ERTB2 ERTB-1 // wo ERT ist Concatenation Schritt 2. Verwenden Sie PBKDF2, um die gewünschte Anzahl von Bytes zu erzeugen, aber mit dem teuren Salz, das wir gerade generierte Rückkehr PBKDF2HMAC-SHA256(Passphrase, costSalt, 1, DesiredKeyLen;) Ist PBKDF2(P, S, c, dkLen) Notation in RFC 2898 definiert, wobei c eine Iterationszahl ist. Diese Notation wird von RFC 7914 zur Angabe einer Verwendung von PBKDF2 mit c = 1. Funktion ROMix(Block, Iterationen) Iterationskopien von X X ← Block für i ← 0 zu Iterations-1 do Vi ← X X X ← BlockMix(X) for i ← 0 to Iterations-1 do j ← Integerify(X)mod Iterations X Da Iterationen gleich 2 der Macht von N sind nur die ersten Ceiling(N / 8) Bytes unter den letzten 64 Bytes von X, interpretiert als wenig-endian ganze Zahl A2, tatsächlich benötigt, um Integerify(X) mod Iterationen = A1 mod Iterationen = A2 mod Iterationen zu berechnen. Funktion BlockMix(B): Der Block B ist r 128-Byte-Cracks (was 2r 64-Byte-Cracks entspricht) r ← Länge(B) / 128; Treat B als Array von 2r 64-Byte-Cracks [B0...B2r-1] ← B X B2r-1 für i ← 0 bis 2r-1 do X. Yi ← X return ← Y0 ERTY2 ERT... ERTY2r-2 ERTY1 ERTY3 ERTY2r-1Where Salsa20/8 ist die 8-runde Version von Salsa20. Kryptowährung verwendet Scrypt wird in vielen Kryptowährungen als Beweis-of-work-Algorithmus verwendet. Es wurde erstmals für Tenebrix (im September 2011 veröffentlicht) umgesetzt und diente als Basis für Litecoin und Dogecoin, die auch seinen Kryptaalgorithmus angenommen. Die Minierung von Kryptowährungen, die Scrypt verwenden, wird oft auf Grafik-Verarbeitungseinheiten (GPUs) durchgeführt, da GPUs tendenziell deutlich mehr Verarbeitungsleistung (für einige Algorithmen) im Vergleich zur CPU haben. Dies führte zu Verknappungen von High-End-GPUs aufgrund des steigenden Preises dieser Währungen in den Monaten November und Dezember 2013. Ab Mai 2014 ist spezialisierte ASIC Bergbau-Hardware für kryptbasierte Kryptowährungen verfügbar. Siehe auch Schlüsselableitungsfunktion Argon2, Gewinner des Password Hashing Competition Krypt, Passwortspeicherung und Verifikationsschema PBKDF2, eine weit verbreitete Standard passwortbasierte Schlüsselableitungsfunktion bcrypt, Passwort Hashing Funktion mit Blowfish Space-time tradeoff Referenzen Externe Links Die Scrypt-Seite auf der Tarsnap-Website. Das originale Scrypt-Papier. Scrypt auf GitHub