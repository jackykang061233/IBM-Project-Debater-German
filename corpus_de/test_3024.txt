In der Berechnungstheorie wird ein System von Daten-Manipulationsregeln (z.B. ein Computer-Anweisungssatz, eine Programmiersprache oder ein Zellenautomat) als Turing-komplete oder rechnerisch universal bezeichnet, wenn es zur Simulation einer Turing-Maschine verwendet werden kann. Dies bedeutet, dass dieses System in der Lage ist, andere Datensätze zu erkennen oder zu entscheiden. Die Turing-Vervollständigung wird als Weg verwendet, um die Kraft eines solchen Daten-Manipulationsregelsatzes auszudrücken. Fast alle Programmiersprachen sind heute Turing-komplete. Das Konzept ist nach dem englischen Mathematiker und Informatiker Alan Turing benannt. Ein damit verbundenes Konzept ist das von Turing equivalence – zwei Computer P und Q werden als gleichwertig bezeichnet, wenn P Q simulieren und Q P simulieren kann. Die Church-Turing-Thesis konjectures, dass jede Funktion, deren Werte durch einen Algorithmus berechnet werden können, kann von einer Turing-Maschine berechnet werden, und daher, dass, wenn ein realer Computer eine Turing-Maschine simulieren kann, ist es Turing äquivalent zu einer Turing-Maschine. Eine universelle Turing-Maschine kann verwendet werden, um jede Turing-Maschine zu simulieren und durch Erweiterung der rechnerischen Aspekte eines möglichen realen Computers. Um zu zeigen, dass etwas Turing-komplete ist, ist es genug zu zeigen, dass es verwendet werden kann, um einige Turing-komplete System zu simulieren. Eine zwingende Sprache ist beispielsweise Turing-komplete, wenn sie eine bedingte Verzweigung (z.B. wenn und goto-Anweisungen, oder eine "Bremse, wenn Null"-Anweisung; siehe Ein-Anweisungs-Set-Computer) und die Möglichkeit hat, eine beliebige Speichermenge zu ändern (z.B. die Fähigkeit, eine beliebige Anzahl von Datenelementen aufrechtzuerhalten). Natürlich kann kein physisches System unendliche Speicher haben; aber wenn die Begrenzung des endlichen Speichers ignoriert wird, sind die meisten Programmiersprachen ansonsten Turing-vollständig. Nicht-mathematische Nutzung Unter den Begriffen Turing-complete und Turing-equivalent wird in der Kolloquial-Nutzung verstanden, dass jeder universelle Computer oder Computersprache in der Realität die rechnerischen Aspekte eines anderen universellen Computers oder einer Computersprache annähernd simulieren kann. Reale Computer, die bisher aufgebaut sind, können funktionell wie eine Einband-Turniermaschine analysiert werden (das Band entspricht ihrem Speicher); so kann die zugehörige Mathematik durch Abstraktion ihrer Operation weit genug gelten. Allerdings haben reale Computer begrenzte physische Ressourcen, so sind sie nur linear gebunden automaton komplett. Ein universeller Computer wird dagegen als Gerät mit einem Turing-kompleten Befehlssatz, unendlichem Speicher und unendlicher verfügbarer Zeit definiert. Formale Definitionen In der Rechenschaftstheorie werden mehrere eng verwandte Begriffe verwendet, um die Rechenleistung eines Rechensystems (wie eine abstrakte Maschine oder Programmiersprache) zu beschreiben. Turing Vollständigkeit Ein Rechensystem, das jede Turing-komputierbare Funktion berechnen kann, heißt Turing-complete (oder Turing-powerful). Alternativ kann ein solches System eine universelle Turing-Maschine simulieren. Turing equivalence Ein Turing-complete-System wird als Turing-equivalent bezeichnet, wenn jede Funktion, die er berechnen kann, auch Turing-computable ist, d.h. es berechnet genau die gleiche Funktionsklasse wie Turing-Maschinen. Alternativ ist ein Turing-Äquivalent-System, das eine universelle Turing-Maschine simulieren und simulieren kann. ( Alle bekannten physikalisch-implementierbaren Turing-complete Systeme sind Turing-equivalent, die Unterstützung der Kirche-Turing-Thesis.)(Computational universality. Ein System wird universell in Bezug auf eine Klasse von Systemen genannt, wenn es jede Funktion berechnen kann, die durch Systeme in dieser Klasse berechnet werden kann (oder jedes dieser Systeme simulieren kann). Typischerweise wird der Begriff Universalität in Bezug auf eine Turing-complete Klasse von Systemen zaghaft verwendet. Der Begriff "schwach universell" wird manchmal verwendet, um ein System (z.B. ein zelluläres Automaten) zu unterscheiden, dessen Universalität nur durch eine Änderung der Standarddefinition der Turing-Maschine erreicht wird, um Eingangsströme mit unendlich vielen 1s einzuschließen. Geschichte Turing Vollständigkeit ist von Bedeutung, dass jedes reale Design für ein Rechengerät durch eine universelle Turing-Maschine simuliert werden kann. Die Church-Turing-Thesis sagt, dass dies ein Gesetz der Mathematik – dass eine universelle Turing-Maschine im Prinzip jede Berechnung durchführen kann, dass jeder andere programmierbare Computer kann. Dies sagt nichts über den Aufwand, der benötigt wird, um das Programm zu schreiben, oder die Zeit, die es für die Maschine nehmen kann, um die Berechnung durchzuführen, oder irgendwelche Fähigkeiten, die die Maschine besitzen kann, die nichts mit Berechnung zu tun haben. Charles Babbages Analyse-Engine (1830s) wäre die erste Turing-complete Maschine gewesen, wenn es zu der Zeit gebaut worden war, die es entworfen wurde. Babbage schätzte, dass die Maschine in der Lage war, große Kosten der Berechnung, einschließlich primitive logische Argumentation, aber er wusste nicht, dass keine andere Maschine besser tun konnte. Von den 1830ern bis in die 1940er Jahre wurden mechanische Rechenmaschinen wie Addierer und Multiplikatoren gebaut und verbessert, konnten aber keinen bedingten Zweig ausführen und waren daher nicht Turing-komplete. Im späten 19. Jahrhundert formulierte Leopold Kronecker Begriffe der Rechenbarkeit und definierte primitive rekursive Funktionen. Diese Funktionen können durch rote Berechnung berechnet werden, aber sie reichen nicht aus, um einen universellen Computer zu machen, weil die Anweisungen, die sie berechnen, keine unendliche Schleife zulassen. Im frühen 20. Jahrhundert führte David Hilbert ein Programm zur Axiomatisierung aller Mathematik mit präzisen Axiomen und präzise logische Regeln der Reduktion, die von einer Maschine durchgeführt werden könnte. Bald wurde klar, dass eine kleine Reihe von Abzugsregeln ausreichen, um die Konsequenzen jeder Reihe von Axiomen zu erzeugen. Diese Regeln wurden von Kurt Gödel im Jahre 1930 bewiesen, um genug zu sein, um jedes Theorem zu produzieren. Der eigentliche Begriff der Berechnung wurde bald danach isoliert, beginnend mit Gödels Unvollkommenheitstheorem. Dieses Theorem zeigte, dass Axiom-Systeme begrenzt waren, wenn sie über die Berechnung, die ihre Theorems verleitet. Kirche und Turing zeigten unabhängig, dass Hilberts Entscheidungsproblem (Entscheidungsproblem) unlösbar war und somit den Rechenkern des Unvollkommenheitstheorems identifizierte. Diese Arbeit, zusammen mit Gödels Arbeit an allgemeinen rekursiven Funktionen, stellte fest, dass es Sets von einfachen Anweisungen gibt, die, wenn zusammengestellt, in der Lage sind, jede Berechnung zu erstellen. Die Arbeit von Gödel zeigte, dass der Begriff der Berechnung im Wesentlichen einzigartig ist. 1941 beendete Konrad Zuse den Z3-Computer. Zuse war damals nicht mit Turings Arbeit an der Rechenbarkeit vertraut. Insbesondere fehlte das Z3 an dedizierten Einrichtungen für einen bedingten Sprung, wodurch es von Turing komplett ausgeschlossen wird. Im Jahr 1998 wurde von Rojas jedoch gezeigt, dass das Z3 bedingte Sprünge und damit Turing komplettieren kann, indem einige seiner Merkmale unbeabsichtigt genutzt werden. Computability Theorie Computability-Theorie verwendet Modelle der Berechnung, um Probleme zu analysieren und zu bestimmen, ob sie rechnerisch sind und unter welchen Umständen. Das erste Ergebnis der Berechnungstheorie ist, dass es Probleme gibt, für die es unmöglich ist, vorherzusagen, was ein (Turing-complete) System über eine willkürlich lange Zeit tun wird. Das klassische Beispiel ist das Stopping-Problem: Erstellen Sie einen Algorithmus, der als Eingabe eines Programms in einigen Turing-komplete Sprache und einige Daten, die zu diesem Programm gespeist werden, und bestimmt, ob das Programm, das auf der Eingabe, wird schließlich stoppen oder wird für immer weiter. Es ist trivial, einen Algorithmus zu erstellen, der dies für einige Eingaben tun kann, aber unmöglich, dies im Allgemeinen zu tun. Für jedes Merkmal der eventuellen Ausgabe des Programms ist es nicht möglich, festzustellen, ob diese Eigenschaft hält. Diese Unmöglichkeit stellt Probleme bei der Analyse von realen Computerprogrammen. Beispielsweise kann man kein Werkzeug schreiben, das Programmierer vollständig vor dem Schreiben unendlicher Schleifen schützt oder Benutzer vor der Bereitstellung von Eingaben schützt, die unendliche Schleifen verursachen würden. Man kann stattdessen ein Programm beschränken, nur für eine feste Zeitdauer (Timeout) auszuführen oder die Leistung von Flow-Control-Anweisungen zu begrenzen (z.B. nur Schlaufen vorzusehen, die über die Elemente eines vorhandenen Arrays iterieren). Ein weiteres Theorem zeigt jedoch, dass es Probleme gibt, die durch Turing-complete Sprachen auflösbar sind, die nicht durch jede Sprache mit nur endlichen Schleiffähigkeiten gelöst werden können (d.h. jede Sprache, die garantiert, dass jedes Programm irgendwann beendet wird). Jede solche Sprache ist also nicht Turing-komplete. So kann beispielsweise eine Sprache, in der Programme abgeschlossen und aufgehalten werden, nicht die von Cantors Diagonalar erstellte Rechenfunktion auf alle Rechenfunktionen in dieser Sprache berechnen. Turing oracles Ein Computer mit Zugriff auf ein unendliches Datenband kann leistungsfähiger sein als eine Turing-Maschine: zum Beispiel kann das Band die Lösung zum Stillstand Problem oder ein anderes Turing-undecidable Problem enthalten. Ein solches unendliches Datenband wird als Turing-Orakel bezeichnet. Selbst ein Turing-Oracle mit zufälligen Daten ist nicht berechenbar (mit Wahrscheinlichkeit 1,), da es nur zahlbar viele Berechnungen, aber unzählbar viele Orakel gibt. So kann ein Computer mit einem zufälligen Turing Oracle Dinge berechnen, die eine Turing-Maschine nicht kann. Digitale Physik Alle bekannten Gesetze der Physik haben Konsequenzen, die durch eine Reihe von Annäherungen auf einem digitalen Computer berechnet werden. Eine Hypothese, die digitale Physik nennt, besagt, dass dies kein Zufall ist, weil das Universum selbst auf einer universellen Turing-Maschine berechnet wird. Dies würde bedeuten, dass kein Computer leistungsfähiger als eine universelle Turing-Maschine physisch gebaut werden kann. Beispiele Die als Turing-komplete Systeme diskutierten Rechensysteme (algebras, calculi) sind diejenigen, die für das Studium der theoretischen Informatik bestimmt sind. Sie sollen so einfach wie möglich sein, so dass es einfacher wäre, die Grenzen der Berechnung zu verstehen. Hier sind ein paar: Automata Theorie Formale Grammatik (Sprachgeneratoren) Formale Sprache (Spracherkenner) Lambda Calculus Post-Türmaschinen Prozessrechnung Die meisten Programmiersprachen (ihre abstrakten Modelle, vielleicht mit einigen bestimmten Konstrukte, die annehmen, dass endlich Speicher weggelassen wird), sind konventionelle und unkonventionell, Turing-komplete. Dazu gehören: Alle allgemein gültigen Sprachen in weitem Gebrauch. Procedural Programmiersprachen wie C, Pascal. Objektorientierte Sprachen wie Java, Smalltalk oder C#.Multi-Paradigm Sprachen wie Ada, C+, Common Lisp, Fortran, Object Pascal, Perl, Python, R. Die meisten Sprachen verwenden weniger häufige Paradigmen: Funktionssprachen wie Lisp und Haskell. Logische Programmiersprachen wie Prolog. Universalmakroprozessor wie m4. Deklarative Sprachen wie XSLT. VHDL und andere Hardware-Beschreibungssprachen. TeX, ein Typeinstellungssystem. Esoterische Programmiersprachen, eine Form der mathematischen Erholung, in der Programmierer arbeiten, wie man grundlegende Programmierkonstrukte in einer extrem schwierigen aber mathematisch Turing-Äquivalentsprache zu erreichen. Einige Rewrite-Systeme sind Turing-komplete. Turing Vollständigkeit ist eine abstrakte Aussage der Fähigkeit, anstatt eine Verordnung von bestimmten Sprachmerkmalen verwendet, um diese Fähigkeit zu implementieren. Die Merkmale, die zur Erreichung der Turing-Komplettheit verwendet werden, können ganz unterschiedlich sein; Fortran-Systeme würden Schleifenkonstrukte oder möglicherweise sogar goto-Anweisungen verwenden, um Wiederholungen zu erreichen; Haskell und Prolog, es fehlt fast vollständig Schleifen, würden Rekursion verwenden. Die meisten Programmiersprachen beschreiben Berechnungen auf von Neumann Architekturen, die Speicher (RAM und Register) und eine Steuereinheit haben. Diese beiden Elemente machen diese Architektur Turing-komplete. Selbst reine Funktionssprachen sind Turing-komplete. Turing Vollständigkeit in declarativem SQL wird durch wiederkehrende gemeinsame Tabellenausdrücke implementiert. Unüberraschend sind auch Verfahrenserweiterungen zu SQL (PLSQL, etc.) Turing-complete. Dies zeigt einen Grund, warum relativ leistungsfähige nicht-Turing-complete Sprachen selten sind: Je leistungsfähiger die Sprache zunächst ist, desto komplexer sind die Aufgaben, auf die sie angewendet wird, und je schneller ihr Mangel an Vollständigkeit als Nachteil wahrgenommen wird, um ihre Erweiterung zu fördern, bis es Turing-complete ist. Der untypische Lambda-Calculus ist Turing-komplete, aber viele Arten Lambda-Calculi, einschließlich System F, sind nicht. Der Wert der eingegebenen Systeme basiert in ihrer Fähigkeit, die meisten typischen Computerprogramme zu repräsentieren, während mehr Fehler zu erkennen. Regel 110 und Conway's Game of Life, beide zelluläre automata, sind Turing-komplete. Unbeabsichtigte Turing Vollständigkeit Einige Spiele und andere Software sind Turing-komplete durch Zufall, d.h. nicht durch Design. Software: Microsoft Excel Microsoft PowerPoint Videospiele: Dwarf Fortress OpenTTD Terraria Minecraft Minesweeper LittleBigPlanet Baba ist Sie Factorio Städte: Skylines Opus Magnum Portal 2 Shenzhen I/OSocial Media: Habbo Hotel Kartenspiele: Magie: Die GatheringZero-Person Spiele (Simulationen:) Conway's Game of LifeComputational languages: C+ TemplatesComputer Hardware: x86 MOV Anleitung Biologie: Chemische Reaktionsnetze und enzymbasierte DNA-Computer haben sich als Turing-equivalente nicht-Turing-komplete Sprachen erwiesen Es gibt viele rechnerische Sprachen, die nicht Turing-komplete sind. Ein solches Beispiel ist der Satz von regulären Sprachen, die durch regelmäßige Ausdrücke erzeugt werden und von endlicher automata erkannt werden. Eine leistungsfähigere, aber immer noch nicht türing-komplete Erweiterung von finite automata ist die Kategorie der Pushdown automata und kontextfreie Grammatik, die häufig verwendet werden, um Parse Bäume in einer ersten Phase des Programm-Compiling zu erzeugen. Weitere Beispiele sind einige der frühen Versionen der Pixel-Tönersprachen, die in Direct3D- und OpenGL-Erweiterungen eingebettet sind. In allen funktionellen Programmiersprachen, wie Charity und Epigram, sind alle Funktionen vollständig und müssen enden. Charity verwendet ein Typensystem und Steuerkonstrukte auf Basis der Kategorietheorie, während Epigram abhängige Typen verwendet. Die LOOP-Sprache ist so konzipiert, dass sie nur die Funktionen, die primitiv rekursiv sind, berechnet. Alle diese rechnergerechten Teilmengen der gesamten Rechenfunktionen, da der vollständige Satz von Gesamtrechnerfunktionen nicht rechnerisch zählbar ist. Auch, da alle Funktionen in diesen Sprachen insgesamt sind, können Algorithmen für wiederauffindbare Sätze nicht in diesen Sprachen geschrieben werden, im Gegensatz zu Turing Maschinen. Obwohl (untypisch) Lambda-Calculus ist Turing-komplete, einfach eingegeben Lambda-Calculus ist nicht. Datensprachen Der Begriff der Turing-Vervollständigung gilt nicht für Sprachen wie XML, HTML, JSON und YAML, weil sie typischerweise verwendet werden, um strukturierte Daten zu repräsentieren, nicht beschreiben Berechnung. Diese werden manchmal als Markupsprachen oder besser als "Containersprachen" oder "Datenbeschreibungssprachen" bezeichnet. Siehe auch Hinweise ReferenzenWeiter lesen Externe Links "Turing Complete". wiki.c2.com