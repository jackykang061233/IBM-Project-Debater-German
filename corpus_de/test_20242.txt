Das Jahr 2038 (auch Y2038, Epochalypse, Y2k38, Y2038 Fehler oder Microsoft Y2K) bezieht sich auf die Darstellung der Zeit in vielen digitalen Systemen als Zahl der Sekunden, die seit dem 1. Januar 1970 auf dem UTC übertragen wurden und ihn als unterzeichnete 32-bit-Nummer speichern. Solche Umsetzungen können nach 03:14:07 UTC am 19. Januar 2038 nicht codieren. ähnlich wie das Y2K-Problem wird das Problem des Jahres 2038 durch unzureichende Kapazität verursacht, die zur Darstellung der Zeit genutzt werden. Ursachen Letztes Mal seit dem 1. Januar 1970, das mit einer unterzeichneten 32-bit-Zahl gespeichert werden kann, ist 03:14:07 am Dienstag, 19 Januar 2038 (231–1 = 2,147,483,647 Sekunden nach 1 Januar 1970. Programme, die versuchen, die Zeit über dieses Datum hinaus zu verlängern, werden den Wert verursachen, der intern als negative Zahl zu speichern ist, die diese Systeme am 20:45 Uhr ausgelegt haben:52 am Freitag, 13 Dezember 1901 (2,147,483,648 Sekunden vor dem 1. Januar 1970) statt 19 Januar 2038. Dies wird durch eine Vielzahl von Überflüssen verursacht, bei denen der Gegenlauf aus unsablen binären digitalen oder Bits läuft und stattdessen das Zeichen abschließt. In diesen Berichten ist eine höchst negative Zahl zu verzeichnen, und die Zahl wird weiter auf Null angehoben und dann durch die positiven Zahlen wieder erhöht. fehlerhafte Berechnungen dieser Systeme verursachen wahrscheinlich Probleme für Nutzer und andere abhängige Parteien. Frühzeitige Probleme Mai 2006 berichtet über eine frühzeitige Manifestation des Problems Y2038 in der AserverOL Software. Die Software wurde mit einem kl präjudiziert, um eine Datenbank-Anforderung zu bearbeiten, die nie auslaufen sollte. Mehr als speziell für diesen speziellen Fall bestimmt das ursprüngliche Design einfach einen willkürlichen Zeitplan in der Zukunft. Die Standarddatenbank für den Server hat angegeben, dass der Antrag nach einer Milliarde Sekunden auslaufen sollte. 1 Milliarde Sekunden (rund 32 Jahre) nach 01:27:28 UTC am 13. Mai 2006 liegt über dem 2038 Stichtag. Nach dieser Zeit ist die Zeitabrechnung überflutet und kehrte ein Datum zurück, das in der Vergangenheit tatsächlich war und die Software zum Absturz führte. Wenn das Problem entdeckt wurde, mussten die AOLServer-Betreiber die Konfigurationsdatei bearbeiten und die Zeit bis zu einem niedrigeren Wert legen. Spieler von Spielen oder Apps, die bereit sind, Wartefristen zu verhängen, laufen in dieses Problem, wenn die Spieler versuchen, die Wartezeit durch die Festlegung des Datums auf ihren Geräten bis zum 19. Januar 2038 zu umgehen, sind aber nicht in der Lage, dies zu tun, da ein 32-bit-PC-Zeitformat verwendet wird. Vul Systeme Embedded Systeme, die Daten für die Berechnung oder den diagnostischen Holzeinschlag verwenden, sind höchstwahrscheinlich vom 2038 Problem betroffen. Viele Transportsysteme von Flug bis Auto nutzen eingebettete Systeme. In Automobilsystemen kann dies ein Antiblockiersystem (ABS), die elektronische Stabilitätskontrolle (ESC/ESP), die Traktionskontroll (TCS) und die automatische Vierradantriebe umfassen; Flugzeuge können inertiale Leitfäden und GPS-Empfänger verwenden. Dies bedeutet jedoch nicht, dass alle diese Systeme vom Problem Y2038 leiden, da viele solche Systeme keinen Zugang zu Daten erfordern. Für diejenigen, die den Unterschied zwischen den Zeiten/Tagen und nicht absoluten Zeiten/Zeiten nur durch die Art der Berechnung bewältigt haben, werden diese Systeme kein großes Problem haben. Hierbei handelt es sich um Kfz-Diagnose auf der Grundlage von legislatierten Normen wie CARB (California Air Resources Board). Ein weiterer wichtiger Einsatz von eingebetteten Systemen ist in Kommunikationsgeräten, einschließlich Zelltelefonen und Internetgeräten (Transporter, drahtlose Zugangspunkte, IP-Kameras usw.). die sich auf die Speicherung einer genauen Zeit und Datum stützen und zunehmend auf UNIX-ähnliche Betriebssysteme basieren. Beispielsweise macht das Problem Y2038 einige Geräte mit 32-bit Android-Absturz und wird nicht wieder aufgenommen, wenn die Zeit zu diesem Zeitpunkt geändert wird. Trotz der modernen 18-24-Monats-Generational-Aktualisierung in der Computersysteme-Technologie sind eingebettete Systeme konzipiert, um die Lebensdauer der Maschine, in der sie eine Komponente sind, zu erfüllen. Es ist denkbar, dass einige dieser Systeme noch in 2038 genutzt werden können. In einigen Fällen kann es unpraktisch oder unmöglich sein, die Software, die diese Systeme betreibt, zu aktualisieren, letztlich zu ersetzen, wenn die 32-bit-Beschränkungen korrigiert werden sollen. MySQL Datenbank installierte Funktionen wie UNIX_ETSTAMP)( werden 0 nach 03:14:07 UTC am 19. Januar 2038 zurückgeben. Früh Mac OS X-Versionen sind für das Jahr 2038 anfällig. Datenstrukturen mit Zeitproblemen Viele Datenstrukturen, die heute genutzt werden, verfügen über 32-bit-Zeitvertretungen, die in ihre Struktur eingebettet sind. Eine vollständige Liste dieser Datenstrukturen ist praktisch unmöglich, aber es gibt gut bekannte Datenstrukturen, die das Problem der Microsoft-Zeit haben: Dateisysteme (many-Dateisysteme verwenden nur 32 Bit, um Zeiten in Inodes zu vertreten) binäre Formate (d. h. 32-bit-Zeitfelder) Datenbanken (d. h. 32-bit-Zeitfelder) Abfragen Sprachen, z.B. Beispiele für Systeme, die Datenstrukturen verwenden, die 32-bit-Zeit-Vertretungen enthalten können, sind: eingebettete Fabrik, Raffineriekontrolle und Überwachung von Subsystemen als Konsortierte militärische Geräte Jedes System, das Datenstrukturen mit 32-bit-Zeit-Vertretern nutzt, wird das Risiko darstellen. Risikograd ist abhängig vom Fehlermodus. Mögliche Lösungen Es gibt keine universelle Lösung für das Problem des Jahres 2038. In der C-Sprache würde jede Änderung der Definition der Datenart Zeit_t zu Code-.-Problemen in jedem Antrag führen, in dem Datum und Zeitvertretungen von der Art der unterzeichneten 32-bit-Zeit_t-Nummer abhängig sind. Zum Beispiel würde sich die Zeit ändern, die sich auf eine nicht unterzeichnete 32-bit-Nummer ausdehnt, die die Bandbreite auf 2106 (insbesondere 06:28:15 UTC am Sonntag, 7 Februar 2106,) ausdehnen würde, Programme, die vor dem Jahr 1970 speichern, sammeln oder manipulieren, da diese Daten durch negative Zahlen vertreten sind. Größe der Zeit_t-Typ auf 64 Bits in einem bestehenden System würde zu nicht kompatiblen Veränderungen der Gestaltung der Strukturen und der binären Schnittstelle führen. Die meisten Betriebssysteme, die auf 64-bit-Hardware laufen, haben bereits 64bit-Zeit_t-Zahlen unterzeichnet. Mit einem unterzeichneten 64-bit-Wert wird ein neues Umlaufdatum eingeführt, das über zwanzigmal größer ist als das geschätzte Zeitalter des Universums: etwa 292 Milliarden Jahre. Die Fähigkeit, Berechnungen zu den Daten zu machen, ist begrenzt, da Tm_Jahr einen unterzeichneten 32-bit-Lastwert ab 1900 Jahren verwendet. Dieses Jahr beschränkt sich auf maximal 2147,485,547 (2,147,483,647 + 1900). FreeBSD nutzt 64-bit-Zeit_t für alle 32-bit- und 64-bit-Architekturen mit Ausnahme von 32-bit i386, die die 32-bit-Zeit_t anstelle von 32-bit-Zeit_t verwenden. Start mit NetBSD Version 6,0 (im Oktober 2012 freigesetzt) verwendet das NetBSD-Betriebssystem eine 64-bit-Zeit_t für 32-bit- und 64-bit-Architekturen. Anwendungen, die für eine ältere NetBSD- Freisetzung mit 32-bit-Zeit_t zusammengestellt wurden, werden über eine binäre Kompatibilitätsschicht unterstützt, aber solche älteren Anwendungen werden immer noch unter dem Problem des Jahres 2038 leiden. OpenBSD seit Version 5.5, veröffentlicht im Mai 2014, nutzt auch eine 64-bit-Zeit_t für 32-bit- und 64-bit-Architekturen. Kontrast zu NetBSD gibt es keine binäre Kompatibilitätsschicht. Anwendungen, die eine 32-bit-Zeit_t und Anwendungen erwarten, die alle von der Zeit bis zur Speicherung von Zeitwerten unterscheiden, können daher brechen. ursprünglich eine 64-bit-Zeit_t für 64-bit-Architekturen verwendet; die reine 32-bit ABI wurde aufgrund der Rückverfolgbarkeit nicht geändert. Ab der Version 5.6 wird 64-bit-Zeit_t auch auf 32-bit-Architekturen unterstützt. Letzteres wurde vor allem im Interesse von eingebetteten Softwaresystemen getan. Die x32 ABI für Linux (die ein Umfeld für Programme mit 32-bit-Adressen definiert, aber den Prozessor in 64-bit-Modus führt) nutzt eine 64-bit-Zeit_t. Da es sich um ein neues Umfeld handelte, gab es keine besonderen Kompatibilitätsvorkehrungen. Obwohl die nativen APIs von OpenVMS die Zeitstempel bis zum 31. Juli 31086 unterstützen können, nutzt die C Runtime Library (CRTL) 32-bit-Zahlen für Zeit_t. Im Rahmen der im Jahr 1998 durchgeführten Konformitätsarbeit Y2K wurde der CRTL geändert, um nicht unterzeichnete 32-bit-Zahlen zur Darstellung der Zeit zu verwenden; die Zeitspanne bis zum 7. Februar 2106 zu verlängern. Systemversion 4 hat seine Zeitfelder als Struktur nfstime4 {int64_t Sekunden; uint32_t nz;} seit Dezember 2000 festgelegt. Werte mehr als Null für die Sekunden Felddichten nach der 0-Stunden, Januar 1, 1970. Werte weniger als Null für die Sekunden vor der 0-Stunden-Zeit, Januar 1, 1970. In beiden Fällen ist das Feld nz (nanozs) für die endgültige Vertretung in die Sekunden eingelegt. Alternativvorschläge (einige davon sind bereits in Gebrauch), wie z.B. die Lagerung von entweder geschliffenen oder Mikrosekten seit einer Zeit (normalerweise entweder 1 Januar 1970 oder 1 Januar 2000) in einer unterzeichneten 64-bit-Nummer, die eine Mindestanzahl von 300.000 Jahren bei der Mikrosekretierung vorsieht. Insbesondere wird die Verwendung von 64-bit-Langnummern überall in der Zeit als „milliz ab dem 1. Januar 1970“ korrekt für die nächsten 292 Millionen Jahre arbeiten. Andere Vorschläge für neue Zeitvertretungen bieten unterschiedliche Präzisionen, Bandbreiten und Größen (fast immer breiter als 32 Bits) sowie die Lösung anderer damit zusammenhängender Probleme, wie die Handhabung von Sprung Sekunden. TAI64 ist insbesondere eine Umsetzung des Internationalen Atomzeitstandards (TAI), des aktuellen internationalen Echtzeit-Standards zur Festlegung eines zweiten und Referenzrahmens. Siehe auch die Einführung der GPS-Woche, die im November 2038 Deep Impact geschieht, wird davon ausgegangen, dass sie zum Zeitpunkt der internen Uhr 232 100-millizintervalle (one-tenth Sekunde) seit 2000 verloren gegangen sind, am 11. August 2013 00:38:49 UTC. Zeitformatierung und Speicherung von Schlagzeilen sind Verweise auf Außenbeziehungen Y2038 Nachweisness Design glibc Wiki Einreise in Wie Stuff Works Das Projekt 2038 Häufig gestellte Fragen Kritische und wichtige Termine 2038 A 2038-safe Ersatz für Zeit.h auf 32 Bitsysteme Baraniuk, Chris (5 Mai 2015). "Die Zahl der Glitchen, die zu Katastrophen führen können". BBC Future. Clewett, James. "2,147,483,647 - Das Ende der Zeit [Unix]". Nummerphile. Brady Haran. Archiviert vom Original am 22. Mai 2017 April 2013