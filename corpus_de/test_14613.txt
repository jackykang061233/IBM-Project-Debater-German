In der Kryptographie bietet das Elliptische Curve Digital Signature Algorithm (ECDSA) eine Variante des Digital Signature Algorithm (DSA), das elliptische Kurven-Kryptographie verwendet. Schlüssel und Signatur-Größe Wie bei der elliptisch-kurven Kryptographie im Allgemeinen, die Bitgröße des öffentlichen Schlüssels für ECDSA benötigt wird etwa doppelt so groß wie die Sicherheitsstufe in Bits. So würde z.B. bei einem Sicherheitsniveau von 80 Bits - d.h. ein Angreifer benötigt maximal etwa 2 80 \{displaystyle 2^{80}-Operationen, um den privaten Schlüssel zu finden - die Größe eines ECDSA-Privatschlüssels 160 Bit betragen, während die Größe eines DSA-Privatschlüssels mindestens 1024 Bit beträgt. Andererseits ist die Signaturgröße sowohl für DSA als auch für ECDSA gleich: etwa 4 t \{displaystyle 4t} Bits, wobei t \{displaystyle t} der in Bits gemessene Sicherheitspegel ist, also etwa 320 Bits für einen Sicherheitspegel von 80 Bits. Signature Generation Algorithmus Suppose Alice will eine signierte Nachricht an Bob senden. Zunächst müssen sie die Kurvenparameter (CURVE , G , n ) \{displaystyle \({textrm {CURVE},G,n) einig sein. Neben dem Feld und der Gleichung der Kurve benötigen wir G \{displaystyle G}, einen Grundpunkt der Hauptordnung auf der Kurve; n \{displaystyle n} ist die multiplikative Reihenfolge des Punktes G \{displaystyle G} . Die Reihenfolge n \{displaystyle n} des Basispunktes G \{displaystyle G} muss vorzüglich sein. In der Tat gehen wir davon aus, dass jedes nicht-zero Element des Rings Z / n Z \{displaystyle \mathbb {Z} /n\mathbb {Z} } invertierbar ist, so dass Z / n Z \{displaystyle \mathbb {Z} /n\mathbb {Z} ein Feld sein muss. Es bedeutet, dass n \{displaystyle n} primär sein muss (vgl. Bézouts Identität). Alice erstellt ein Schlüsselpaar, bestehend aus einer privaten Schlüssel-Integer d A \{displaystyle d_{A}, zufällig ausgewählt im Intervall [1 , n - 1 ] \{displaystyle [1,n-1}] und einem öffentlichen Schlüsselkurvenpunkt Q A = d A × G \{displaystyle Q_{A}=d_{A}\Zeiten G} .Wir verwenden × \{displaystyle \times } um elliptische Kurvenpunktvervielfachung durch einen Skalar zu bezeichnen. Für Alice, um eine Nachricht m \{displaystyle m} zu unterschreiben, folgt sie diesen Schritten: Berechnung e = HASH (m ) \{displaystyle e={\textrm {HASH}(m) . (Hier ist HASH eine kryptographische Hash-Funktion, wie SHA-2, mit dem Ausgang in eine ganze Zahl umgewandelt.) Lassen Sie z \{displaystyle z} die L n \{displaystyle L_{n} linkmost bits von e \{displaystyle e} sein, wobei L n \{displaystyle L_{n} die Bitlänge der Gruppenbestellung n \{displaystyle n} ist. (Anmerkung, dass z \{displaystyle z} größer sein kann als n \{displaystyle n} aber nicht länger.) Wählen Sie eine kryptographisch sichere zufällige ganze Zahl k \{displaystyle k} aus [ 1, n - 1 ] \{displaystyle [1,n-1}] .Kalkulieren Sie den Kurvenpunkt ( x 1 , y 1 ) = k × G \{displaystyle (x_{1},y_{1})=k\times G} .Calculate r = x 1 mod n \{displaystyle r=x_{1}\,{\bmod ,\{n .If r = 0 \{displaystyle r=0}, go back to step 3. Berechnung s = k - 1 (z + r d A) mod n \{displaystyle s=k^{-1}(z+rd_{A})\,{\bmod ,\{n} .If s = 0 \{displaystyle s=0} , gehen Sie zurück zu Schritt 3. Die Signatur ist das Paar (r, s ) \{displaystyle (r,s}). (Und (r, − s mod n ) \{displaystyle (r,-s\,{\bmod ,\{n) ist auch eine gültige Signatur.) Es ist nicht nur erforderlich, dass k \displaystyle k} geheim ist, sondern es ist auch entscheidend, für verschiedene Signaturen unterschiedliche k \{displaystyle k} zu wählen, andernfalls kann die Gleichung in Schritt 6 für d A \{displaystyle d_{A} und r z-z'{s-s .Seit s = k - 1 (z + r d A) \{displaystyle s=k^{-1}(z+rd_{A) , kann der Angreifer nun den privaten Schlüssel d A = s k - z r \{displaystyle d_{A}=\frac sk-z}{r berechnen. Dieser Implementierungsfehler wurde zum Beispiel verwendet, um den Signing-Schlüssel für die PlayStation 3 Gaming-Konsole zu extrahieren. Eine andere Möglichkeit ECDSA Signatur kann private Schlüssel lecken ist, wenn k \{displaystyle k} von einem fehlerhaften Zufallszahlengenerator erzeugt wird. Ein solcher Fehler in der Zufallszahlengenerierung verursachte Benutzer von Android Bitcoin Wallet, um ihre Gelder im August 2013 zu verlieren. Um sicherzustellen, dass k \{displaystyle k} für jede Nachricht einzigartig ist, kann man die Zufallszahlenerzeugung vollständig umgehen und deterministische Signaturen erzeugen, indem k \{displaystyle k} aus der Nachricht und dem privaten Schlüssel abgeleitet wird. Signaturverifikationsalgorithmus Für Bob Alices Unterschrift zu authentifizieren, muss er eine Kopie ihres Public-key-Kurvenpunktes Q A \{displaystyle Q_{A} haben.Bob kann überprüfen Q A \{displaystyle Q_{A} ist ein gültiger Kurvenpunkt wie folgt: Prüfen Sie, dass Q A \{displaystyle Q_{A} nicht gleich dem Identitätselement O ist und seine Koordinaten ansonsten gültig sind. Q_{A} Danach folgt Bob diesen Schritten: Vergewissern Sie sich, dass r und s ganze Zahlen in [1, n - 1] \{displaystyle [1,n-1}] sind. Falls nicht, ist die Unterschrift ungültig. Berechnen e = HASH (m ) \{displaystyle e={\textrm {HASH}(m) , wobei HASH die gleiche Funktion ist, die in der Signatur-Generation verwendet wird. ,, , , , , , n , n , n , n , n , n , n , n , n , n , n , n , n , n , n , n , n , n , n , n , n , n , n , n , n , n A \{displaystyle (x_{1},y_{1})=u_{1}\times G+u_{2}Zeiten Q_{A} .If ( x 1 , y 1 ) = O \{displaystyle (x_{1},y_{1})= O dann ist die Unterschrift ungültig. Die Signatur ist gültig, wenn r ≡ x 1 (mod n ) \{displaystyle r\equiv x_{1}{\pmod {n} andernfalls ungültig ist. Beachten Sie, dass eine effiziente Implementierung inverse s - 1 mod n \{displaystyle s^{-1}\,{\bmod ,\{n nur einmal berechnen würde. Auch mit Shamir's Trick, eine Summe von zwei Skalarmultiplikationen u 1 × G + u 2 × Q A \{displaystyle u_{1}\times G+u_{2}Zeiten Q_{A} kann schneller berechnet werden als zwei skalare Multiplikationen, die unabhängig durchgeführt werden. Korrektur des Algorithmus Es ist nicht sofort offensichtlich, warum die Überprüfung sogar richtig funktioniert. Um zu sehen, warum, bezeichnet als C der in Schritt 5 der Verifikation berechnete Kurvenpunkt, C = u 1 × G + u 2 × Q A \{displaystyle C=u_{1}\Zeiten G+u_{2}Zeiten Q_{A) Aus der Definition des öffentlichen Schlüssels als Q A = d A × G \{displaystyle Q_{A}=d_{A}\times G}, C = u 1 × G + u 2 d A × G \{displaystyle C=u_{1}\Zeiten G+u_{2}d_{A}Zeiten G} Weil elliptische Kurvenskalarmultiplikation über Addition verteilt, C = ( u 1 + u 2 d A) × G \{displaystyle C=(u_{1}+u_{2}d_{A})\Zeiten G! Erweitern der Definition von u 1 \{displaystyle u_{1} und u 2 \{displaystyle u_{2} aus Verifikationsschritt 4, C = (z s - 1 + r d A s - 1 ) × G \{displaystyle C=(zs^{-1}+rd_{A}s^-1})\ s − 1 × G \{displaystyle C=(z+rd_{A})s^{-1}\times G! Erweitern der Definition von s aus dem Signaturschritt 6, C = (z + r d A) (z + r d A ) - 1 (k - 1 ) - 1 × G \{displaystyle C=(z+rd_{A})(z+rd_{A})^{-1}(k{-1})^{-1}\times G! Da die Inverse eines Invers das ursprüngliche Element ist, und das Produkt eines Elements inverse und das Element die Identität ist, sind wir mit C = k × G \{displaystyle C=k\times G} Aus der Definition von r ist dies der Prüfschritt 6. Dies zeigt nur, dass eine korrekt signierte Nachricht korrekt überprüft wird; viele andere Eigenschaften werden für einen sicheren Signaturalgorithmus benötigt. Angesichts einer Nachricht m und Alices Unterschrift r, s \{displaystyle r,s} auf dieser Nachricht, Bob kann (potenziell) Alices öffentlicher Schlüssel erholen: Vergewissern Sie sich, dass r und s ganze Zahlen in [1, n - 1] \{displaystyle [1,n-1}] sind. Falls nicht, ist die Unterschrift ungültig. Berechnen eines Kurvenpunktes R = ( x 1 , y 1 ) \{displaystyle R=(x_{1},y_{1) wobei x 1 \{displaystyle x_{1} einer von r \{displaystyle r} ist, r + n \{displaystyle r+n}, r + 2 n \{displaystyle r+2n}, etc.(providiert x 1 \ \ \ Beachten Sie, dass es mehrere Kurvenpunkte geben kann, die diese Bedingungen erfüllen, und jeder unterschiedliche R-Wert führt zu einem eindeutigen wiederhergestellten Schlüssel. Berechnen e = HASH (m ) \{displaystyle e={\textrm {HASH}(m) , wobei HASH die gleiche Funktion ist, die in der Signatur-Generation verwendet wird. Berechnen Sie u 1 = - z r - 1 mod n \{displaystyle u_{1}=-zr^{-1}\,{\bmod ,\{n und u\2= s r - 1 mod n \{displaystyle u_{2}=sr^{-1}\,{\b\b mod,{c}Berechnung des Kurvenpunktes Q A = ( x A, y A) = u 1 × G + u 2 × R \{displaystyle Q_{A}=(x_{A},y_{A})=u_{1}\times G+u_{2}\times R} .Die Signatur ist gültig, wenn Q A \{displaystyle Q_{A} mit Alices öffentlichem Schlüssel übereinstimmt. Die Signatur ist ungültig, wenn alle möglichen R-Punkte versucht wurden und keine Alices öffentlichen Schlüssels entspricht. Beachten Sie, dass eine ungültige Unterschrift oder eine Unterschrift aus einer anderen Nachricht zur Wiederherstellung eines falschen öffentlichen Schlüssels führen wird. Der Wiederherstellungsalgorithmus kann nur verwendet werden, um die Gültigkeit einer Signatur zu überprüfen, wenn der öffentliche Schlüssel des Signers (oder dessen Hash) vorher bekannt ist. Korrektur des Wiederherstellungsalgorithmus Beginnen Sie mit der Definition von Q A \{displaystyle Q_{A} aus dem Wiederherstellungsschritt 6, Q A = ( x A, y A) = u 1 × G + u 2 × R \{displaystyle Q_{A}=(x_{A},y_{A})=u_{1}\times G+u_{2}Zeiten R} Aus der Definition R = ( x 1 , y 1 ) = k × G \{displaystyle R=(x_{1},y_{1})=k\times G} aus dem Unterzeichnerschritt 4, Q A = u 1 × G + u 2 k × G \{displaystyle Q_{A}=u_{1}\Zeiten G+u_{2}k\Zeiten G} Weil elliptische Kurvenskalarmultiplikation über Addition verteilt, Q A = ( u 1 + u 2 k) × G \{displaystyle Q_{A}=(u_{1}+u_{2}k)\times G} Erweitern der Definition von u 1 \{displaystyle u_{1} und u 2 \{displaystyle u_{2} aus Recovery Step 5, Q A = ( − z r − 1 + s k r − 1 ) × G \{displaystyle Q_{A}=(-zr^{-1}+skr^{-1})\Zeiten G} Erweitern der Definition von s aus dem Signaturschritt 6, Q A = ( - z r - 1 + k - 1 ( z + r d A) k r - 1 ) × G \{displaystyle Q_{A}=(-zr^{-1}+k^{-1}(z+rd_{A})kr^{-1})\Zeiten G! Da das Produkt der Inverse eines Elements und das Element die Identität ist, sind wir mit Q A = ( − z r − 1 + (z r − 1 + d A ) × G \{displaystyle Q_{A}=(-zr^{-1}+(zr^{-1}+d_{A}))\Zeiten G! Die ersten und zweiten Bedingungen heben sich aus, Q A = d A × G \{displaystyle Q_{A}=d_{A}\times G} Aus der Definition von Q A = d A × G \{displaystyle Q_{A}=d_{A}\times G} ist das Alices öffentlicher Schlüssel. Dies zeigt, dass eine korrekt signierte Nachricht den richtigen öffentlichen Schlüssel wiederherzustellen, sofern zusätzliche Informationen geteilt wurden, um den Kurvenpunkt R = ( x 1 , y 1 ) \{displaystyle R=(x_{1},y_{1) vom Signaturwert r eindeutig zu berechnen. Sicherheit Im Dezember 2010 kündigte eine Gruppe, die sich als fail0verflow bezeichnete, die Wiederherstellung des ECDSA-Privatschlüssels an, der von Sony verwendet wurde, um Software für die PlayStation 3 Spielkonsole zu unterzeichnen. Dieser Angriff funktionierte jedoch nur, weil Sony den Algorithmus nicht richtig implementierte, weil k \{displaystyle k} statische statt zufällig war. Wie im Abschnitt Signature-Generationsalgorithmus oben erwähnt, macht dies d A \{displaystyle d_{A} auflösbar, was den gesamten Algorithmus nutzlos macht. Am 29. März 2011 veröffentlichten zwei Forscher ein IACR-Papier, in dem gezeigt wird, dass es möglich ist, einen TLS-Privatschlüssel eines Servers mit OpenSSL abzurufen, der mit Elliptic Curves DSA über ein Binärfeld über einen Timing-Angriff authentifiziert. Die Sicherheitslücke wurde in OpenSSL 1.0.0e behoben. Im August 2013 wurde gezeigt, dass Bugs in einigen Implementierungen der Java-Klasse SecureRandom manchmal Kollisionen im k \{displaystyle k}-Wert erzeugt haben. Dies erlaubt Hacker, um private Schlüssel zu erholen, die ihnen die gleiche Kontrolle über Bitcoin-Transaktionen wie legitime Schlüssel Besitzer hatte, mit dem gleichen Exploit, die verwendet wurde, um die PS3 unterzeichnen Schlüssel auf einigen Android-App-Implementierungen, die Java verwenden und verlassen auf ECDSA, um Transaktionen zu authentifizieren. Dieses Problem kann durch eine unvorhersehbare Generation von k \{displaystyle k}, z.B. ein deterministisches Verfahren, wie es von RFC 6979 beschrieben wird, verhindert werden. Sachgebiete Es gibt zwei Arten von Bedenken mit ECDSA: Politische Bedenken: Die Vertrauenswürdigkeit von NIST-produzierten Kurven, die nach Enthüllungen in Frage gestellt werden, dass die NSA bereitwillig Hintertüren in Software, Hardwarekomponenten und veröffentlichte Standards einfügt; bekannte Kryptographen haben Zweifel darüber geäußert, wie die NIST-Kurven entwickelt wurden, und freiwillige Bewahrung wurde bereits in der Vergangenheit nachgewiesen. Dennoch fehlt noch ein Beweis, dass die benannten NIST-Kurven eine seltene Schwäche ausnutzen. Technische Bedenken: die Schwierigkeit, den Standard, seine Slowness und Designfehler richtig umzusetzen, die die Sicherheit bei unzureichend defensiven Implementierungen des Dual_EC_DRBG Zufallsgenerators verringern. Beides ist in der Einführung der libssh-Kurve25519 zusammengefasst. Im Folgenden finden Sie eine Liste kryptographischer Bibliotheken, die Unterstützung für ECDSA bieten: Botan Bouncy Castle cryptlib Crypto+ libgcrypt GnuTLS OpenSSL Wolf Crypt LibreSSL mbed TLS Microsoft CryptoAPI Crypto API (Linux) Beispiel-Nutzung Wikipedia.org verwendet ECDSA in einem TLS-Ciphersuite, um sich an Webbrowser zu authentifizieren, die das folgende verkürzte Transkript zeigt. Siehe auch EdDSA RSA (cryptosystem) Referenzen Weiter lesen Akkreditierte Standards Committee X9, ASC X9 stellt neuen Standard für Public Key Cryptography/ECDSA, 6. Okt. 2020. Source Accredited Standards Committee X9, American National Standard X9.62-2005, Public Key Cryptography for the Financial Services Industry, The Elliptic Curve Digital Signature Algorithm (ECDSA,) 16. November 2005. Certicom Forschung, Standards für effiziente Kryptographie, SEC 1: Elliptic Curve Cryptography, Version 2.0, 21. Mai 2009.López, J. und Dahab, R. Eine Übersicht über Elliptic Curve Cryptography, Technical Report IC-00-10, State University of Campinas, 2000. Daniel J. Bernstein, Pippengers Exponentiationalgorithmus, 2002. Daniel R. L. Brown, Generische Gruppen, Kollisionswiderstand und ECDSA, Designs, Codes und Kryptographie, 35, 119–152, 2005. ePrint version Ian F. Blake, Gadiel Seroussi, und Nigel Smart, Editoren, Fortschritte in Elliptic Curve Cryptography, London Mathematical Society Lecture Note Series 317, Cambridge University Press, 2005. Hankerson, D;. Vanstone, S;. Menezes, A. (2004). Leitfaden zur Elliptischen Curve Cryptography.Springer Professional Computing. New York: Springer.doi:10.1007/b97644.ISBN 0-387-95273-X. S2CID 720546. Externe Links Digital Signature Standard; enthält Informationen über ECDSA Der Elliptic Curve Digital Signature Algorithm (ECDSA;) bietet einen ausführlichen Leitfaden über ECDSA. Link zum Thema