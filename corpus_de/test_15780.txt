In der Computerwissenschaft ist ein Dolmetscher ein Computerprogramm, das in einer Programmierungs- oder Schreibsprache unmittelbar Anweisungen ausführt, ohne dass sie zuvor in ein maschinenlesbares Sprachprogramm zusammengefasst wurden. Ein Dolmetscher nutzt in der Regel eine der folgenden Strategien für die Programmdurchführung: Parse den Herkunftscode und führt sein Verhalten direkt durch; die Quelle in einen effizienten Zwischenvertretungs- oder Einspruchscode und führt diese unverzüglich durch; faktisch ausgeführte Vorabkompilierte Codes, die von einem Gutachter erstellt werden, der Teil des Dolmetschersystems ist. Frühversionen der Lisp Programmierungssprache und der Minicomputer und Mikrocomputer werden Beispiele für die erste Art sein. Perl, Python, MATLAB, Ruby sind Beispiele für die zweite, während UCSD Pascal ein Beispiel für die dritte Art ist. Quelle Programme werden vor der Zeit erstellt und als maschinenlesbarer, unabhängiger Code gespeichert, der dann mit der Laufzeit verbunden ist und von einem Dolmetscher- und/oder Teamer (für JIT-Systeme) ausgeführt wird. Manche Systeme, wie kleine und zeitgenössische Versionen von und Java können ebenfalls zwei und drei miteinander verbinden. Dolmetscher verschiedener Arten wurden auch für viele Sprachen gebaut, die traditionell mit der Zusammenstellung assoziiert sind, wie Algol, Fortran, Cobol, C und C++. Dolmetschen und Zusammenstellungen sind die beiden wichtigsten Mittel, mit denen die Programmiersprachen umgesetzt werden, sind sie nicht gegenseitig exklusiven Charakter, da die meisten Dolmetschsysteme auch einige Übersetzungsarbeiten durchführen, genauso wie die Sammelstellen. Die Begriffe "interpredierte Sprache" oder "kompilierte Sprache" erklären, dass die faktische Umsetzung dieser Sprache ein Dolmetscher oder ein Gebildner ist. Eine hochrangig besetzte Sprache ist ideal eine abstrakte, von bestimmten Umsetzungen unabhängig. Frühere Dolmetscher wurden bereits 1952 verwendet, um die Programmierung innerhalb der Grenzen von Computern zum Zeitpunkt zu erleichtern (z.B. fehlende Programmspeicherfläche oder keine einheimische Unterstützung für schwimmende Nummern). Dolmetscher wurden auch verwendet, um zwischen maschinenlesbaren Sprachen zu übersetzen, so dass Code für Maschinen, die noch im Bau waren und auf Computer getestet wurden, die bereits existierten. Die erste interpretierte hochrangige Sprache war Lisp. Lisp wurde erstmals 1958 von Steve Russell auf einem IBM 704 Computer umgesetzt. Russell hatte das Papier von John McCarthy gelesen und realisiert (To McCarthys Überraschung), dass die Funktion der Lisp eval im Maschinencode umgesetzt werden könnte. Das Ergebnis war ein Arbeits Lisp Auslegunger, der verwendet werden könnte, um Lisp-Programme durchzuführen, oder genauer gesagt, „evaluate Lisp Expressions“. Compilers versus Dolmetscherprogramme, die in einer hochrangig besetzten Sprache geschrieben sind, werden entweder direkt von einer Art von Dolmetschern ausgeführt oder von einem Sammler (und dem Linker) für die CPU in Maschinencode umgewandelt. Zusammenfassende (und akkumulierende) Maschinencodes erzeugen zwar im Allgemeinen direkt durch Computer-Hardware übertragene Maschinen, können aber oft (fakultativ) ein Zwischenformular namens Objektcode erstellen. Das ist im Wesentlichen der gleiche maschinenlesbare Code, aber mit einem Symboltabelle mit Namen und Etiketten, um greifbare Blöcke (oder Module) zu identifizieren und wiederzufinden. Compiled Programme werden in der Regel Bausteine (Funktionen) verwenden, die in einer Bibliothek solcher Objektcode-Module aufbewahrt werden. Ein Linker wird verwendet, um (vorgefertigte) Bibliotheksdateien mit den Gegenstanddateien(en) des Antrags zu kombinieren, um eine einzige exekutierbare Datei zu bilden. Gegenstanddateien, die zur Erstellung einer exekutierbaren Datei verwendet werden, werden daher oft in verschiedenen Zeiten produziert, und manchmal auch in unterschiedlichen Sprachen (in der Lage, dasselbe Objektformat zu erstellen). Ein einfacher Dolmetscher, der in einer niedrigen Sprache (z.B. in der Versammlung) geschrieben ist, kann ähnliche Maschinencodeblöcke besitzen, die Durchführungsfunktionen der hochrangig gespeicherten Sprache anwenden und bei der Einreise einer Funktion in einen Blickpunkt auf diesen Code ausgeführt werden. Jedoch verwendet ein Dolmetscher, der in einer hochrangig besetzten Sprache geschrieben ist, in der Regel einen anderen Ansatz, wie die Erzeugung und der anschließende Aufstieg eines Parsebaums oder die Herstellung von zwischen Software definierten Anweisungen oder beide. So werden sowohl die Autoren als auch die Dolmetscher in der Regel den Herkunftscode (Textdateien) in Token umwandeln, kann (oder kann nicht) einen Parsebaum erzeugen, und beide können sofortige Anweisungen (für eine stapelbare Maschine, vierruple Code oder andere Mittel) generieren. Der grundlegende Unterschied besteht darin, dass ein Zusammenstellungssystem, einschließlich eines (in oder getrennten) Linkers, ein eigenständiges Maschinencode-Programm erstellt, während ein Dolmetschersystem anstelle der im Hochrangigen Programm beschriebenen Maßnahmen durchgeführt wird. Man kann also fast alle Umwandlungen von Quellencodes semantikern auf die Maschinenebene einmal und für alle (d. h. bis das Programm geändert werden muss) machen, während ein Dolmetscher jeden Zeitpunkt eine Erklärung oder Funktion ausführen muss. In einem effizienten Dolmetscher wird jedoch viel der Übersetzungsarbeit (einschließlich der Analyse von Arten und ähnlichen) nur zum ersten Mal ein Programm, ein Modul, eine Funktion oder sogar eine Erklärung durchgeführt, so dass es sehr an der Art und Weise, wie ein Pool funktioniert. Jedoch läuft ein zusammengestelltes Programm unter den meisten Umständen noch viel schneller, zum Teil weil die Zusammenstellungen zum Optimierungscode konzipiert sind und zu diesem Zweck genügend Zeit haben. Dies gilt insbesondere für einfachere hochwertige Sprachen ohne (many) dynamische Datenstrukturen, Kontrollen oder Artskontrolle. In der traditionellen Zusammenstellung ist die exekutable Produktion der Linker (.exe Dateien oder .dll Dateien oder eine Bibliothek, siehe Bild) in der Regel wiederaufladbar, wenn sie im Rahmen eines allgemeinen Betriebssystems betrieben werden, viel wie die Objektcode-Module sind, aber mit dem Unterschied, dass diese Umverteilung im laufenden Stadium dynamisch ist, d. h. wenn das Programm für die Ausführung eingesetzt wird. Auf der anderen Seite werden zusammengestellte und verwandte Programme für kleine eingebettete Systeme in der Regel statische zugewiesen, oft in einem NOR-Lichtspeicher, da es oft keine sekundäre Lagerung und kein Betriebssystem in diesem Sinne gibt. Historisch haben die meisten Dolmetschensysteme einen selbsttragenden Chef aufgebaut. Es wird immer häufiger für Sammler (die häufig als IDE bezeichnet werden), obwohl einige Programmteilnehmer lieber einen Herausgeber ihrer Wahl verwenden und den Pool, Linker und andere Werkzeuge manuell betreiben möchten. Historisch vordate Dolmetscher, weil Hardware zu diesem Zeitpunkt nicht sowohl den Dolmetscher- und Auslegungscode als auch die typische Chargenumgebung der Zeit die Vorteile der Auslegung unterstützen konnte. Entwicklungszyklus Während des Software-Entwicklungszyklus machen die Programmierer häufige Änderungen an der Quelle. Jedes Mal, wenn ein Pool verwendet wird, muss ein Wechsel zum Herkunftscode vorgenommen werden, müssen sie warten, um die veränderte Quelle zu übersetzen und alle binären Code-Dateien zusammen zu verbinden, bevor das Programm ausgeführt werden kann. Je größer das Programm, desto länger das Warten. Kontrastlich ist ein Programmteilnehmer, der einen Dolmetscher benutzt, viel weniger aufwarten, da der Dolmetscher in der Regel nur auf eine Zwischenvertretung übersetzen muss (oder sie überhaupt nicht übersetzen lassen), so dass viel weniger Zeit vor der Überprüfung der Änderungen erforderlich ist. Auswirkungen zeigen sich auf die Rettung des Quellecodes und die Umladung des Programms. Vervollständigter Code ist in der Regel weniger leicht als Bearbeitung, Ausgleich und Verknüpfung von sequentiellen Prozessen, die in der richtigen Reihenfolge mit einer entsprechenden Reihe von Befehlen durchgeführt werden müssen. In diesem Zusammenhang haben viele Künstler auch eine Exekutivhilfe, die als Make-Datei und Programm bekannt ist. In der Make-Datei werden die Befehlslinien und die Programmquelle-Code-Dateien zusammengefasst, können aber eine einfache Befehlslinie-Tabellen (z.B. "Make 3)" einnehmen, die die dritte Gruppe (set) aus Anweisungen auswählen, dann die Befehlsbefehle an den Pool und die Linker, die die angegebenen Datencodedateien verwenden. Vertrieb Ein zusammengestellter Konversionscode in binäre Anleitung für eine bestimmte Prozessorarchitektur und damit weniger tragbare Geräte. Diese Umwandlung erfolgt gerade einmal, auf der Umgebung des Entwicklers, und nach dem, dass derselbe bin auf die Maschinen des Benutzers verteilt werden kann, wenn es ohne weitere Übersetzung ausgeführt werden kann. Ein Cross-Pooler kann einen binären Code für die Benutzermaschine schaffen, auch wenn es einen anderen Prozessor als die Maschine hat, in der der Code zusammengestellt ist. Ein verdolmettes Programm kann als Quellecode verteilt werden. Es muss in jeder Endmaschine übersetzt werden, die mehr Zeit dauert, aber die Programmverteilung unabhängig von der Architektur der Maschine macht. Jedoch hängt die Übertragbarkeit des Auslegungscodes von der Zielmaschine ab, die tatsächlich einen geeigneten Dolmetscher hat. Wenn der Dolmetscher zusammen mit der Quelle geliefert werden muss, ist der Gesamtinstallationsprozess komplexer als die Lieferung eines mikroskopischen Exklusioners, da der Dolmetscher selbst Teil des Bedarfs ist. Die Tatsache, dass der Auslegungscode leicht lesbar und von Menschen kopiert werden kann, kann im Hinblick auf das Urheberrecht Anlass zur Sorge geben. Jedoch gibt es verschiedene Verschlüsselungs- und Verstopfungssysteme. Lieferung von Zwischencodes, wie beispielsweise Bytecode, hat ähnliche Auswirkungen auf die Verstopfung, aber durchtecode konnte mit einem Decompiler oder Disassembler entkoppelt werden. EffizienzDer Hauptnachteil der Dolmetscher ist, dass ein Dolmetschprogramm in der Regel langsamer läuft als wenn es zusammengestellt wurde. Die Differenz der Geschwindigkeiten könnte klein oder groß sein; oft eine Größenordnung und manchmal mehr. In der Regel dauert es länger, ein Programm unter einem Dolmetscher durchzuführen als der Zusammenstellungscode durchzuführen, aber es kann weniger Zeit dauern, es zu interpretieren als die Gesamtzeit, die für die Erstellung und Führung dieses Kodex erforderlich ist. Insbesondere ist dies wichtig, wenn Prototyp- und Testcodes, wenn ein Behandlungs-interpret-debug-Zyklus oft viel kürzer sein kann als ein anpassungs-compile-run-debug-Zyklus. Verdolmetschungscode ist langsamer als der Zusammenstellungscode, da der Dolmetscher jede Erklärung in dem Programm jedes Mal, wenn er ausgeführt wird und die gewünschte Maßnahme führt, analysieren muss, während der Zusammenstellungscode die Maßnahme nur innerhalb eines von der Erstellung festgelegten Rahmens durchführt. Diese Lebenszyklusanalyse ist als "interpretive Überbuchung" bekannt. Zugang zu Variablen ist auch langsamer in einem Dolmetscher, weil die Kartierung der Kennzeichen für Speicherstandorte wiederholt im Lauf der Zeit statt der Zeit erfolgen muss. Es gibt verschiedene Kompromisse zwischen der Entwicklungsgeschwindigkeit bei der Verwendung eines Dolmetschers und der Ausführungsgeschwindigkeit bei der Verwendung eines Sammlers. Manche Systeme (z.B. einige Lisps) erlauben es, miteinander zu kommunizieren und Variablen zu teilen. Dies bedeutet, dass, wenn eine Routine unter dem Dolmetschen getestet und gestrichen wurde, dass sie gesammelt werden kann und somit von einer schnelleren Ausführung profitieren können, während andere Routinen entwickelt werden. Viele Dolmetscher führen den Herkunftscode nicht durch, sondern verwechseln es in eine etwas besser einheitlichere Form. Viele GR-Darlehen ersetzen die Schlüsselwörter mit einzigen Aufschlägen, die verwendet werden können, um die Lehre in einem Sprungtisch zu finden. Manche Dolmetscher, wie der PBASIC Dolmeter, erreichen sogar höhere Programmdichten, indem sie eine Bitorientierung anstelle einer durchte-orientierten Programmspeicherstruktur verwenden, in der die Befehlsklemme vielleicht 5 Bits besetzen, werden nominal 16-bit-Konstante in einem variablen Längencode gespeichert, der 3, 6, 10 oder 18 Bits erfordert, und die Adresse der operationellen umfassen einen "bit-ausgleich". Viele GR-Darletscher können ihre eigene umgedrehte interne Darstellung speichern und lesen. Ein Dolmetscher könnte den gleichen lexical-Inspektor und  as als Sammler nutzen und dann den daraus entstehenden abstrakten Synthesebaum auswerten. Beispieldatentypdefinitionen für Letztere und ein Spielzeugverdolmetschunger für aus C Expressionen gewonnene Zellbäume werden in der Box dargestellt. Regression kann nicht als alleinige Methode der Ausführung verwendet werden: selbst wenn ein Dolmetscher selbst ausgelegt werden kann, und so ist ein direkt ausgeführtes Programm am unteren Ende des Knopfs erforderlich, weil der zu interpretierende Code nicht identisch mit dem Maschinencode ist, den die CPU ausführen kann. Variationen Bytecode- Dolmetscher Es gibt ein Spektrum von Möglichkeiten zwischen der Auslegung und dem Ausgleich, je nach Analyse, die vor Durchführung des Programms durchgeführt wurde. Emacs Lisp wird zum Beispiel an Bytecode zusammengefasst, das eine hochgepresste und optimierte Darstellung der Lisp-Quelle ist, ist aber nicht Maschinencode (und somit nicht an bestimmte Hardware gebunden). Dieser Zusammenstellungscode wird dann von einem Bytecode Interpretationer (einmal in C geschrieben) interpretiert. In diesem Fall ist der Zusammenstellungscode für eine virtuelle Maschine, die nicht in der Hardware, sondern im Bytecode Interpretationser verwendet wird. Solche Ausgleichsdolmetscher werden manchmal auch als Verbrecher bezeichnet. In einem Bytecode Dolmetschen beginnt jede Anleitung mit einem Byte, und daher müssen bis zu 256 Anweisungen verwendet werden, obwohl nicht alle benutzt werden können. Manche Bytecodes können mehrere Durchsätze übernehmen und können willkürlich kompliziert sein. Kontrolltabellen - die nicht notwendigerweise jemals über eine Ausgleichsphase übertragen werden müssen - erfordern einen angemessenen algorischen Kontrollfluss über maßgeschneiderte Dolmetscher in ähnlicher Weise wie Bytecode Dolmetscher. Taschencodedolmetscher Logierte Codedolmetscher sind ähnlich wie durchtecode-Darlehen, anstatt von Stellen, die sie verwenden. Jede Anleitung ist ein Wort, das auf eine Funktion oder eine Unterrichtssequenz verweist, möglicherweise gefolgt von einem Parameter. Der gefälschte Code interpretiert entweder die Fängen und ruft die Funktionen auf, die sie anweisen, oder holt die erste Anleitung ein und dringt auf, und jede Unterrichtssequenz endet mit einem Fänger und einem Sprung in die nächste Anleitung. Anders als durchtecode gibt es keine effektive Beschränkung auf die Anzahl unterschiedlicher Anweisungen, die nicht verfügbar sind, und den Raum zu lösen. Das klassische Beispiel des Gewindecodes ist der Forth-Code, der in offenen Betriebssystemen verwendet wird: Die Quellesprache wird in "F-Code" (ein Bytecode) zusammengefasst, der dann von einer virtuellen Maschine interpretiert wird. Taschenbilder Im Frequenzspektrum zwischen Dolmetschen und Ausgleich besteht ein weiterer Ansatz darin, den Herkunftscode in einen optimierten abstrakten Synthesebaum (AST) zu verwandeln, dann das Programm nach dieser Baumstruktur auszuführen oder zu verwenden, um den heimischen Code einfach ins Leben zu rufen. In diesem Ansatz muss jeder Satz nur einmal geteilt werden. Als Vorteil über Bytecode hält die AST die globale Programmstruktur und die Beziehungen zwischen den Aussagen (die in einer Bytecode-Vertretung verloren geht) und wenn sie eine kompaktere Darstellung bietet. So wurde die Verwendung von AST als besserer Zwischenformat für nur-in-time-Fern vorgeschlagen als durchtecode. Außerdem ermöglicht es das System eine bessere Analyse während der Laufzeit. Für Dolmetscher führt ein AST jedoch mehr als ein Bytecode Dolmetscher, da es sich um ein nicht sinnvolles Werk handelt, einer weniger sequentiellen Vertretung (erforderlichen Traversen von mehr Punktern) und der Überbuchung des Baums. Kurzinformation Mehr verwischt die Unterscheidung zwischen Dolmetschern, Bytecode-Ständen und Zusammenstellungen ist nur-in-time (JIT)-Zusammenarbeit, eine Technik, in der die Zwischenvertretung zum heimischen Maschinencode im Lauf der Zeit erstellt wird. Dies verleiht der Effizienz des inländischen Codes, zu den Kosten der Startzeit und einer verstärkten Speichernutzung, wenn der Bytecode oder AST zuerst erstellt werden. Der früheste veröffentlichte JIT-Gemeinschaftsbund wird im Jahr 1960 in der Regel auf LISP von John McCarthy zurückgeführt. Anpassungsoptimierung ist eine complementary Technik, bei der der Dolmetscher das laufende Programm ausweisen und seine am häufigsten ausgeführten Teile in den heimischen Code zusammengefasst. Letztere Technik ist ein paar Jahrzehnte alt, das in Sprachen wie Kleinen in den 80er Jahren erscheint. Just-in-time-Zusammenarbeit hat in den letzten Jahren eine durchgängige Aufmerksamkeit unter den Sprachausführern gewonnen, mit Java, dem .NET-Rahmen, den modernsten Implementierungen von JavaScript und Matlab, jetzt auch JIT-Gemeinschaften. Drehbuchverdolmetschunger Klärung der Unterscheidung zwischen Compilers und Dolmetschern ist noch immer noch mehr vage ein besonderes Auslegungsdesign, das als Drehbuchverdolmetschunger bekannt ist. Mehr als die Ausführung des Code durch eine große Rotationserklärung, die alle möglichen Bytecodes enthält, während sie auf einem Softwarestapel oder einem Baumgang betrieben wird, behält ein Musterverdolmetschunger eine große Bandbreite von Bytecode (oder eine effiziente Zwischenvertretung) vor, die direkt an die entsprechenden inländischen Maschinenanweisungen ausgerichtet ist, die auf der Host Hardware als Schlüsselpaar ausgeführt werden können, die als Vorlage bezeichnet werden. Wenn das bestimmtes Code-Segment ausgeführt wird, belastet der Dolmetscher einfach die opcode-Karte in der Vorlage und führt sie direkt auf der Hardware. Aufgrund seines Entwurfs ähnelt das Muster sehr stark einem Just-in-Time Compiler anstelle eines traditionellen Dolmetschers, doch ist es technisch nicht so, dass es nur den Code von der Sprache in einheimische Anrufe übersetzen lässt, anstatt optimierte Sequenzen der exekutiven Anleitung aus dem gesamten Code-Segment zu erstellen. Aufgrund des einfachen Entwurfs des Dolmetschers, die Anrufe direkt an die Hardware zu übertragen anstatt sie direkt durchzuführen, ist es viel schneller als jede andere Art, selbst durch Siecodedolmetscher und in geringerem Maße zu Fehlern, aber da ein Auslauf schwieriger ist, weil der Dolmetscher die Übersetzung auf mehrere verschiedene Architekturen anstelle einer unabhängigen virtuellen Plattform unterstützen muss. Bisher ist der einzige Drehbuchverdolmetschunger, der eine Sprache zur Verfügung stellt, der Dolmetscher innerhalb der HotSpot/OpenJDK Java virtuelle Maschinenbeschreibung. Selbstinterpreter Ein Selbstinterpreter ist eine Programmiersprache, die in einer Programmierungssprache geschrieben wird, die sich selbst ausbilden kann; ein Beispiel ist ein Dolmetscher, der in der Schrift geschrieben ist. Selbstinterpreters sind mit Selbstinterpretern verbunden. Liegt kein Pool für die zu interpretierende Sprache vor, erfordert die Einführung einer Selbstinterpreter-Sprache in einer Gastsprache (die möglicherweise eine andere Programmiersprache oder einen Pool sein kann). Indem sie einen ersten Dolmetscher wie dies haben, wird das System gestrichen und neue Versionen des Dolmetschers können in der Sprache selbst entwickelt werden. Donald Knuth entwickelte so den TANGLE Dolmetscher für die Sprache WEB des Systems der industriellen Norm TeX. Klärung einer Computersprache erfolgt in der Regel im Zusammenhang mit einer abstrakten Maschine (sogenannte operative semantische) oder als mathematische Funktion (denotative semantische). Eine Sprache kann auch von einem Dolmetscher definiert werden, in dem die semantischen der Aufnahmesprache angegeben sind. Die Definition einer Sprache durch ein Selbstinterpreter ist nicht begründet (es kann keine Sprache definieren), aber ein Selbstinterpreter gibt einen Leser über die Größe und die Echtheit einer Sprache. Er ermöglicht es dem Dolmetscher auch, seinen Herkunftscode, den ersten Schritt auf dem Weg zur reflektierenden Auslegung zu interpretieren. Eine wichtige Gestaltungsdimension bei der Umsetzung einer Selbstinterpreter ist, ob ein Merkmal der interpretierten Sprache mit dem gleichen Merkmal in der Gastsprache des Dolmetschers umgesetzt wird. Ein Beispiel ist, ob eine Schließung in einer Lisp-ähnlichen Sprache mit Schließungen in der Dolmetschen Sprache oder manuell mit einer Datenstruktur, die die Umwelt ausdrücklich schützt, durchgeführt wird. Je mehr die gleichen Merkmale in der Gastsprache umgesetzt werden, desto weniger kontrollieren die Programmperson des Dolmetschers; ein anderes Verhalten bei der Behandlung der Zahlüberflüsse kann nicht realisiert werden, wenn die aritmetischen Operationen an entsprechende Operationen in der Aufnahmesprache delegiert werden. Manche Sprachen wie Lisp und Prolog haben elegante Selbstinterpreter. In der Programmplanungssprache, einem Dialekt von Lisp, wurde viel Forschung auf Selbstinterpretern (insbesondere reflektierende Dolmetscher) durchgeführt. Insgesamt erlaubt jede Turing-vollständige Sprache jedoch die Schrift ihres eigenen Dolmetschers. Lisp ist eine solche Sprache, weil Lisp-Programme Listen von Symbolen und anderen Listen sind. XSLT ist eine solche Sprache, weil XSLT-Programme in XML geschrieben sind. Ein Teilbereich von Metaprogramming ist das Schreiben von bereichsspezifischen Sprachen (DSL).Clive Kubford hat eine Maßqualität von Selbstinterpreter (der Selbstinterpreter) eingeführt, die Begrenzung des Verhältnisses zwischen Computerzeit, die eine Mischung aus N-Selbstinterpretern und Zeit verbracht hat, um eine Mischung aus N − 1 Selbstinterpreter als N infinity zu betreiben. Dieser Wert hängt nicht von dem laufenden Programm ab. Die Buchstruktur und die Interpretation von Computerprogrammen zeigen Beispiele für die Meta-circular-Dimension für System und seine Dialekte. Andere Beispiele für Sprachen mit Selbstinterpreter sind Forth und Pascal. Microcode Microcode ist eine sehr häufig verwendete Technik, die einen Dolmetscher zwischen der Hardware und dem architektonischen Niveau eines Computers vorschreibt. Mikrocode ist also eine Schicht von Hardware-Auflagen, die in vielen digitalen Verarbeitungselementen auf höherer Ebene Maschinencode-Anweisungen oder internen staatlichen Maschinensequenzen durchführen. Microcode wird sowohl in der allgemeinen Zweckbestimmung der zentralen Verarbeitungseinheiten als auch in spezialisierten Prozessoren wie Mikro-Monitorer, Digital-Signal-Verarbeiter, Kanallotsen, Netzschnittstellen, Netzverarbeiter, Grafikverarbeitungseinheiten und anderen Hardware verwendet. Microcode ist in der Regel in einem speziellen Hochgeschwindigkeitsspeicher untergebracht und übersetzt Maschinenanweisungen, staatliche Maschinendaten oder andere Eingaben in Sequenzen von detaillierten Schaltaktionen. Es unterscheidet die Maschinenanleitung der zugrunde liegenden Elektronik, so dass Anweisungen konzipiert und frei verändert werden können. Sie erleichtert auch den Aufbau komplexer Multi-Level-Anweisungen und verringert gleichzeitig die Komplexität der Computerkreise. Mikrocode wird häufig als Mikroprogramm bezeichnet, und der Mikrocode in einem bestimmten Prozessor wird manchmal als Mikroprogramm bezeichnet. Mehr umfangreiche Mikrocodes ermöglichen kleine und einfache Mikrobausteine, um leistungsfähigere Architekturen mit breiterer Textlänge, mehr Ausführungseinheiten und damit eine relativ einfache Möglichkeit für die Kompatibilität der Software zwischen verschiedenen Produkten in einer Prozessorfamilie zu schaffen. Computerverarbeitung Selbst ein nicht-Mikrocode-Computer-Verarbeiter selbst kann als parsing sofortiger Ausführungsverdolmetschunger angesehen werden, der in einer allgemeinen Hardwarebeschreibungssprache wie VHDL geschrieben wird, um ein System zu schaffen, das die Maschinencode-Anweisungen entspricht und diese sofort ausgeführt. Anwendungen Dolmetscher werden häufig verwendet, um die Kommandosprachen auszuführen, und Klebstoffsprachen, da jeder in der Befehlssprache ausgeführte Betreiber in der Regel eine Unwiderhandlung eines komplexen Routinen wie ein Redakteur oder Einleger ist. Selbstmodifikationscode kann leicht in einer interpretierten Sprache umgesetzt werden. Dies betrifft die Herkunft von Dolp und künstlicher Intelligenzforschung. Virtualisierung. Maschinencode für eine Hardwarearchitektur kann mit einer virtuellen Maschine betrieben werden. Häufig wird dies verwendet, wenn die vorgesehene Architektur nicht verfügbar ist, oder unter anderen Verwendungen für die Durchführung mehrerer Kopien. Sandboxing: Während einige Arten von Sandboxen auf Betriebssystemschutz angewiesen sind, wird ein Dolmetscher oder virtuelle Maschinen häufig verwendet. Die tatsächliche Hardwarearchitektur und die ursprünglich vorgesehene Hardware-Architektur können oder können nicht gleich sein. Man kann vielleicht punktlos erscheinen, es sei denn, Sandboxen sind nicht verpflichtet, alle Anweisungen auszuführen, die sie verarbeiten. Insbesondere kann es sich ablehnen, Code auszuführen, der gegen jegliche Sicherheitszwänge verstößt, die es unternimmt. CHEM für die Durchführung von Computersoftware geschrieben für veraltete und nicht verfügbare Hardware auf moderneren Geräten. Siehe auch GRUND Auslegunger Befehls-line Dolmetscher Compiled Sprache Dynamische ZusammenstellungMeta-circular evaluator Partial Assessment Homoiconicity Referenzen Externe Links IBM Card Dolmetscherers Seite an der Columbia University Theoretische Stiftungen für praktische „Gesamtfunktionelle Programmierung“ ( 7 7 besonders) Doktoratologie befasst sich mit dem Problem der formalisierung, was ist ein Dolmetscher Short Animation, der den entscheidenden konzeptionellen Unterschied zwischen Dolmetschern und Künstlern erläutert.