Kademlia ist eine verteilte Hash-Tabelle für dezentrales Peer-to-Peer-Computernetzwerke, die 2002 von Petar Maymounkov und David Mazières entworfen wurden. Sie legt die Struktur des Netzes und den Informationsaustausch durch Node-Suchen fest. Kademlia nodes kommunizieren untereinander mit UDP.A virtuelles oder überlastetes Netz wird vom Teilnehmerknoten gebildet. Jeder Node wird von einer Nummer oder einer Node ID ermittelt. Die Node ID dient nicht nur als Identifikation, sondern der Kademlia-Algorithmus verwendet die Node ID, um Werte zu ermitteln (normalerweise ist die Datei Asche oder Stichwörter). In Wirklichkeit bietet die Node ID eine direkte Karte an, um die Asche aufzuhören und keine Informationen darüber zu speichern, wo die Datei oder Ressourcen erhalten. Bei der Suche nach einem gewissen Wert muss der Algorithmus den zugehörigen Schlüssel kennen und das Netzwerk in mehreren Schritten erkunden. Jeder Schritt wird nodes finden, die dem Schlüssel näher sind, bis die Kontaktperson den Wert zurückgibt oder keine näheren Knoten gefunden werden. Dies ist sehr effizient: wie viele andere DHT, Kademlia Kontakte nur O ( Log ⁡ ( ) ) Memedisplaystyle O(\log(n)} nodes während der Suche nach einer Gesamtzahl von n Memestyle n} Knoten im System. Insbesondere in der dezentralen Struktur werden weitere Vorteile festgestellt, die die Widerstandsfähigkeit gegen einen undienstlichen Anschlag erhöhen. Selbst wenn eine ganze Reihe von Knoten überflutet ist, wird dies nur begrenzte Auswirkungen auf die Netzverfügbarkeit haben, da das Netz sich durch das Aussetzen des Netzes um diese Löcher erholen wird. I2P-Durchführung von Kademlia wird geändert, um die Schwachstellen von Kademlia, wie Sybil-Angriffe, abzuschwächen. Systemdetails Peer-to-Peer-Netze bestehen aus Knoten, durch Design. Die Protokolle, die diese Knoten verwenden, um Informationen zu kommunizieren und zu finden, sind im Laufe der Zeit effizienter geworden. Die erste Generation von Peer-to-Peer-Datei-Sharing-Netzen, wie Napster, stützte sich auf eine zentrale Datenbank, um die Suche auf dem Netz zu koordinieren. Gruppennetzen der zweiten Generation, wie Gnutella, verwendeten Überschwemmungen, um Dateien zu finden und alle Node auf dem Netz zu suchen. Peer-to-Peer-Netze der dritten Generation, wie Bittorrent, verwenden distributed Hash-Tabellen, um Dateien im Netz zu untersuchen. Verteilte Hash-Tabellen speichern Ressourcen im gesamten Netz. Kademlia verwendet eine Fernberechnung zwischen zwei Knoten. Diese Entfernung wird als ausschließliche oder (XOR) der beiden Node ID berechnet, wobei das Ergebnis als ungedeckte Zahl gilt. Keys und Node IDs haben das gleiche Format und Länge, so dass die Entfernung zwischen ihnen genau so berechnet werden kann. Die Node ID ist in der Regel eine große zufällige Zahl, die mit dem Ziel ausgewählt wird, für einen bestimmten Node einzigartig zu sein (siehe UUID). Es kann und geschieht, dass geografisch weit voneinander entfernte Knoten – von Deutschland und Australien, beispielsweise – Nachbarn sind, wenn sie ähnliche zufällige Node IDs ausgewählt haben. Ausschließlich oder wurde gewählt, weil sie als Fernfunktion zwischen allen Node IDs fungiert. Konkret: Die Entfernung zwischen einem Node und selbst ist null, es ist symmetrisch: Die von A bis B und B bis A berechneten Entfernungen entsprechen dem Dreiecksungleich: Da A, B und C (Punkte) eines Dreiecks verwechselt sind, ist die Entfernung von A bis B kürzer als (oder gleich) die Summe der Entfernung von A bis C plus die Entfernung von C bis B. Diese drei Bedingungen reichen aus, um sicherzustellen, dass die Ausschließlichkeit oder die Erfassung aller wichtigen Funktionen, während sie einfach und einfach zu berechnen sind. Jede Kademlia-Suche ist etwas näher an das Ziel. Ein grundlegendes Kademlia-Netz mit 2n Knoten wird nur Schritte (im schlimmsten Fall) unternehmen, um zu finden. Festgelegte Größentabellen wurden in der vorgefertigten Fassung des Originalpapiers präsentiert und werden in der späteren Fassung nur für einige mathematische Nachweise verwendet. Eine tatsächliche Kademlia-Durchführung verfügt nicht über einen festen Standardplan, sondern eine dynamische Einheit. Kademlia-Strecken sind eine Liste für jeden Teil der Node ID.(z.B. wenn eine Node ID aus 128 Bits besteht, wird ein Node 128 solcher Listen halten). Eine Liste hat viele Beiträge. Jeder Eintrag in einer Liste hat die erforderlichen Daten, um einen anderen Node zu finden. Die Daten in jeder Liste sind in der Regel die IP-Adresse, der Hafen und die Node-ID eines anderen Node. Jede Liste entspricht einer bestimmten Entfernung vom Node. Nodes, die in die nth-Liste gehen können, muss ein unterschiedliches nth Bit von der Notde-ID haben; die ersten n-1 Bits der Kandidatenidenten müssen mit denen der Node-ID übereinstimmen. Dies bedeutet, dass es sehr einfach ist, die erste Liste als 1/2 der Knoten des Netzes zu verbreiten, weit wegfallend. Die nächste Liste kann nur 1/4 der Knoten im Netz (ein wenig näher als die erste) usw. verwenden. Mit einer ID von 128 Bits werden alle Knoten im Netz andere Knoten in einer von 128 verschiedenen Entfernungen, eine bestimmte Entfernung pro Bit, einstufen. Da keinedes auf dem Netz gefunden wird, werden sie in die Listen aufgenommen. Dazu gehört auch die Lagerung und die Rückgewinnung und sogar die Unterstützung anderer Knoten, um einen Schlüssel zu finden. Jeder Fall gilt für die Aufnahme in die Listen. Deshalb ist das Wissen, dass ein Knotennetz sehr dynamisch ist. Das Netz wird ständig aktualisiert und erhöht die Widerstandsfähigkeit gegenüber Misserfolgen oder Angriffen. In der Kademlia-Literatur werden die Listen als k-Gets.k bezeichnet, eine system breite Zahl wie 20. Jedes k-Get ist eine Liste mit bis zu k-Einsendungen innerhalb; d. h. für ein Netz mit k=20, jede Node wird Listen mit bis zu 20 Knoten für ein bestimmtes Bit (eine besondere Entfernung von sich) enthalten. Da die möglichen Knoten für jeden k-Güter schnell abnehmen (da es sehr wenige Knoten gibt, die schließen), werden die niedrigeren Bitk-Flotten alle Knoten in diesem Abschnitt des Netzes in vollem Umfang erfassen. Da die Menge möglicher IDs viel größer ist als jede node Population kann je sein, werden einige der k-Gets, die sehr kurze Entfernungen entsprechen, leer bleiben. Überlegungen zum einfachen Netz an. Die Netzgröße beträgt 2^3 oder acht Maximalschlüssel und Knoten. Es gibt sieben Knoten, die kleine Kreise am unteren Rand. Keiner der geprüften Fälle ist node 6 (binarische 110) in schwarz. In diesem Netz gibt es drei k-Güter. Nodes Null, ein und zwei (binarische 000, 001 und 010) sind Kandidaten für den weitesten k-Güter. Node 3 (binarische 011, nicht nachgewiesen) ist nicht am Netz beteiligt. In der mittleren K-Güter werden vier und fünf (bind 100 und 101) vergeben. Letztlich kann der dritte K-Güter nur node 7 enthalten (binarische 111). Jede der drei k-Gets ist in einem grauen Kreis untergebracht. Liegt die Größe des k-Güters zwei, so kann der weiteste 2-Get nur zwei der drei Knoten enthalten. Liegt es beispielsweise bei node sechs keine und zwei im weitesten 2-Greifer, müsste sie eine Node-ID-Aufsicht dieser Knoten beantragen, um den Standort (ip-Adresse) von node Null zu finden. Jeder Knoten kennt seine Nachbarschaft gut und hat Kontakt mit einigen wenigen Knoten weit entfernt, die dazu beitragen können, andere Knoten weit wegzufinden. Es ist bekannt, dass Knoten, die seit langem in einem Netz angeschlossen sind, wahrscheinlich lange in der Zukunft angebunden bleiben. Kademlia wählt wegen dieser statistischen Verteilung lange vernetzte Knoten aus, die in den k-Güter aufbewahrt werden. Dies erhöht die Zahl der bekannten gültigen Knoten in der Zukunft und sieht ein stabileres Netz vor. Wenn ein K-Get voll ist und ein neues Node für diesen k-Güter entdeckt wird, ist die zuletzt in der k-Greifet gefundene Undeklarheit PINGed. Wenn die Node noch lebendig ist, wird die neue Node in einer zweiten Liste, einem Ersatz-Cache, platziert. Der Ersatzfilter wird nur verwendet, wenn ein node in den k-Güter-Kranken stoppt. Mit anderen Worten: Neue Knoten werden nur verwendet, wenn ältere Knoten verschwinden. Protokollnachrichten Kademlia hat vier Botschaften. PING – Verwendung, um zu überprüfen, dass ein Node noch lebendig ist. PS – Stores a (key, value) Paar in einem node. FIND_NODE – Der Empfänger des Antrags wird die kknoten in seinen eigenen Taschen zurückgeben, die die nächsten sind. FIND_VAL -UE Wie FIND_NODE, aber wenn der Empfänger der Anfrage den geforderten Schlüssel in seinem Lager hat, wird er den entsprechenden Wert zurückgeben. Jede RPC-Nachricht enthält einen Zufallswert vom Initiator. Hierdurch wird sichergestellt, dass die Antwort, wenn die Antwort eingegangen ist, dem zuvor verschickten Ersuchen entspricht.(vgl. Läuft man die nodes Node-Prüfungen, so können sie sich als chronisch erweisen. Die Menge der gleichzeitigen Nachprüfungen wird durch α gebremst und ist in der Regel drei. Keinede eröffnet eine FIND_NODE-Anforderung, indem sie sich an die . Knoten in ihren eigenen k-Güter wenden, die die nächsten sind, auf den gewünschten Schlüssel. Wenn diese Begünstigten den Antrag erhalten, werden sie in ihren k-Güter schauen und die k nächsten Knoten zum gewünschten Schlüssel zurückgeben. Der Antragsteller wird eine Ergebnisliste mit den Ergebnissen (Abonne ID's) aktualisieren und die k besten (die k Knoten, die dem gesuchten Schlüssel näher sind) halten, die auf Anfragen reagieren. Dann wird der Antragsteller diese k besten Ergebnisse auswählen und den Antrag an sie richten und diesen Prozess erneut und wieder aufnehmen. Jedes Node verfügt über ein besseres Wissen über seine eigene Umgebung als jeder andere hat, die empfangenen Ergebnisse werden andere Knoten sein, die einander näher und näher an den gesuchten Schlüssel sind. Nach wie vor gibt es noch immer keine Knoten, die näher sind als die besten bisherigen Ergebnisse. Wenn die Iterations aufhören, sind die besten k nodes in der Ergebnisliste die im gesamten Netz, das der gewünschte Schlüssel ist, am nächsten. Die node Information kann mit runden Reisezeiten oder RTT erweitert werden. Diese Informationen werden verwendet, um für alle konsultierten Node eine bestimmte Zeit zu wählen. Wenn eine Abfragezeit ausläuft, kann eine weitere Abfrage eingeleitet werden, ohne gleichzeitig die α-Anfragen zu überschreiten. Zusammenführende Ressourceninformationen sind durch Kartierung auf einen Schlüssel. Asche wird in der Regel für die Karte verwendet. Die Speicherknoten werden aufgrund einer vorherigen Anmeldung Informationen haben. Ein Wert folgt dem gleichen Verfahren wie die Zuweisung der nächsten Knoten zu einem Schlüssel, außer wenn die Suche endet, wenn ein Node den geforderten Wert in seinem Speicher hat und diesen Wert zurückgibt. Die Werte werden in mehreren Knoten (k von ihnen) gespeichert, damit Knoten kommen und gehen können und noch der Wert in manchen node haben. Langfristig wird eine node, die einen Wert festlegt, das Netz erkunden, um die k Knoten zu finden, die in der Nähe des Schlüsselwerts liegen und den Wert auf sie replizieren. Ausgleich für verschwundene Knoten. Auch für populäre Werte, die viele Forderungen haben könnten, wird die Belastung im Speicherknoten verringert, indem man diesen Wert in einigen node in der Nähe, aber außerhalb der k nächsten lag. Diese neue Lagerung wird als Klär bezeichnet. In diesem Sinne wird der Wert je nach Anzahl der Anträge weitverbreitet und weitverbreitet. Dies ermöglicht eine schnellere Suche nach einem Speicher. Da der Wert von nodes weitther weg vom Schlüssel zurückgeführt wird, wird dies mögliche "Hotspots" mildern. Caching nodes wird den Wert nach einer bestimmten Zeit abziehen, je nach Entfernung vom Schlüssel. Manche Umsetzungen (z.B. Kad) verfügen nicht über Replizierung oder Kaching. Zweck ist es, alte Informationen schnell vom System zu entfernen. Die Node, die die Datei bereitstellt, wird die Informationen in regelmäßigen Abständen auf das Netz aktualisieren (perform FIND_NODE und Warnmeldungen). Wenn alle Nodes mit der Datei offline gehen, wird niemand seine Werte (Quellen und Stichwörter) wiederherstellen und die Informationen schließlich vom Netz verschwinden. Einbindung des Netzes Ein Knoten, der dem Netz beitreten möchte, muss zunächst über einen Sprint-Prozess gehen. In dieser Phase muss der beitretende Node die IP-Adresse und den Hafen eines anderen Node kennen – ein Bootstrap node (unter dem Nutzer oder aus einer gespeicherten Liste), die bereits am Kademlia-Netz teilnehmen. Wenn der Beitrittsknoten noch nicht an dem Netz beteiligt ist, berechnet er eine Zufalls-Identifikationsnummer, die aufgrund einer sehr großen zufälligen Zahl wahrscheinlich nicht ohne andere Node zugewiesen werden kann. Sie nutzt diese ID bis zum Verlassen des Netzes. Mit dem Beitrittsknotenpunkt wird der Bootstrap node zu einem seiner k-Güter eingefügt. Der Beitritt führt dann eine node-Bewertung seiner eigenen ID gegen die Bootstrap node (das einzige andere, es kennt). Mit der neuen Node ID wird die Selbstfestsetzung andere nodes' k-factets mit der neuen Node-ID behellen und das Zusammentreffen der node's k-factets mit den Knoten auf dem Weg zwischen diesem und dem Sprinttrap node begrüßen. Nach dieser Auffrischung stellt der Beitrittsknoten alle k-Güte weiter weg als die k-Güter, die Bootstrap node fällt. Diese Auffrischung ist nur ein Zufallsschlüssel, der in diesem k-Gangbereich liegt. Anfangs haben Knoten einen k-Güter. Wenn der K-Get voll wird, kann er aufgeteilt werden. Die Aufteilung findet statt, wenn die Palette der Knoten im K-Güter die eigene Glude (Werte auf den linken und rechts in einem binären Baum) umfasst. Kademlia lockert sogar diese Regel für den einzigen "Käden" k-Gache, weil in der Regel ein einziger Eimer der Entfernung entsprechen wird, in der alle Knoten, die am nächsten sind, können sie mehr als k sein, und wir wollen alle kennen. Man kann ausschließen, dass in der Nähe der Node ein stark unausgewogener binärer Unterpark besteht. K ist 20, und es gibt 21+ Knoten mit einer Prävalenz von xxx0011. und die neue Node ist xxx000011001, die neue Node kann mehrere k-Güter für die anderen 21+ Knoten enthalten. Man soll sicherstellen, dass das Netzwerk über alle Knoten in der nächsten Region weiß. Beschleunigte Nachprüfungen Kademlia verwenden eine XOR-Messe zur Bestimmung der Entfernung. Zwei Node ID oder eine Node ID und ein Schlüssel sind XORed und das Ergebnis ist die Entfernung zwischen ihnen. Bei jedem Bit kehrt die XOR-Funktion Null zurück, wenn die beiden Bits gleich sind und wenn die beiden Bits unterschiedlich sind. XOR-metrische Entfernungen halten das Dreieck ungleich: Da A, B und C (Punkte) eines Dreiecks sind, ist die Entfernung von A bis B kürzer als (oder gleich) die Entfernung von A bis C zu B. Die XOR-Messe erlaubt Kademlia, die Streckentabellen über einzelne Bits hinaus auszuweiten. Gruppen von Bits können in k-Gets platziert werden. Die Gruppe der Bits wird als Präferenz bezeichnet. Für einen m-bit-Vorschlag gibt es 2m-1 k-Gets. Die fehlende K-Get ist eine weitere Erweiterung des Liniesbaums, der die Node ID enthält. Ein m-bit-Vorschlag verringert die maximale Anzahl von Nachprüfungen von Log2 n bis Log2m n. Es handelt sich um Höchstwerte und der durchschnittliche Wert wird deutlich geringer sein, wodurch die Chance erhöht wird, einen Knoten in einem k-Güter zu finden, der mehr als nur den Vorsatz mit dem Zielschlüssel teilt. Nodes kann Mischungen von Vorschüssen in ihrem Fahrplan verwenden, wie das von eMule verwendete Kad-Netz. Das Kademlia-Netz könnte sogar auf Kosten der Komplementierung der Analyse von Sehnen heterogen sein. akademische Bedeutung Obwohl die XOR-Messe nicht erforderlich ist, um Kademlia zu verstehen, ist sie in der Analyse des Protokolls kritisch. XOR arithmetic ist eine abelianische Gruppe, die eine geschlossene Analyse ermöglicht. Andere DHT-Protokolle und Algorithmen erfordern eine Simulation oder komplizierte formale Analyse, um das Netzverhalten und die Richtigkeit vorherzusagen. Mit Hilfe von Gruppen von Bits werden auch die Algorithmen vereinfacht. mathematische Analyse des Algorithmus Um den Algorithmus zu analysieren, betrachten Sie ein Kademlia-Netz von n {\displaystyle n} Knoten mit IDs x 1 , ... , x n displaystyle x_{1},\ldots ,x_{n} , von denen jeder eine Reihe von Länge d Memestyle d} ist, die nur solche und Null enthält. Man kann als Trie konzipiert werden, in dem jedes Blatt einen Node darstellt, und der markierte Weg von der Wurzel bis zu einem Blatt stellt seine ID dar. Für einen Node x { x 1 , ... , x n } displaystyle x\in x_{1},\ldots ,x_{n\} , lassen D i ( x ) {\displaystyle Meme mathematisch D D_{i}(x) das Set von Knoten (IDs) sein, die mit x Colastyle x} Länge d - i style d-i}  k  i . . . . . . . . . . .  i . . . . . .  i . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  T x y WELLstyle T_{xy} ist eine Reihe von Schritten, die erforderlich sind, um aus dem Blatt x {\displaystyle x} zu einem Ziel ID y displaystyle y} zu gehen.Assuming that x 1 , ... x n {\displaystyle x_{1},\ldots ,x_{n} werden deterministisch von { 0, 1 } }  0,1d } nachgewiesen, dass sup x 1, x 1 x  ..., x  ...  1  1  1  1,  1  1  1  1,  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1 x_{n,,\sup {_y\in 0,1}}\ {E} [T_{xy}]\leq 1+o(1) nHH_{k, wo H k Memestyle H_{k} die k displaystyle k} -thHarmonic Number. Seit H k / Log ⁡ k → 1 Memestyle H_{k}/\log k\to 1} als k → {\ {\displaystyle k\to \infty }, wenn k {\displaystyle k} groß ist E T x y {\displaystyle \bb \th {E} T_{xy} ist von oben an Log k .  n KINGstyle \log {_k}n , aber die IDs und das Ziel werden ausgewählt. Es ist gerechtfertigt, dass in Kademlia nur O ( Log   n ) Memestyle O(\log n)} Knoten bei der Suche nach einem Zielknoten kontaktiert werden. Um das Modell näher zu echten Kademlia-Netzen zu machen, x 1 , ... , x n {\displaystyle x_{1},\ldots ,x_{n} kann auch ohne Ersatz aus { 0 { 0 , 1 } d } e .Dien können nachgewiesen werden, dass für alle x  be { x 1 }, x n } x  x x  x x 1 x 1 1 1 1 1 1 1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1 P frac WELLlog ncc_{k}}},\\ &\logbb {E} ncc_{k}}},\end{align, wo c k {\displaystyle c_{k} konstant ist, je nachdem, ob nur k {\displaystyle k} mit c k / H k → 1 {\displaystyle c_{k}/H_{k}\to 1} als k →   WELLdisplaystyle k\to \infty }. K {\displaystyle k} groß, E T x y / Log k ⁡ n {\displaystyle \th {E} T_{xy} {_k}n konvergiert auf eine ständige nahe 1 {\displaystyle 1} Dies bedeutet, dass die Zahl der Knoten bei der Suche nach einem Zielknotenpunkt tatsächlich . ( Log k ⁡ n ) Memestyle \Theta (\log {_k}n) im Durchschnitt ist. Kademlia wird in Datei-Sharing-Netzen verwendet. Indem Kademlia Schlüsselsuchungen macht, kann man Informationen im Datei-Sharing-Netz finden, damit es heruntergeladen werden kann. Da es keine zentrale Instanz gibt, einen Index der vorhandenen Dateien zu speichern, ist diese Aufgabe sogar unter allen Kunden aufgeteilt: Wenn ein Node eine Datei teilen möchte, verarbeitet er den Inhalt der Datei, berechnet von ihm eine Nummer (hash), die diese Datei innerhalb des Datei-Sharing-Netzes identifizieren wird. Die Papiere und die Node ID müssen von derselben Länge sein. Er sucht dann mehrere Knoten, deren ID in der Nähe des Hash liegt, und hat seine eigene IP-Adresse, die bei diesen Knoten gespeichert ist.i.e sie veröffentlicht sich als Quelle für diese Datei. Kademlia wird die Suche nach dem Netz für die node nutzen, deren ID die kleinste Entfernung zur Datei hat, dann die in diesem Fall gespeicherte Liste der Quellen entnehmen. Da ein Schlüsselwert viele Werte, z.B. viele Quellen derselben Datei, entsprechen kann jede Lagerung von Node verschiedene Informationen. Dann werden die Quellen von allen k Knoten nahe dem Schlüssel angefordert. Die Datei ist in der Regel aus einer speziell gebildeten Internet Magnetverbindung, die anderswo gefunden wird oder in einer Indexierungsdatei aus anderen Quellen enthalten ist. Dateiname Suche wird mit Stichwörtern durchgeführt. Der Name der Datei ist in seine Worte unterteilt. Jeder dieser Stichwörter ist zusammen mit dem entsprechenden Dateiname und dem Dossier im Netz untergebracht und gespeichert. Eine Suche beinhaltet die Wahl eines der Stichwörter, die Kontaktperson mit einer ID in der Nähe dieses Stichworts und die Wiederaufnahme der Liste der Namen, die das Schlüssel enthalten. Seit jedem in der Liste enthaltenen Aktenname ist die ausgewählte Datei auf normale Weise erhältlich. Implementierungsnetze Öffentliche Netze mit dem Kademlia-Algorithmus (diese Netze sind mit einem anderen unvereinbar): I2P: eine anonyme Netzschicht. Kad Network: ursprünglich von der eMule-Gemeinschaft entwickelt, um die Serverarchitektur des eDonkey-Netzes zu ersetzen. Kerstin: Das Protokoll über die Entdeckung von Node in der VMware-Netzstapel basiert auf einer leicht geänderten Umsetzung von Kademlia. Overnet: Mit KadC ist eine C-Bibliothek für den Umgang mit der Kademlia verfügbar.(Die Entwicklung von Overnet wird beendet) Mainline DHT: ein DHT für BitTorrent auf der Grundlage einer Umsetzung des Kademlia-Algorithmus für spurlose Flucken. Osiris (alle Version): zur Verwaltung des verteilten und anonymen Webportals verwendet. Retroshare:F2F dezentralisierte Kommunikationsplattform mit sicherer VOIP, sofortiger Nachrichtenübermittlung, Übertragung von Dateien usw. Tox: ein vollständig verteiltes Nachrichten-, VoIP- und Video-Chat-Plattform Gnutella DHT: ursprünglich von Kalzium zur Ausweitung des Gnutella-Protokolls für die Suche nach alternativen Dateistandorten, die jetzt von anderen gnutella-Kunden genutzt werden. IPFS: ein auf libp2p basierendes System von Peer-to-Peer verteilt. TeleHash: ein Netzwerkprotokoll, das Kademlia nutzt, um direkte Verbindungen zwischen den Parteien zu lösen. iMule: datei-Sharing-Software für I2P. OpenDHT: Bibliothek mit Durchführung von Kademlia, die von Jami und anderen genutzt wird. GNUnet: alternatives Netzmodul für den Bau sicherer, dezentraler und datenschutzgeschützter verteilter Anwendungen. Verwenden Sie randomisierte Version von Kademlia R5NDat: ein auf dem Protokoll von Hypercore basierendes Peer-to-Peer-Datei-Sharing. Siehe auch Content-Adresseables Network Chord (DHT) Bandstry(DHT) Pastry (DHT) Koorde Referenzen Externe Links Xlattice-Projekte Kademlia Spezifikation und Definitionen. Paketpilferage ist der Diebstahl eines Teils des Inhalts eines Pakets. Sie kann auch den Diebstahl des Inhalts umfassen, aber das Paket verlassen, vielleicht mit Scheininhalten wiederaufgenommen. Kleine Pakete können aus einem größeren Paket wie einem Schiffscontainer abgeleitet werden. Mehr und damit zusammenhängende Aspekte des Paket Diebstahls können unter anderem das gesamte Paket, die Palettenlast, die Last des LKWs, den Ladentransport usw. umfassen. Der Diebstahl kann an jedem beliebigen Punkt in der Reise von der Quelle zum Zielort stattfinden, einschließlich der Diebstahl von Logistikmitarbeitern und Zollagenten in internationalen Postszenarien. Lösungen umfassen alle Phasen der Produktproduktion, Verpackung, Vertrieb, Logistik, Verkauf und Verwendung. Keine einzige Lösung gilt als „Präfer-Test“. Häufig haben Verpackungsingenieure, Logistikingenieure und Sicherheitsfachleute mehrere Sicherheitsstufen angesprochen, um das Risiko von Kläranlagen zu verringern. Jede Situation ist einzigartig. Manche Erwägungen enthalten: Identifizierung, wer ein potenzieller pilferer sein könnte: ein interner Mitarbeiter, Sicherheitsschutz, LKW-Fahrer, Lieferperson, Empfänger (Konflikt), organisierte Kriminalität usw. Ingenieure beginnen in der Regel mit dem Know-how, Werkstoffen, Werkzeugen usw.might. Ermittlung möglicher Methoden des unerlaubten Zugangs zu einem Produkt, Paket oder System. Neben den Haupteintrittsmitteln betrachten Ingenieure auch sekundäre oder "Backtür"-Methoden. Identifizierung der verfügbaren Mittel zur Wiederauffüllung, zur Wiederauffüllung oder zur Ersetzung besonderer Robben. Verwendung zusätzlicher starker und sicherer Verpackungen: Ein schwaches oder beschädigtes Paket ist eine Einladung zur Ausweisung. in Erwägung von einzigartigen Zollsiegeln und -etiketten (die sich regelmäßig ändern, weil diese Fälschungen unterliegen)Utilisierung obligatorischer Paketverfolgungs-Scans in jeder Phase des Versandverfahrens, um das Paket für verdächtige Aktivitäten zu überwachen; beide Absender und Empfänger können dann den Status des Pakets über ein Spur- und Rückverfolgungssystem überprüfen. Verbesserung der pilferentilität, um die Kläranlage schwieriger, zeitaufwändig usw. zu machen. Identität und Wert eines pilferierbaren Gegenstands. Logistik- und Verpackungsfachleute möchten nicht auf den Punkt, sein Paket, Adressen, Namen usw. aufmerksam machen. Hinzufügen von pilfer-evidenten Merkmalen, um die Existenz von Klärchen zu erkennen. wählen Sie einen Logistikanbieter, der die Risiken von Klaufer verringern kann. Transport in Paketen mit Stückladung oder in intermodalen Transportbehältern mit Sicherheitssiegeln Aufklärung der Menschen zum Nachweis von Klaufering. Mit einer Wellpappebox mit einem breiteren und stärkeren Schließungsband, 3-Zoll- oder 72 mm, einem verstärkten Gummi- oder Druckband. Verwendung eines speziellen Sicherheitsbandes oder Versiegelung auf Verpackungen, die eine Botschaft, Warnung oder andere Angabe, wenn sie entfernt sind. Einrichtung eines Überwachungssystems zur Identifizierung von Verdächtigen. Siehe auch die Echtheitsprüfung (Gesetz)Los Prevention Retail Verlustvorbeugung Sicherheitsbeutel Tamper-evidenten Referenzen Soroka, W, "Fundamentals of Packaging Technology", IoPP, 2002, ISBN 1-930268-25-4 Yam, K. L, "Geschichte der Verpackungstechnik", John Kuhn & Sons, 2009 ISBN: 0,4-470-087-6 Rose, J., "Improving Tamper-Ev Packaging: Probleme, Tests und Lösungen", Philip Cook (2007). Sicherheit und Verlustverhütung: Einführung (5. ed). Butterworth-Heinemann.ISBN UV0-12-3725-7.Alan Greggo; Millie Kresitsch (2009). Konfliktverhütung: Probleme und Lösungen.KRK Presse.ISBN: +1-4200-9006-2.