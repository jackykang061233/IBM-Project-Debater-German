Der Linux-Kernel ist ein freier und offener, monolithischer, modularer, multitasking, Unix-ähnlicher Betriebssystem-Kernel. Es wurde 1991 von Linus Torvalds für seinen i386-basierten PC konzipiert und erstellt, und es wurde bald als Kernel für das GNU-Betriebssystem angenommen, das als freier Ersatz für UNIX geschaffen wurde. Seitdem hat es eine große Anzahl von Betriebssystem-Distributionen, häufig auch Linux genannt. Linux wird auf einer Vielzahl von Computersystemen eingesetzt, wie eingebettete Geräte, mobile Geräte (einschließlich deren Nutzung im Android-Betriebssystem), Personal Computer, Server, Mainframes und Supercomputer. Es kann auf bestimmte Architekturen und für mehrere Nutzungsszenarien mit einer Familie von einfachen Befehlen (d.h. ohne manuelle Bearbeitung seines Quellcodes vor der Erstellung) zugeschnitten werden; privilegierte Benutzer können auch feintune Kernel-Parameter zur Laufzeit. Der größte Teil des Linux-Kernel-Codes wird mit den GNU-Erweiterungen von GCC auf die Standard-C-Programmiersprache und unter Verwendung von architekturspezifischen Anweisungen (ISA) geschrieben. Dadurch ergibt sich eine hochoptimierte ausführbare (vmlinux) hinsichtlich der Ausnutzung von Speicherraum und Aufgabenausführungszeiten. Tages-zu-Tage-Entwicklungsgespräche finden auf der Linux-Kernel-Mailingliste (LKML) statt. Änderungen werden mit der Versionssteuerung git verfolgt, die von Torvalds als maßgeschneiderter Ersatz für BitKeeper erstellt wurde. Linux als Ganzes wird unter der GNU General Public License Version 2 (GPLv2,) veröffentlicht, aber es enthält auch mehrere Dateien unter anderen kompatiblen Lizenzen, und eine Ad-hoc-Befreiung für die User Space API Header Dateien (UAPI.) Geschichte Im April 1991 begann Linus Torvalds, damals 21-jähriger Informatikstudent an der Universität Helsinki, Finnland, an einfachen Ideen für ein Betriebssystem zu arbeiten. Er begann mit einem Aufgabenschalter in der Montagesprache Intel 80386 und einem Terminaltreiber. Am 25. August 1991 veröffentlichte Torvalds folgendes auf comp.os.minix, eine Newsgroup auf Usenet: Ich mache ein (kostenloses) Betriebssystem (nur ein Hobby, wird nicht groß und professionell wie gnu) für 386(486)AT Klone. Dies ist seit April gebrüht und beginnt, sich vorzubereiten. Ich möchte jedes Feedback zu Dingen, die Menschen mögen oder sich in Minix, wie mein Betriebssystem es etwas ähnelt (gleiche physische Layout des Dateisystems (aus praktischen Gründen) unter anderem). Ich habe gerade Bash(1.08) und Gcc(1.40) portiert und die Dinge scheinen zu funktionieren. Das bedeutet, dass ich innerhalb von wenigen Monaten etwas Praktisches bekommen werde.][Ja - es ist frei von jedem Minix-Code, und es hat eine Multi-Threaded fs. Es ist NICHT protable [sic] (verwendet 386 Task Switching etc,) und es wird wahrscheinlich nie etwas anderes als AT-harddisks unterstützen, wie das alles, was ich habe .(-: Am 17. September 1991, Torvalds vorbereitet Version 0,01 von Linux und auf den ftp.funet.fi - FTP-Server der finnischen Universität und Forschungsnetzwerk (FUNET). Es war nicht einmal ausführbar, da sein Code noch Minix für Compilation und Spielen benötigte. Am 5. Oktober 1991 gab Torvalds die erste offizielle Version von Linux bekannt, Version 0.02. An dieser Stelle konnte Linux Bash, GCC und einige andere GNU-Dienste ausführen:[As] Ich habe vor einem Monat erwähnt, ich arbeite an einer kostenlosen Version eines Minix-lookalike für AT-386-Computer. Es hat endlich die Bühne erreicht, wo es sogar nutzbar ist (obwohl nicht abhängig von dem, was Sie wollen,) und ich bin bereit, die Quellen für eine breitere Verteilung herauszubringen. Es ist nur Version 0.02... aber ich habe erfolgreich Bash, gcc, gnu-make, gnu-sed, Komprimierung, etc. unter ihm laufen. Danach trugen viele Leute Code zum Projekt bei, darunter einige Entwickler der MINIX-Community. Zu der Zeit hatte das GNU-Projekt viele der für ein kostenloses Betriebssystem benötigten Komponenten erstellt, aber sein eigener Kernel, GNU Hurd, war unvollständig und nicht verfügbar. Die Berkeley Software Distribution hatte sich noch nicht von Rechtsumständen befreit. Trotz der begrenzten Funktionalität der frühen Versionen, Linux schnell gewonnen Entwickler und Benutzer. Torvalds hat dem Kernel die Version 0 zugewiesen, um anzuzeigen, dass es hauptsächlich zum Testen und nicht für den produktiven Einsatz bestimmt war. Version 0.11, veröffentlicht im Dezember 1991, war der erste selbstgehostete Linux, denn es könnte von einem Computer mit demselben Kernel kompiliert werden. Als Torvalds Version 0.12 im Februar 1992 veröffentlichte, nahm er die GNU General Public License Version 2 (GPLv2) über seine frühere selbstverbaute Lizenz an, die keine kommerzielle Umverteilung erlaubt hatte. Im Gegensatz zu Unix sind alle Quelldateien von Linux frei verfügbar, darunter Gerätetreiber. Der erste Erfolg von Linux wurde von Programmierern und Testern auf der ganzen Welt angetrieben. Mit Unterstützung der POSIX APIs konnte Linux durch das libC, das, ob erforderlich, als Einstiegspunkt in den Kernel-Adressenraum fungiert, Software und Anwendungen ausführen, die für Unix entwickelt wurden. Am 19. Januar 1992 wurde der erste Post an die neue Newsgroup alt.os.linux eingereicht. Am 31. März 1992 wurde die Nachrichtengruppe comp.os.linux umbenannt. Die Tatsache, dass Linux ein monolithischer Kern und nicht ein Mikrokern ist, war das Thema einer Debatte zwischen Andrew S. Tanenbaum, dem Schöpfer von MINIX und Torvalds. Die Tanenbaum-Torvalds-Debatte begann 1992 mit der Usenet-Gruppe comp.os.minix als allgemeine Diskussion über Kernelarchitekturen. Linux-Version 0.95 war der erste, der das X Window System ausführen konnte. Im März 1994 wurde Linux 1.0.0 mit 176.250 Zeilen Code veröffentlicht. Es war die erste Version, die für den Einsatz in Produktionsumgebungen geeignet war. Es startete ein Versioning-System für den Kernel mit drei oder vier Zahlen, die durch Punkte getrennt wurden, in denen die erste die große Veröffentlichung darstellte, die zweite war die kleinere Veröffentlichung, und die dritte war die Revision. Zu dieser Zeit waren ungeradzahlige kleinere Releases für Entwicklung und Tests, während sogar nummerierte kleinere Releases für die Produktion waren. Die optionale vierte Ziffer gab eine Reihe von Patches zu einer Revision an. Mit -rc ("Release-Kandidat") Suffix wurden Entwicklungsfreigaben angegeben. Die aktuelle Versionsnummerierung unterscheidet sich von oben etwas. Die sogar vs. ungerade Nummerierung wurde abgenommen und eine bestimmte Hauptversion wird nun durch die ersten beiden Zahlen als Ganzes angezeigt. Während der Zeitrahmen für die Entwicklung des nächsten Majors offen ist, wird der -rcN-Suffix verwendet, um den n'th Release-Kandidat für die nächste Version zu identifizieren. So wurde der Version 4.16 beispielsweise sieben 4.16-rcN vorangestellt (von -rc1 bis -rc7). Sobald eine stabile Freigabe erfolgt, wird die Wartung an das „stabile Team“ weitergegeben. Die betrieblichen Aktualisierungen von stabilen Releases werden durch ein drei Nummerierungsschema (z.B. 4.13.1, 4.13.2, ..., 4.13.16) identifiziert. Nach Version 1.3 des Kernels entschied Torvalds, dass Linux genug entwickelt hatte, um eine neue große Zahl zu garantieren, so dass er Version 2.0.0 im Juni 1996 veröffentlicht. Die Serie beinhaltete 41 Releases. Das Hauptmerkmal von 2.0 war die Unterstützung für symmetrische Multiverarbeitung (SMP) und Unterstützung für mehr Arten von Prozessoren. Starten mit Version 2.0, Linux ist konfigurierbar für die Auswahl bestimmter Hardware-Ziele und für die Aktivierung von architekturspezifischen Features und Optimierungen. Die make *config-Familie von Befehlen von kbuild wird verwendet, um Tausende von Optionen für den Aufbau von ad hoc Kernel ausführbare (vmlinux) und beladbare Module zu aktivieren und zu konfigurieren. Version 2.2, veröffentlicht am 20. Januar 1999, verbesserte Verriegelungsgranularität und SMP-Management, fügte m68k, PowerPC, Sparc64, Alpha und andere 64-Bit-Plattformen Unterstützung. Darüber hinaus hat es neue Dateisysteme hinzugefügt, einschließlich Microsofts NTFS-Read-Only-Fähigkeit. 1999 veröffentlichte IBM seine Patches auf den Linux 2.2.13-Code für die Unterstützung der S/390-Architektur. Version 2.4.0, veröffentlicht am 4. Januar 2001, enthielt Unterstützung für ISA Plug and Play, USB und PC-Karten. Linux 2.4 fügte Unterstützung für die Pentium 4 und Itanium hinzu (letztere führte die ia64 ISA, die gemeinsam von Intel und Hewlett-Packard entwickelt wurde, um die ältere PA-RISC zu übertreffen), und für den neueren 64-Bit MIPS Prozessor. Die Entwicklung für 2.4.x änderte sich ein bisschen, indem mehr Funktionen während der gesamten Dauer der Serie zur Verfügung gestellt wurden, einschließlich Unterstützung für Bluetooth, Logical Volume Manager (LVM) Version 1, RAID-Unterstützung, InterMezzo und ext3 Dateisysteme. Version 2.6.0 wurde am 17. Dezember 2003 veröffentlicht. Die Entwicklung für 2.6.x änderte sich weiter in Richtung neue Features während der gesamten Dauer der Serie. Unter den in der 2.6-Serie vorgenommenen Änderungen sind: Integration von μClinux in die Mainline-Kernelquellen, PAE-Unterstützung, Unterstützung von mehreren neuen CPU-Leitungen, Integration von Advanced Linux Sound Architecture (ALSA) in die Mainline-Kernelquellen, Unterstützung von bis zu 232 Anwendern (bis zu 216) Unterstützung für bis zu 229 Prozess-IDs (nur 64-bit, 32-Bit-Bogene) Bemerkenswert sind auch die Hinzufügung einer großen Auswahl an Dateisystemen, die mit den 2.6.x-Versionen beginnen: jetzt unterstützt der Kernel eine große Anzahl von Dateisystemen, einige, die für Linux entwickelt wurden, wie ext3, ext4, FUSE, Btrfs und andere, die aus anderen Betriebssystemen wie JFS, XFS, Minix, Xenix, Irix, Solaris, System V, Windows und MS-DOS stammen. Im Jahr 2005 wurde das stabile Team als Reaktion auf den Mangel an Kernelbaum gebildet, wo Menschen an Bugfixes arbeiten könnten, und es würde stabile Versionen aktualisieren. Im Februar 2008 wurde der Linux-next-Baum geschaffen, um als Ort zu dienen, an dem sich Patches während des nächsten Entwicklungszyklus zusammenfügen sollen. Mehrere Subsystem-Betreuer nahmen auch die Suffix -next für Bäume mit Code an, die sie für die Aufnahme in den nächsten Release-Zyklus einreichen. Ab Januar 2014 findet die in-Entwicklung Version von Linux in einem instabilen Zweig namens linux-next statt. Linux wurde ohne Hilfe eines automatisierten Quellcode-Management-Systems beibehalten, bis 2002 die Entwicklung auf BitKeeper umgestellt wurde. Es war frei für Linux-Entwickler verfügbar, aber es war nicht freie Software. Im Jahr 2005 hat das Unternehmen, das die Software besaß, die Unterstützung der Linux-Gemeinschaft aufgehoben. Als Reaktion schrieben Torvalds und andere Git. Das neue System wurde innerhalb von Wochen geschrieben, und in zwei Monaten wurde der erste offizielle Kernel mit ihm gemacht. Details zur Geschichte der 2.6-Kernel-Serie finden Sie in den ChangeLog-Dateien auf dem Quellcode-Release-Bereich der 2.6-Kernel-Serie von kernel.org. Der 20. Jahrestag von Linux wurde von Torvalds im Juli 2011 mit der Veröffentlichung der 3.0.0-Kernel-Version gefeiert. Da 2.6 die Versionsnummer für 8 Jahre war, musste dem Kernel eine neue uname26 Persönlichkeit hinzugefügt werden, die 3.x als 2.6.40+x meldet, damit alte Programme funktionieren würden. Version 3.0 wurde am 22. Juli 2011 veröffentlicht. Am 30. Mai 2011 kündigte Torvalds an, dass die große Veränderung "NOTHING" sei. Absolut nichts."und fragte: "Wir stellen sicher, dass wir die nächste Veröffentlichung nicht nur eine neue glänzende Zahl, sondern auch ein guter Kernel machen. " Nach den erwarteten 6–7 Wochen des Entwicklungsprozesses würde es nahe dem 20. Jahrestag von Linux veröffentlicht werden. Am 11. Dezember 2012 hat Torvalds beschlossen, die Kernel-Komplexität zu reduzieren, indem die Unterstützung für i386 Prozessoren entfernt wird und die 3.7 Kernel-Serie die letzte, die noch den ursprünglichen Prozessor unterstützt. Die gleiche Serie einheitliche Unterstützung für den ARM-Prozessor. Version 3.11, veröffentlicht am 2. September 2013, fügt viele neue Features wie neue O_TMPFILE-Flag für open(2) hinzu, um temporäre Dateiverwundbarkeiten, experimentelle AMD Radeon dynamisches Power-Management, Low-Latency-Netzwerk-Umfrage und zswap (komprimierte Swap-Cache) zu reduzieren. Die Nummerierung änderte sich von 2.6.39 auf 3,0 und von 3.19 auf 4,0, keine aussagekräftige technische Differenzierung. Die große Versionsnummer wurde erhöht, um große kleinere Zahlen zu vermeiden. Stable 3.x.y Kernels wurden bis 3.19 im Februar 2015 veröffentlicht. Im April 2015 veröffentlichte Torvalds Kernel Version 4.0. Bis Februar 2015 hatte Linux Beiträge von fast 12.000 Programmierern von mehr als 1.200 Unternehmen erhalten, darunter einige der weltweit größten Software- und Hardware-Anbieter. Version 4.1 von Linux, veröffentlicht im Juni 2015, enthält über 19.5 Millionen Zeilen Code von fast 14.000 Programmierern beigetragen. Insgesamt 1,991 Entwickler, von denen 334 erste Mitarbeiter sind, mehr als 553,000 Zeilen Code zu Version 5.8 hinzugefügt, brechen den Datensatz zuvor von Version 4.9 Nach der jährlichen Developer Survey von Stack Overflow von 2019 haben mehr als 53% aller Befragten Software für Linux OS und etwa 27% für Android entwickelt, obwohl nur etwa 25% mit Linux-basierten Betriebssystemen entwickeln. Die meisten Websites laufen auf Linux-basierten Betriebssystemen, und alle der weltweit 500 mächtigsten Supercomputer nutzen eine Art Betriebssystem basierend auf Linux. Linux-Distributionen bündeln den Kernel mit Systemsoftware (z.B. GNU C Library, systemd, and other Unix utilities and daemons) und einer breiten Auswahl an Anwendungssoftware, aber deren Nutzungsanteil an Desktops ist im Vergleich zu anderen Betriebssystemen gering. Android, die für die meisten der installierten Basis aller Betriebssysteme für mobile Geräte verantwortlich ist, ist für die steigende Nutzung des Linux-Kernels verantwortlich, zusammen mit seiner breiten Verwendung in einer Vielzahl von eingebetteten Geräten. Architektur und Features Linux ist ein monolithischer Kernel mit modularem Design (z.B. kann er belastbare Kernelmodule zur Laufzeit einfügen und entfernen), der die meisten Features einmal nur in geschlossenen Quellkernen von nicht-freien Betriebssystemen zur Verfügung stellt. Der Rest des Artikels nutzt die UNIX- und Unix-ähnliche Betriebssystemkonvention auf den offiziellen Handseiten. Die Befehls-, Schnittstellen- und andere Funktionen sind dazu bestimmt, den Abschnitt (assii.e, die Art der OS-Komponente oder -Funktion) anzugeben, zu dem sie gehören (z.B. execve(2) bezieht sich auf einen Systemruf, während exec(3) auf einen Benutzer-Hyperspace-Bibliotheks-Wrapper bezieht) Sicherheitsmechanismen für die Ermessens- und Pflichtzugriffskontrolle (SELinux, AppArmor, POSIX ACLs und andere); mehrere Arten von geschichteten Kommunikationsprotokollen (einschließlich der Internet-Protokoll-Suite). Gerätetreiber und Kernelerweiterungen laufen im Kernel-Raum (Ring 0 in vielen CPU-Architekturen), mit vollem Zugriff auf die Hardware, obwohl einige Ausnahmen im Benutzerraum laufen, zum Beispiel Dateisysteme basierend auf FUSE/CUSE und Teile von UIO. Das Grafiksystem, das die meisten Menschen mit Linux verwenden, läuft nicht innerhalb des Kernels. Im Gegensatz zu Standard-Monolith-Kernels sind Gerätetreiber einfach als Module konfiguriert und während des Betriebs des Systems geladen oder entladen und können auch unter bestimmten Bedingungen vorveröffentlicht werden, um Hardware-Interrupts richtig zu handhaben und die symmetrische Multiverarbeitung besser zu unterstützen. Linux hat nach Wahl keine stabile Gerätetreiber-Anwendung binäre Schnittstelle. Linux nutzt typischerweise den Speicherschutz und den virtuellen Speicher und kann auch den ungleichmäßigen Speicherzugriff handhaben, das Projekt hat jedoch μClinux absorbiert, was es auch ermöglicht, Linux auf Mikrocontrollern ohne virtuellen Speicher auszuführen. Die Hardware ist in der Dateihierarchie dargestellt. Benutzeranwendungen interagieren mit Gerätetreibern über Einträge in den /dev oder /sys Verzeichnissen. Prozessinformationen werden auch über das /proc-Verzeichnis in das Dateisystem abgebildet. Schnittstellen Linux ist ein Klon von UNIX und zielt auf POSIX und Single UNIX Spezifikation Compliance. Der Kernel bietet auch Systemanrufe und andere Linux-spezifische Schnittstellen. Um in den offiziellen Kernel aufgenommen zu werden, muss der Code eine Reihe von Lizenzierungsregeln erfüllen. Die Linux Application binäre Schnittstelle (ABI) zwischen dem Kernel und dem Benutzerraum hat vier Grad der Stabilität (Tabelle, Tests, veraltet, entfernt;) aber die Systemanrufe werden erwartet nie ändern, um die Benutzerspace-Programme, die auf sie verlassen nicht zu brechen. Loadable-Kernel-Module (LKMs,) von Design, können sich nicht auf einen stabilen ABI verlassen. Daher müssen sie immer wieder kompiliert werden, wenn ein neuer Kernel ausführbar in einem System installiert ist, sonst werden sie nicht geladen. In-tree-Treiber, die als integraler Bestandteil des ausführbaren Kernels (vmlinux) ausgebildet sind, werden durch den Bauprozess statisch verknüpft. Es gibt auch keine Garantie für die Stabilität der Source-Level-In-Kernel-API und deshalb, Gerätetreiber-Code, sowie den Code eines anderen Kernel-Subsystems, muss mit Kernel-Entwicklung aktualisiert werden. Jeder Entwickler, der eine API-Änderung macht, ist erforderlich, um jeden Code zu beheben, der durch seine Änderung bricht. Kernel-to-userspace API Der Satz der Linux-Kernel-API, der die Benutzeranwendungen ausgesetzten Schnittstellen betrachtet, besteht grundsätzlich aus UNIX- und Linux-spezifischen Systemanrufen. Ein Systemaufruf ist ein Einstiegspunkt in den Linux-Kernel. Beispielsweise gibt es unter den Linux-spezifischen die Familie der clone(2) Systemanrufe. Die meisten Erweiterungen müssen aktiviert werden, indem das GNU_SOURCE-Makro in einer Header-Datei definiert wird oder wenn der User-land-Code kompiliert wird. Systemanrufe können nur mit Montageanleitungen aufgerufen werden, die den Übergang vom nichtprivilegierten Benutzerraum zum privilegierten Kernelraum im Ring 0 ermöglichen. Aus diesem Grund fungiert die C-Standard-Bibliothek (libC) als Wrapper für die meisten Linux-Systemanrufe, indem C-Funktionen, die nur, ob sie benötigt wird, transparent in den Kernel eingeben können, der im Namen des Aufrufprozesses ausgeführt wird. Für diese von libC nicht belichteten Systemaufrufe, z.B. den schnellen Userspace-Mutex (futex), bietet die Bibliothek eine Funktion namens syscall(2), mit der sie explizit aufgerufen werden können. Pseudo-Dateisysteme (z.B. die sysfs und procfs-Dateisysteme) und spezielle Dateien (z.B. dev/random, dev/sda, dev/tty und viele andere) stellen eine andere Ebene der Schnittstelle zu Kernel-Datenstrukturen dar, die Hardware- oder logische (Software)-Geräte repräsentieren.Kernel-to-userspace ABI Aufgrund der Unterschiede zwischen den Hunderten von verschiedenen Implementierungen des Linux OS, ausführbare Objekte, auch wenn sie kompiliert, montiert und für den Betrieb auf einer bestimmten Hardware-Architektur (d.h. sie verwenden die ISA der Ziel-Hardware), oft nicht auf verschiedenen Linux-Distributionen laufen. Dieses Problem ist vor allem auf verteilungsspezifische Konfigurationen und eine Reihe von Patches, die auf den Code des Linux-Kernels, Unterschiede in Systembibliotheken, Diensten (Dämonen,) Dateisystemhierarchien und Umgebungsvariablen angewendet werden. Der Hauptstandard für die Anwendung und binäre Kompatibilität von Linux Distributionen ist die Linux Standard Base (LSB). Allerdings geht der LSB über das, was den Linux-Kernel betrifft, hinaus, weil er auch die Desktop-Spezifikationen, die X-Bibliotheken und Qt definiert, die wenig damit zu tun haben. Die LSB-Version 5 basiert auf mehreren Standards und Entwürfen (POSIX, SUS, X/Open, File System Hierarchy (FHS,) und anderen). Die für den Kernel weitgehend relevanten Teile des LSB sind das Allgemeine ABI (gABI), insbesondere das System V ABI und das ausführbare und verlinkende Format (ELF) und das Processor Specific ABI (psABI), beispielsweise die Core Specification für X86-64. Der Standard ABI, wie x86_64 Benutzerprogramme Systemanrufe anrufen, ist das Laden der Syscall-Nummer in das Rasterregister und die anderen Parameter in rdi, rsi, rdx, r10, r8 und r9 und schließlich die Syscall Montageanleitung in den Code. In-Kernel APIEs gibt mehrere Kernel interne APIs zwischen den verschiedenen Subsystemen verwendet. Einige sind nur innerhalb der Kernel-Subsysteme verfügbar, während ein etwas begrenzter Satz von In-Kernel-Symbolen (d.h. Variablen, Datenstrukturen und Funktionen) auch dynamisch belastbaren Modulen (z.B. auf Anfrage geladene Gerätetreiber) ausgesetzt ist, ob sie mit den EXPORT_SYMBOL() und EXPORT_SYMBOL_GPL() Makros exportiert werden (die letzteren vorbehalten, um Module Lizenzen unter einem GPL-kompatiblen zu können). Linux bietet in-Kernel-APIs, die Datenstrukturen manipulieren (z.B. verknüpfte Listen, Radien, rotschwarze Bäume, Warteschlangen) oder gemeinsame Routinen ausführen (z.B. Kopierdaten von und zu Benutzerraum, Speicher zuordnen, Druckleitungen zum Systemprotokoll usw.), die zumindest seit der Linux-Version 2.6 stabil geblieben sind. In-Kernel APIs umfassen Bibliotheken von Low-Level-Common Services, die von Gerätetreibern verwendet werden: SCSI Schnittstellen und libATA – bzw. ein peer-to-peer-Paketbasiertes Kommunikationsprotokoll für an USB, SATA, SAS, Fibre Channel, FireWire, ATAPI-Gerät angeschlossene Speichergeräte und eine in-Kernel-Bibliothek zur Unterstützung von [S]ATA-Host-Controllern und -Geräten. Direct Rendering Manager (DRM) und Kernel Mode Setting (KMS) – zum Wechseln mit GPUs und zur Unterstützung der Bedürfnisse moderner 3D-beschleunigter Videohardware und zur Einstellung von Bildschirmauflösung, Farbtiefe und Aktualisierungsrate DMA-Puffer (DMA-BUF) – zum Austausch von Puffern für Hardware-Direktspeicherzugriff über mehrere Gerätetreiber und Subsysteme Video4Linux – für Video-Capture Hardware Advanced Linux Sound Architecture Module, die für eine bestimmte Version des Kernels kompiliert werden, können nicht in eine andere Version geladen werden, ohne erneut kompiliert zu werden, vorausgesetzt, dass die Quellebene in-Kernel API geblieben ist, ansonsten muss auch der Modulcode entsprechend geändert werden. Prozesse und Threads Linux erstellt Prozesse mittels des Klons(2) oder durch die neueren clone3(2) Systemaufrufe. Je nach den gegebenen Parametern kann die neue Einheit die meisten oder keine der Ressourcen des Anrufers teilen. Diese Syscalls können neue Entitäten erstellen, die von neuen unabhängigen Prozessen (jeweils mit einer speziellen Kennung namens TGID innerhalb der Task_struct-Datenstruktur im Kernelraum, obwohl diese Kennung im Benutzerraum PID genannt wird) bis zu neuen Ausführungsfäden innerhalb des rufenden Prozesses (durch den CLONE_THREAD-Parameter). In diesem letzteren Fall besitzt das neue Unternehmen die gleiche TGID des Aufrufprozesses und hat somit auch die gleiche PID im Benutzerraum. Wenn die ausführbare Verbindung mit freigegebenen Bibliotheken dynamisch erfolgt, wird ein dynamischer Linker (für ELF-Objekte ist es typischerweise lib/ld-linux.so.2) verwendet, um die benötigten Objekte zu finden und zu laden, das Programm zu starten und dann auszuführen. Der Native POSIX Thread Library, einfach als NPTL bekannt, stellt die Standard-POSIX-Gewinde-Schnittstelle (Ptthreads) auf den Benutzerbereich zur Verfügung. Wenn ein neuer Thread mit der pthread_create(3) POSIX-Schnittstelle erstellt wird, muss die clone(2)-Familie von Systemanrufen auch die Adresse der Funktion erhalten werden, auf die der neue Thread springen muss. Der Linux-Kernel bietet die futex(7) (Acronym für "Fast user-space mutexes") Mechanismen zur schnellen Benutzer-Raum-Verriegelung und Synchronisation; die meisten Operationen werden im Benutzerraum durchgeführt, aber es kann notwendig sein, mit dem Kernel über den futex(2)-Systemaufruf zu kommunizieren. Eine ganz besondere Fadenkategorie sind die sogenannten Kernelfäden. Sie dürfen nicht mit den oben genannten Ausführungsfäden der Prozesse des Benutzers verwechselt werden. Kernelfäden existieren nur im Kernelraum und ihr einziger Zweck besteht darin, Kernelaufgaben gleichzeitig auszuführen. Anders ausgedrückt, wenn ein unabhängiger Prozess erstellt wird, kommen die Syscalls genau in die nächste Anweisung desselben Programms zurück, gleichzeitig im Elternprozess und im Kind (d.h. ein Programm, zwei Prozesse). Verschiedene Rückgabewerte (eines pro Prozess) ermöglichen es dem Programm zu wissen, in welchem der beiden Prozesse es derzeit ausgeführt wird. Programme benötigen diese Informationen, weil der Kinderprozess, ein paar Schritte nach der Prozessvervielfältigung, in der Regel den execve(2) Systemaufruf (möglicherweise über die Familie der exec(3) Wrapper-Funktionen in glibC) anruft und das Programm ersetzt, das derzeit durch den Anrufprozess mit einem neuen Programm, mit neu initialisierten Stack-, Heap- und (initialisierten und uninitialisierten) Datensegmenten betrieben wird. Wenn es fertig ist, führt es zu zwei Prozessen, die zwei verschiedene Programme ausführen. Abhängig von der effektiven Benutzer-ID (euid,) und der effektiven Gruppen-ID (z.B.) kann ein Prozess, der mit Benutzer-Null-Privilegien (root, der Systemadministrator, besitzt die Kennung 0) läuft, alles ausführen (z.B. alle anderen Prozesse töten oder wiederkehrend ganze Dateisysteme auslöschen), anstatt nicht Null-Benutzerprozesse können die Privilegien(7) durch den Superuser in verschiedene Einheiten unabhängig voneinander getrennt werden können. Regelung und Befreiung Der Linux Scheduler ist modular, in dem Sinne, dass es verschiedene Terminierungsklassen und Richtlinien ermöglicht. Schedulerklassen sind steckbare Scheduler-Algorithmen, die mit dem Basisplaner-Code registriert werden können. Jede Klasse terminiert verschiedene Arten von Prozessen. Der Kerncode des Schedulers iteriert über jede Klasse in der Reihenfolge der Priorität und wählt den höchsten Prioritätsplaner, der eine schedulable Einheit des Typs struct sched_entity bereit zu laufen hat. Entitäten können Fäden, Fadengruppen und sogar alle Prozesse eines bestimmten Benutzers sein. Linux bietet sowohl Benutzerpreemption als auch vollständige Kernelvorgabe. Preemption reduziert die Latenz, erhöht die Reaktionsfähigkeit und macht Linux für Desktop- und Echtzeitanwendungen besser geeignet. Für normale Aufgaben verwendet der Kernel standardmäßig die in der 2.6.23-Version des Kernels eingeführte Klasse „Computly Fair Scheduler (CFS). Intern wird diese Standard-Scheduler-Klasse in einem Makro eines C-Headers als SCHED_NORMAL definiert. In anderen POSIX-Kernels ordnet eine ähnliche, als SCHED_OTHER bezeichnete Politik CPU-Timeslices an (d.h. es gibt absolute Scheiben der Prozessorzeit in Abhängigkeit von einer vorgegebenen oder dynamisch berechneten Priorität jedes Prozesses). Die Linux-CFS nimmt mit absoluten Timlices ab und ordnet einen fairen Anteil an CPU-Zeit in Abhängigkeit von Parametern wie der Gesamtzahl der Runnable-Prozesse und der Zeit, die sie bereits ausgeführt haben; diese Funktion berücksichtigt auch eine Art Gewicht, das von ihren relativen Prioritäten (Nice-Werte) abhängt. Mit Benutzervorgabe kann der Kernel Scheduler den aktuellen Prozess durch die Ausführung eines Kontextschalters zu einem anderen ersetzen, der somit die Rechenressourcen für den Betrieb (CPU, Speicher und mehr) erwirbt. Es macht es nach dem CFS-Algorithmus (insbesondere verwendet es eine Variable namens Vruntime für Sortiereinheiten und wählt dann diejenige, die die kleinere Vruntime hat, - d.h. die schedulable Einheit, die den geringsten Anteil an CPU-Zeit hatte), zur aktiven Scheduler-Politik und zu den relativen Prioritäten. Mit Kernelvorgabe kann sich der Kernel vorschreiben, wenn ein Interrupt-Handler zurückgibt, wenn Kernel-Aufgaben blockieren und wenn ein Subsystem die Schedule()-Funktion explizit anruft. Der Kernel enthält außerdem zwei POSIX-konforme Echtzeit-Schedulingklassen mit dem Namen SCHED_FIFO (realtime first-in-first-out) und SCHED_RR (realtime round-robin), die beide der Standardklasse vorausgehen. In der Kernel-Version 3.14, die am 30. März 2014 veröffentlicht wurde, wurde eine zusätzliche Schieduling-Richtlinie, die als SCHED DEADLINE bekannt ist, zur Umsetzung des ersten Algorithmus (EDF) hinzugefügt. Der Linux-Kernel-Patch PREEMPT_RT ermöglicht die vollständige Vorgabe von kritischen Abschnitten, Unterbrechern und "unterbrechenden Deaktivieren"-Codesequenzen. Die Teilintegration der Echtzeit-Luxinux-Patches brachte die oben erwähnte Funktionalität zur Kernel-Mainline. Konkurrenz und Synchronisation Der Kernel hat verschiedene Ursachen für Konkurrenz (z.B. Interrupts, Bodenhälften, Präemption von Kernel- und Benutzeraufgaben, symmetrische Multiverarbeitung). Zum Schutz kritischer Bereiche (Sektionen von Code, die atomisch ausgeführt werden müssen), gemeinsame Speicherplätze (wie globale Variablen und andere Datenstrukturen mit globalem Umfang), und Bereiche des Speichers, die durch Hardware asynchron modulierbar sind (z.B. mit C volatile Type Qualifier), bietet Linux eine große Menge an Werkzeugen. Sie bestehen aus atomaren Typen (die nur von einem Satz von bestimmten Operatoren manipuliert werden können), Spinlocks, Semaphoren, Mutexes und sperrlose Algorithmen (z.B. RCUs). Die meisten sperrlosen Algorithmen sind auf Speicherbarrieren aufgebaut, um die Speicherbestellung zu zwingen und unerwünschte Nebenwirkungen durch Compiler-Optimierungen zu verhindern. Geschäftsführung Die Verwaltung der Unterbrechungen, obwohl sie als Einzelarbeit betrachtet werden konnte, ist in zwei getrennte Teile unterteilt. Diese Aufteilung in zwei ist auf die unterschiedlichen Zeitzwänge und auf die Synchronisation Bedürfnisse der Aufgaben zurückzuführen, deren Management besteht. Der erste Teil besteht aus einer asyncronous Interrupt-Service-Routine, die in Linux als obere Hälfte bekannt ist, während der zweite Teil von einer von drei Arten der sogenannten unteren Hälften (softirq, Tasklets und Arbeitswarteschlangen) durchgeführt wird. Linux unterbricht Service-Routinen können geschachtelt werden (d.h. ein neuer IRQ kann in eine hohe Priorität ISR einfallen, die jede andere untere Priorität ISR vorschreibt.) Speicherverwaltung Speicherverwaltung in Linux ist ein komplexes Thema. Zunächst ist der Kernel nicht praktikabel (d.h. er ist immer im physischen Speicher wohnhaft und kann nicht auf die Festplatte getauscht werden). Im Kernel gibt es keinen Speicherschutz (keine SIGSEGV-Signale, anders als im Benutzerraum), daher führen Speicherverletzungen zu Instabilität und Systemabstürzen. Linux implementiert virtuellen Speicher mit 4 und 5-Levels-Seitentabellen. Wie gesagt, ist nur der Speicherplatz des Benutzers immer abrufbar. Es hält Informationen über jeden Seitenrahmen von RAM in Apposite-Datenstrukturen (der Typ struct-Seite), die sofort nach Stiefeln besiedelt werden und die bis zum Abschalten gehalten werden, unabhängig davon, ob sie mit virtuellen Seiten verbunden sind oder nicht. Darüber hinaus klassifiziert sie alle Seitenrahmen in Zonen, entsprechend ihrer architekturabhängigen Zwänge und der beabsichtigten Verwendung. Zum Beispiel sind für DMA-Operationen reservierte Seiten in ZONE_DMA, Seiten, die nicht dauerhaft auf virtuelle Adressen abgebildet werden, sind in ZONE_HIGHMEM (in x86_32 Architektur ist diese Zone für physikalische Adressen über 896 MB, während x86_64 sie nicht benötigt, weil x86_64 physische Seiten, die in höheren Adressen leben, dauerhaft abbilden kann) und alles, was (mit Ausnahme anderer weniger genutzter Klassifikationen NORM) in ZONE_ ist. Kleine Speicherblöcke können über die Familie von kmalloc() dynamisch zugewiesen werden API und befreit mit der entsprechenden Variante von kfree().vmalloc und kvfree() werden für große praktisch zusammenhängende chunks.alloc_pages() verwendet, die die gewünschte Anzahl von ganzen Seiten zuordnet. Unterstützte Architekturen Obwohl nicht ursprünglich als tragbare konzipiert, ist Linux jetzt einer der am weitesten verbreiteten Betriebssystemkerne, die auf einer Vielzahl von Systemen von der ARM-Architektur zu IBM z/Architektur Mainframe-Computern laufen. Der erste Hafen wurde auf der Motorola 68000 Plattform ausgeführt. Die Änderungen am Kernel waren so grundlegend, dass Torvalds die Motorola-Version als Gabel und ein "Linux-ähnliches Betriebssystem" betrachtete. Das bewegte Torvalds jedoch, um eine größere Struktur des Codes zu führen, um die Portierung zu mehr Computerarchitekturen zu erleichtern. Der erste Linux, der allein in einem einzigen Quellbaum Code für mehr als i386 hatte, unterstützte die DEC Alpha AXP 64-Bit-Plattform. Linux läuft als wichtigstes Betriebssystem auf IBM's Summit; ab Oktober 2019 laufen alle weltweit 500 schnellsten Supercomputer ein Betriebssystem basierend auf dem Linux-Kernel, eine große Änderung von 1998, als der erste Linux-Supercomputer in die Liste aufgenommen wurde. Linux wurde auch auf verschiedene Handgeräte wie Apples iPhone 3G und iPod portiert. Unterstützte Geräte 2007 wurde das LKDDb-Projekt gestartet, um eine umfassende Datenbank von Hardware und Protokollen zu erstellen, die von Linux-Kernels bekannt sind. Die Datenbank wird automatisch durch statische Analyse der Kernelquellen erstellt. Später im Jahr 2014 wurde das Linux Hardware-Projekt gestartet, um automatisch eine Datenbank aller getesteten Hardware-Konfigurationen mit Hilfe von Benutzern verschiedener Linux-Distributionen zu sammeln. Live Patching Rebootless-Updates können sogar auf den Kernel angewendet werden, indem Sie Live-Patch-Technologien wie Ksplice, kpatch und kGraft verwenden. Minimalistische Grundlagen für Live-Kernel-Patching wurden in die Linux-Kernel-Mainline in Kernel-Version 4.0 zusammengefasst, die am 12. April 2015 veröffentlicht wurde. Diese Grundlagen, die als Livepatch bekannt sind und vor allem auf der ftrace-Funktionalität des Kernels basieren, bilden einen gemeinsamen Kern, der sowohl kGraft als auch kpatch das Hot Patching unterstützen kann, indem eine Anwendungs-Programmierschnittstelle (API) für Kernel-Module bereitgestellt wird, die Hot-Patches und eine Applikations-Binärschnittstelle (ABI) für die Benutzerspace-Management-Dienstprogramme enthalten. Der in Linux-Kernel 4.0 enthaltene gemeinsame Kern unterstützt jedoch nur die x86-Architektur und bietet keine Mechanismen zur Sicherstellung der Funktionsebenenkonsistenz während der Anwendung der Hot-Patches. Ab April 2015 gibt es laufende Arbeiten an der Portierung von kpatch und kGraft zum gemeinsamen Live-Patch-Kern der Linux-Kernel-Mainline. Security Kernel Bugs präsentieren mögliche Sicherheitsprobleme. Sie können beispielsweise eine Privilegeskalation zulassen oder Denial-of-Service Angriffsvektoren erstellen. Im Laufe der Jahre wurden zahlreiche Fehler gefunden und behoben. Zur Verbesserung der Sicherheit des Kernels werden häufig neue Funktionen implementiert. Fähigkeiten(7) wurden bereits im Abschnitt über die Prozesse und Fäden eingeführt. Android nutzt sie und systemd gibt Administratoren detaillierte Kontrolle über die Fähigkeiten der Prozesse. Linux bietet eine Vielzahl von Mechanismen, um Kernel-Angriffsoberfläche zu reduzieren und Sicherheit zu verbessern, die gemeinsam als Linux Security Module (LSM) bekannt sind. Sie umfassen das Modul Security-Enhanced Linux (SELinux), dessen Code ursprünglich von der NSA entwickelt und anschließend veröffentlicht wurde, und AppArmor unter anderem. SELinux wird nun aktiv auf GitHub entwickelt und gepflegt. SELinux und AppArmor unterstützen den Zugang zu den Sicherheitsrichtlinien, einschließlich der obligatorischen Zugriffskontrolle (MAC), obwohl sie sich in Komplexität und Umfang stark unterscheiden. Ein weiteres Sicherheitsmerkmal ist die Seccomp BPF (SECure COMPuting with Berkeley Packet Filters), die durch Filterung von Parametern arbeitet und die Menge der Systemaufrufe für Benutzer-Land-Anwendungen reduziert. Kritiker haben Kernelentwickler angeklagt, Sicherheitslücken zu verdecken, oder sie zumindest nicht zu verkünden; 2008 reagierte Linus Torvalds darauf mit folgenden Worten: Ich persönlich betrachte Sicherheitsfehler nur als "normale Fehler". Ich vertusche sie nicht, aber ich habe auch keinen Grund, warum es eine gute Idee ist, sie zu verfolgen und sie als etwas Besonderes zu verkünden... einen Grund Ich weigere mich, mit dem gesamten Sicherheitszirkus zu stören, ist, dass ich glaube, es verherrlicht – und damit fördert – das falsche Verhalten. Es macht Helden aus Sicherheitsleuten, als ob die Menschen, die nicht nur normale Fehler beheben, nicht so wichtig sind. Tatsächlich sind alle langweiligen normalen Bugs viel wichtiger, nur weil es viel mehr von ihnen gibt. Ich glaube nicht, dass ein spektakuläres Sicherheitsloch verherrlicht oder gepflegt werden sollte, da es etwas Besonderes ist als ein zufälliger spektakulärer Absturz durch schlechte Verriegelung. Linux-Distributionen veröffentlichen in der Regel Sicherheitsupdates, um Schwachstellen im Linux-Kernel zu beheben. Viele bieten langfristige Support-Releases, die Sicherheits-Updates für eine bestimmte Linux-Kernel-Version für einen längeren Zeitraum erhalten. Entwicklung Entwickler-Community Die Community von Linux-Kernel-Entwicklern umfasst rund 5000–6000 Mitglieder. Laut dem "2017 State of Linux Kernel Development", einer Studie der Linux Foundation, die die Verpflichtungen für die Releases 4.8 bis 4.13 abdeckt, trugen rund 1500 Entwickler von rund 200-250 Unternehmen im Durchschnitt bei. Die Top 30 Entwickler trugen etwas mehr als 16% des Codes bei. Bei den Unternehmen handelt es sich um Intel (13,1%) und Red Hat (7,2%) Linaro (5,6,%) IBM (4.1,%), der zweite und fünfte Platz wird von der keine (8,2%) und unbekannt (4.1%) Kategorien gehalten. Anstelle einer Roadmap gibt es technische Richtlinien. Anstelle einer zentralen Ressourcenzuweisung gibt es Personen und Unternehmen, die alle an der Weiterentwicklung des Linux-Kernels beteiligt sind, ganz unabhängig voneinander: Menschen wie Linus Torvalds und ich plane die Kernelentwicklung nicht. Wir sitzen nicht dort und denken die Roadmap für die nächsten zwei Jahre, dann Ressourcen den verschiedenen neuen Funktionen zuweisen. Das liegt daran, dass wir keine Ressourcen haben. Die Ressourcen sind alle im Besitz der verschiedenen Unternehmen, die zu Linux verwenden und beitragen, sowie der verschiedenen unabhängigen Beiträge da draußen. Es sind diejenigen, die die Ressourcen besitzen, die entscheiden. Quellcode-Management Die Linux-Entwicklungsgemeinde nutzt Git, um den Quellcode zu verwalten. Git-Nutzer klonen die neueste Version von Torvalds' Baum mit git-clone(1) und halten es auf dem neuesten Stand mit git-pull(1). Beiträge werden als Patches in Form von Textnachrichten auf der LKML eingereicht (und oft auch auf anderen Mailinglisten, die bestimmten Subsystemen gewidmet sind). Die Patches müssen einer Reihe von Regeln und einer formalen Sprache entsprechen, die unter anderem beschreibt, welche Codezeilen gelöscht werden sollen und was andere den angegebenen Dateien hinzugefügt werden sollen. Diese Patches können automatisch verarbeitet werden, so dass Systemadministratoren sie anwenden können, um nur einige Änderungen am Code vorzunehmen oder auf die nächste Version inkremental zu aktualisieren. Linux wird auch in GNU zip (gzip) und bzip2 Formaten vertrieben. Code auf den Kernel übertragen Ein Entwickler, der den Linux-Kernel ändern will, beginnt mit der Entwicklung und Prüfung, die sich ändern. Je nachdem, wie signifikant die Änderung ist und wie viele Subsysteme sie verändert, wird die Änderung entweder als einzelne Patch oder in mehreren Patches des Quellcodes eingereicht. Bei einem einzigen Teilsystem, das von einem einzigen Betreuer gehalten wird, werden diese Patches als E-Mail an den Betreuer des Teilsystems mit der entsprechenden Mailingliste in Cc gesendet.Der Betreuer und die Leser der Mailingliste werden die Patches überprüfen und Feedback abgeben. Sobald der Überprüfungsprozess abgeschlossen ist, akzeptiert der Subsystembetreuer die Patches in dem betreffenden Git Kernelbaum.Wenn die Änderungen am Linux-Kernel Fehlerbehebungen sind, die als wichtig genug angesehen werden, wird innerhalb von wenigen Tagen eine Zuganforderung für die Patches an Torvalds gesendet. Ansonsten wird während des nächsten Zusammenschlussfensters eine Zuganforderung an Torvalds gesendet. Das Merge-Fenster dauert in der Regel zwei Wochen und beginnt sofort nach der Freigabe der vorherigen Kernel-Version. Der Git-Kernel-Quellenbaum nennt alle Entwickler, die zum Linux-Kernel im Credits-Verzeichnis beigetragen haben und alle Subsystem-Betreuer sind in Maintainers aufgeführt. Programmiersprache und Kodierungsstil Linux wird in einer speziellen C-Programmiersprache geschrieben, die von GCC unterstützt wird, einem Compiler, der in vielerlei Hinsicht den C-Standard erweitert, z.B. unter Verwendung von in der Montagesprache (in der AT&T-Stil-Syntax) der Zielarchitektur geschriebenen Inline-Abschnitten des Codes. Seit 2002 muss der gesamte Code den 21 Regeln des Linux Kernel Coding Styles entsprechen. GNU toolchain Die GNU Compiler Collection (GCC oder GNU cc) ist der Standard-Compiler für die Mainline Linux-Quellen und wird von einem Dienstprogramm namens make aufgerufen. Dann gibt der GNU Assembler (mehr oft GAS oder GNU as) die Objektdateien aus dem GCC generierten Montagecode aus. Schließlich wird die GNU Linker (GNU ld) verwendet, um eine statisch verknüpfte ausführbare Kerneldatei namens vmlinux zu erzeugen. Sowohl als auch ld sind Teil von GNU Binary Utilities (binutils). Die oben genannten Werkzeuge werden gemeinsam als GNU-Toolchain bezeichnet. Compiler Kompatibilität GCC war für eine lange Zeit der einzige Compiler in der Lage, Linux richtig zu bauen. Im Jahr 2004 behauptete Intel, den Kernel geändert zu haben, so dass sein C-Compiler auch in der Lage war, ihn zu kompilieren. 2009 gab es einen weiteren so gemeldeten Erfolg mit einer geänderten Version 2.6.22. Seit 2010 ist es anstrengend, Linux mit Clang zu bauen, einem alternativen Compiler für die C-Sprache; ab dem 12. April 2014 konnte der offizielle Kernel von Clang fast kompiliert werden. Das diesem Aufwand gewidmete Projekt wird nach der LLVM-Compiler-Infrastruktur, auf der Clang gebaut wird, als LLVMLinux bezeichnet. LLVM Linux zielt nicht darauf ab, entweder Linux oder LLVM zu forkieren, daher ist es ein Meta-Projekt, das aus Patches besteht, die schließlich den vorgelagerten Projekten vorgelegt werden. Durch die Erstellung von Linux durch Clang können Entwickler von kürzeren Compilationszeiten profitieren. Im Jahr 2017 haben Entwickler Upstreaming-Patches abgeschlossen, um den Aufbau des Linux-Kernels mit Clang in der 4.15-Veröffentlichung zu unterstützen, mit Unterstützung für X86-64 und AArch64 zu den 4.4, 4.9 und 4.14 Zweigen des stabilen Kernelbaums. Googles Pixel 2 mit dem ersten Clang gebaut Linux-Kernel ausgeliefert, obwohl Patches für Pixel (1. Generation) existierten.2018 sah Chrome OS bewegen sich, um Kernel mit Clang standardmäßig zu bauen, während Android (Betriebssystem) Clang und LLVM Linker LLD für Kernel Builds im Jahr 2019 benötigt. Google zog seinen Produktionskern, der in seinen Rechenzentren verwendet wurde, um mit Clang im Jahr 2020 gebaut. Die ClangBuiltLinux-Gruppenkoordinaten fixieren heute sowohl Linux als auch LLVM, um die Kompatibilität zu gewährleisten, die beide aus Mitgliedern von LLVMLinux bestehen und Patches von LLVMLinux vorgeschaltet haben. Kernel debugging Bugs mit dem Linux Kernel kann schwierig zu beheben sein, dies ist wegen der Interaktion des Kernels mit Benutzerraum und Hardware, und auch, weil sie aus einer größeren Anzahl von Gründen im Vergleich zu denen von Benutzerprogrammen verursacht werden. Einige Beispiele für die zugrunde liegenden Ursachen sind semantische Fehler in Code, Missbrauch von Synchronisationsprimitiven und falsche Hardware-Management. Ein Bericht eines nicht-fatalen Fehlers im Kernel wird als oops bezeichnet; solche Abweichungen vom korrekten Verhalten des Linux-Kernels können eine kontinuierliche Operation mit kompromittierter Zuverlässigkeit ermöglichen. Über die Panik()-Funktion wird ein kritischer und tödlicher Fehler gemeldet. Es druckt eine Nachricht und stoppt dann den Kernel. Eine der häufigsten Techniken, die verwendet werden, um herauszufinden, Fehler in Code ist Debugging durch Drucken. Zu diesem Zweck bietet Linux eine in-Kernel-API namens printk(), die Nachrichten in einem kreisförmigen Puffer speichert. Der syslog(2)-Systemanruf dient zum Lesen und/oder Löschen des Kernel-Nachrichtenringpuffers und zum Einstellen des maximalen Log-Levels der an die Konsole zu sendenden Nachrichten (d.h. eines der acht KERN*_-Parameter von printk,(), die die Schwere der gemeldeten Bedingung angeben;) wird üblicherweise über den glibC-Wrapper klogctl(3) aufgerufen. Kernel-Nachrichten werden auch über die dev/kmsg-Schnittstelle (z.B. systemd-journald liest diese Schnittstelle und standardmäßig die Nachrichten an var/log/journal anhängen). Eine weitere grundsätzliche Technik zum Debuggen eines laufenden Kernels verfolgt. Der ftrace-Mechanismus ist ein Linux-interner Tracer; es wird zur Überwachung und Debugging von Linux zur Laufzeit verwendet und es kann auch Benutzer-Raum-Latenzen aufgrund von Kernel-Fehlern analysieren. Darüber hinaus ermöglicht ftrace Benutzern Linux bei boot-time.ksons und kretsons können brechen (wie Debugger im Userspace) in Linux und nicht-disruptive Informationen sammeln. ksons können in Code bei (fast) jeder Adresse eingefügt werden, während kretsons arbeiten bei function return.usons haben ähnliche Zwecke, aber sie haben auch einige Unterschiede in der Nutzung und Implementierung. mit KGDB Linux kann in der gleichen Weise wie Userspace-Programme debugged werden. KGDB erfordert eine zusätzliche Maschine, die GDB betreibt und die mit dem Ziel verbunden ist, mit einem seriellen Kabel oder Ethernet debuggiert zu werden. Entwicklungsmodell Das Linux-Kernel-Projekt integriert neuen Code auf einer rollenden Basis. Die in das Projekt geprüfte Software muss fehlerfrei arbeiten und kompilieren. Jedes Kernel-Subsystem wird einem Betreuer zugewiesen, der für die Überprüfung von Patches gegen die Kernel-Code-Standards verantwortlich ist und eine Warteschlange von Patches hält, die Linus Torvalds innerhalb eines Merge-Fensters von mehreren Wochen eingereicht werden kann. Patches werden von Torvalds in den Quellcode der vorherigen stabilen Linux-Kernel-Release zusammengefasst, wodurch der -rc-Release-Kandidat für den nächsten stabilen Kernel erstellt wird. Sobald das Merge-Fenster geschlossen ist, werden nur Korrekturen an den neuen Code in der Entwicklung Release akzeptiert. Die -rc-Entwicklungs-Release des Kernels geht durch Regressionstests und sobald es von Torvalds als stabil beurteilt wird und die Kernel-Subsystem-Betreuer ein neuer Linux-Kernel freigegeben wird und der Entwicklungsprozess wieder beginnt. Entwickler, die sich unlauter behandelt fühlen, können dies dem Technischen Beirat der Linux Foundation melden. Im Juli 2013 forderte der Betreuer des USB 3.0 Treibers Sarah Sharp Torvalds auf, den missbräuchlichen Kommentar in der Kernel-Entwicklungsgemeinschaft anzugehen. 2014 unterstützte Sharp die Linux-Kernel-Entwicklung und sagte: "Der Fokus auf technische Exzellenz, in Kombination mit überlasteten Betreuern und Menschen mit verschiedenen kulturellen und sozialen Normen, bedeutet, dass Linux-Kernel-Betreuer oft stumpf, unhöflich oder brutal sind, um ihre Arbeit zu erledigen". Auf der linux.conf.au (LCA) Konferenz im Jahr 2018 äußerten Entwickler die Ansicht, dass die Kultur der Gemeinschaft in den letzten Jahren viel besser geworden ist. Daniel Vetter, der Betreuer des Intel drm/i915 Grafik-Kernel-Treibers, kommentierte, dass die "heraus gewalttätige Sprache und Diskussion" in der Kernel-Community gesunken oder verschwunden ist. Laurent Pinchart bat Entwickler um Feedback zu ihrer Erfahrung mit der Kernel-Community auf der Embedded Linux Conference Europe 2017. Die aufgeworfenen Fragen wurden einige Tage später auf dem Maintainers Summit erörtert. Im Hinblick auf die mangelnde Konsistenz, wie die Betreuer auf Patches reagierten, die von Entwicklern eingereicht wurden, wurde Shuah Khan, der Betreuer des Kernel-Selbsttest-Rahmens, angesprochen. Torvalds behauptete, dass es nie Konsistenz in der Handhabung von Patches geben würde, weil verschiedene Kernel-Subsysteme im Laufe der Zeit verschiedene Entwicklungsprozesse angenommen haben. Daher wurde vereinbart, dass jeder Kernel-Subsystembetreuer die Regeln für die Patch-Annahme dokumentieren würde. Mainline Linux Der Git-Baum von Linus Torvalds, der den Linux-Kernel enthält, wird als Mainline Linux bezeichnet. Jede stabile Kernelfreigabe stammt aus dem Mainline-Baum und wird häufig auf kernel.org veröffentlicht. Mainline Linux hat nur solide Unterstützung für eine kleine Teilmenge der vielen Geräte, die Linux laufen. Nicht-mainline-Unterstützung wird von unabhängigen Projekten wie Yocto oder Linaro bereitgestellt, aber in vielen Fällen wird der Kernel des Geräteanbieters benötigt. Die Verwendung eines Herstellerkernels erfordert wahrscheinlich ein Board-Support-Paket. Der Erhalt eines Kernelbaums außerhalb der Mainline Linux hat sich als schwierig erwiesen. Mainlining bezieht sich auf den Aufwand, Unterstützung für ein Gerät zum Mainline-Kernel hinzuzufügen, während es früher nur Unterstützung in einer Gabel oder gar keine Unterstützung gab. Dies beinhaltet in der Regel das Hinzufügen von Treibern oder Gerätebaumdateien. Wenn dies beendet ist, wird die Funktion oder die Sicherheitskorrektur als Mainlined betrachtet. Linux-ähnlicher Kernel Der Betreuer des stabilen Zweiges, Greg Kroah-Hartman, hat den Begriff Linux-ähnlich für nachgeschaltete Kernel Forks von Anbietern angewendet, die Millionen von Zeilen Code zum Mainline-Kernel hinzufügen. Im Jahr 2019 erklärte Google, dass sie den Mainline Linux-Kernel in Android verwenden wollten, so dass die Anzahl der Kernelgabeln reduziert werden würde. Der Begriff Linux-ähnlich wurde auch auf den Embeddable Linux Kernel Subset angewendet, der nicht den gesamten Mainline Linux-Kernel, sondern eine kleine modifizierte Teilmenge des Codes umfasst. Linux forks Es gibt bestimmte Gemeinschaften, die Kernel basierend auf dem offiziellen Linux entwickeln. Einige interessante Bits des Codes aus diesen Gabeln (d.h. ein Slang-Termin mit der Bedeutung "abgeleitete Projekte"), darunter Linux-libre, Compute Node Linux, INK, L4Linux, RTLinux und User-Mode Linux (UML) wurden in die Mainline zusammengefasst. Einige Betriebssysteme, die für Handys entwickelt wurden, verwendet zunächst stark modifizierte Versionen von Linux, einschließlich Google Android, Firefox OS, HP WebOS, Nokia Maemo und Jolla Sailfish OS. Im Jahr 2010 kritisierte die Linux-Community Google, um seinen eigenen Kernelbaum effektiv zu starten: Dies bedeutet, dass alle Treiber, die für Android-Hardware-Plattformen geschrieben wurden, nicht in den Hauptkernelbaum zusammengeführt werden können, weil sie Abhängigkeiten von Code haben, die nur in Googles Kernelbaum lebt, wodurch es nicht gelingt, im kernel.org-Baum aufzubauen. Dadurch hat Google nun verhindert, dass ein großes Stück Hardware-Treiber und Plattform-Code jemals in den Hauptkernelbaum zusammengeführt wird. Effektiv einen Kernelzweig zu schaffen, auf den sich nun eine Reihe verschiedener Anbieter verlassen. Heute verwendet Android einen leicht angepassten Linux, wo Änderungen in Gerätetreibern implementiert werden, so dass wenig oder keine Änderung auf den Kernkern-Code erforderlich ist. Android-Entwickler übermitteln auch Patches an den offiziellen Linux, die schließlich das Android-Betriebssystem booten können. Beispielsweise kann ein Nexus 7 die Mainline Linux booten und ausführen. Bei einer Präsentation von 2001 im Computer History Museum hatte Linus Torvalds dies als Antwort auf eine Frage über Distributionen von Linux mit genau denselben Kernelquellen zu sagen oder nicht: Sie sind nicht...wohl sind sie, und sie sind es nicht. Es gibt keinen einzigen Kernel. Jede einzelne Verteilung hat ihre eigenen Veränderungen. Das ist schon seit ziemlich viel Tag. Ich weiß nicht, ob Sie daran denken können, dass Yggdrasil ziemlich extreme Veränderungen am Kernel bekannt war und sogar heute haben alle großen Anbieter ihre eigenen Tweets, weil sie einen Teil des Marktes haben, an dem sie interessiert sind und ganz offen, das ist, wie es sein sollte. Denn wenn jeder eine Person erwartet, kann ich alles verfolgen, was nicht der Punkt von GPL ist. Das ist nicht der Punkt, ein offenes System zu haben. Also tatsächlich die Tatsache, dass eine Distribution entscheidet, dass etwas so wichtig für sie ist, dass sie Patches hinzufügen, auch wenn es nicht im Standardkern ist, das ist ein wirklich gutes Zeichen für mich. So wurde zum Beispiel etwas wie ReiserFS hinzugefügt. Und der Grund, warum ReiserFS das erste Journaling-Dateisystem ist, das im Standard-Kernel integriert wurde, war nicht, weil ich Hans Reiser liebe. Es war, weil SUSE tatsächlich mit ReiserFS als ihren Standard-Kernel anfing, was mir ok erzählte. " Das ist eigentlich in der Produktion. Normale Leute machen das. Sie müssen etwas wissen, was ich nicht weiß. Also in einem sehr realen Sinne, was viele Verteilerhäuser tun, sind sie Teil dieses "wir machen unseren eigenen Zweig" und "wir machen unsere Veränderungen an diesem." Und wegen der GPL kann ich die besten Teile davon nehmen. Entwicklungsgemeinschaftskonflikte Es gab mehrere bemerkenswerte Konflikte unter Linux-Kernel-Entwicklern. Beispiele für solche Konflikte sind: Im Juli 2007 kündigte Con Kolivas an, dass er die Entwicklung für den Linux-Kernel aufhörte. Im Juli 2009 beendete Alan Cox seine Rolle als TTY-Schichtbetreuer nach Meinung von Linus Torvalds. Im Dezember 2010 gab es eine Diskussion zwischen Linux SCSI-Betreuer James Bottomley und SCST-Betreuer Vladislav Bolkhovitin, über die SCSI-Zielstapel im Linux-Kernel enthalten sein sollte. Dies machte einige Linux-Benutzer verärgert. Im Juni 2012 hat Torvalds deutlich gemacht, dass er nicht mit NVIDIA einverstanden war, dass seine Fahrer als geschlossen freigegeben wurden. Im April 2014 verbietete Torvalds Kay Sievers von der Einreichung von Patches an den Linux-Kernel, um nicht mit Bugs zu umgehen, die systemd verursacht, um negativ mit dem Kernel zu interagieren. Im Oktober 2014 beschuldigte Lennart Poettering Torvalds, den groben Diskussionsstil auf Linux kernelbezogenen Mailinglisten zu tolerieren und ein schlechtes Vorbild zu sein. Im März 2015 hat Christoph Hellwig eine Klage gegen VMware wegen Verletzung des Urheberrechts auf dem Linux-Kernel eingereicht. Linus Torvalds machte deutlich, dass er mit dieser und ähnlichen Initiativen nicht einverstanden war, indem er Anwälte zu einer eisigen Krankheit rief. Prominente Linux-Kernel-Entwickler waren sich der Bedeutung bewusst, Konflikte zwischen Entwicklern zu vermeiden. Lange Zeit gab es keinen Verhaltenskodex für Kernelentwickler aufgrund der Opposition von Linus Torvalds. Am 8. März 2015 wurde jedoch ein Linux Kernel Code of Conflict eingeführt. Er wurde am 16. September 2018 durch einen neuen Verhaltenskodex auf Basis des Beitragsbundes ersetzt. Dies fiel mit einer öffentlichen Entschuldigung von Torvalds und einer kurzen Pause von der Kernelentwicklung zusammen. Am 30. November 2018 schickte Jarkko Sakkinen von Intel nach dem Code of Conduct Patches, die in Quellcode-Kommentaren auftretende Fick-Instanzen ersetzen, durch geeignete Versionen, die auf den Wortumarmung fokussiert sind. CodebaseAs von 2021, die 5.11 Release des Linux-Kernels hatte etwa 30.34 Millionen Zeilen Code, etwa 14% des Codes ist Teil des Kerns (Architektur, Kernel und mm Verzeichnisse), während 60% ist Treiber. Linux ist Evolution, kein intelligentes Design! Geschätzte Kosten für Neuentwickeln Die Kosten für die Neuentwicklung der Linux-Kernel-Version 2.6.0 in einer traditionellen proprietären Entwicklung wurden auf 612 Millionen US$ (€467M, £394M) in den Preisen von 2004 mit dem COCOMO-Personen-Monats-Schätzmodell geschätzt. Im Jahr 2006 legte eine von der Europäischen Union finanzierte Studie die Kosten für die Sanierung von Kernel Version 2.6.8 höher, bei 882M $(1.14bn, £744M). Dieses Thema wurde im Oktober 2008 von Amanda McPherson, Brian Proffitt und Ron Hale-Evans revidiert. Mit David A. Wheeler's Methodik, schätzten sie die Neuentwicklung des 2.6.25 Kernels jetzt kostet $1.3bn (Teil von insgesamt $10.8bn um Fedora 9 zu erneuern). Auch Garcia-Garcia und Alonso de Magdaleno von der University of Oviedo (Spanien) schätzen, dass die jährliche Wertschöpfung an Kernel zwischen 2005 und 2007 etwa 100 Mio. € und 225 Mio. € im Jahr 2008 betrug, es würde auch mehr als 1 Mrd. € (ca. 1,4 Mrd. $ im Februar 2010) in der Europäischen Union zu entwickeln kosten. Ab dem 7. März 2011, mit dem aktuellen LOC (Codezeilen) von 2.6.x Linux-Kernel und Lohnzahlen mit David A. Wheelers Berechnungen würde es ungefähr $3bn (ca. €2.2bn) kosten, um den Linux-Kernel neu zu entwickeln, da er immer größer wird. Eine aktualisierte Berechnung ab dem 26. September 2018, mit dem aktuellen 20,088,609 LOC (Codezeilen) für den 4.14.14 Linux-Kernel und dem aktuellen US-amerikanischen durchschnittlichen Programmiergehalt von $75,506 zeigen, dass es ungefähr $14,725,449,000 Dollar (£11,191,341,000) kosten würde, um den bestehenden Code neu zu schreiben. Wartung und langfristige Unterstützung Die neueste Kernel-Version und ältere Kernel-Versionen werden separat gepflegt. Die neuesten Kernel-Versionen wurden von Linus Torvalds überwacht. Aktuelle Versionen werden von Greg Kroah-Hartman veröffentlicht. Die Linux-Kernel-Entwickler-Community unterhält einen stabilen Kernel, indem sie Fixes für Software-Bugs verwendet, die während der Entwicklung des nachfolgenden stabilen Kernels entdeckt wurden. Deshalb wird www.kernel.org immer zwei stabile Kernel auflisten. Der nächste stabile Linux-Kernel wird erst 8 bis 12 Wochen später veröffentlicht. Daher haben die Linux-Kernel-Betreuer einige stabile Kernel-Releases als langfristig bezeichnet, diese langfristigen Linux-Kernels werden mit Bugfixes für zwei oder mehr Jahre aktualisiert. Im November 2019 gab es fünf langfristige Linux-Kernels: 4.19.84, 4.14.154, 4.9.201, 4.4.201 und 3.16.76. Die vollständige Liste der Releases ist in der Linux-Kernel-Versionsgeschichte. Die meisten Linux-Benutzer führen einen Kernel aus, der von ihrer Linux-Distribution geliefert wird. Einige Distributionen liefern die Vanille oder stabile Kerne. Allerdings halten mehrere Linux-Distribution-Anbieter (wie Red Hat und Debian) eine weitere Reihe von Linux-Kernel-Zweigstellen aufrecht, die in ihre Produkte integriert sind. Diese werden in der Regel in einem langsameren Tempo im Vergleich zum Vanillezweig aktualisiert, und sie enthalten in der Regel alle Fixes aus dem betreffenden stabilen Zweig, aber gleichzeitig können sie auch Unterstützung für Treiber oder Funktionen hinzufügen, die in der Vanille-Version nicht freigegeben wurden, der Distributionsanbieter begann, ihren Zweig aus. Rechtliche Aspekte GPLv2 Lizenzbedingungen Ursprünglich veröffentlichte Torvalds Linux unter einer Lizenz, die jegliche kommerzielle Nutzung verbietet. Dies wurde in Version 0.12 durch einen Schalter in die GNU General Public License Version 2 (GPLv2) geändert. Diese Lizenz ermöglicht die Verteilung und den Verkauf von möglicherweise modifizierten und unmodifizierten Versionen von Linux, erfordert jedoch, dass alle diese Kopien unter der gleichen Lizenz veröffentlicht werden und von - oder dass auf Anfrage kostenlose Zugriff gegeben wird - die komplette entsprechende Quellcode. Torvalds hat die Lizenzierung Linux unter der GPLv2 als das "beste, was ich je gemacht habe" beschrieben. Der Linux-Kernel ist ausschließlich unter der Version 2 der GPL explizit lizenziert, ohne dem Lizenznehmer die Option zur Auswahl "jeder späteren Version" anzubieten, die eine gemeinsame GPL-Erweiterung ist. Die offizielle Git-Niederlassung von Torvalds enthält Dokumentationen, die den Kernelentwicklungsprozess für Menschen erklären, die mit der Community zusammenarbeiten und Code beitragen wollen; es gibt eindeutig, dass ["Any] Beiträge, die nicht von einer [GPLv2] kompatiblen Lizenz abgedeckt sind, nicht in den Kernel akzeptiert werden." Es gab eine erhebliche Debatte darüber, wie einfach die Lizenz geändert werden konnte, um spätere GPL-Versionen (einschließlich Version 3) zu verwenden und ob diese Änderung sogar wünschenswert ist. Torvalds selbst ausdrücklich auf die Version 2.4.0 hingewiesen, dass sein eigener Code nur unter Version 2 veröffentlicht wird. Die Begriffe des GPL-Zustandes, dass, wenn keine Version angegeben ist, dann jede Version verwendet werden kann, und Alan Cox wies darauf hin, dass sehr wenige andere Linux-Beitrager eine bestimmte Version der GPL spezifiziert hatten. Im September 2006 ergab eine Umfrage von 29 Kernel-Programmierern, dass 28 GPLv2 zum damals aktuellen GPLv3-Entwurf bevorzugt. Torvalds kommentierte: "Ich glaube, eine Reihe von Außenseitern. glaubte, dass ich persönlich nur der seltsame Mann war, weil ich so öffentlich kein großer Fan der GPLv3 gewesen bin." Diese Gruppe von hochkarätigen Kernelentwicklern, darunter Torvalds, Greg Kroah-Hartman und Andrew Morton, kommentierte auf Massenmedien über ihre Einwände gegen die GPLv3. Sie bezogen sich auf Klauseln über DRM/Tultivierung, Patente, "Zusätzliche Einschränkungen" und warnten eine Balkanisierung des "Open Source Universe" durch die GPLv3. Linus Torvalds, der sich entschlossen hat, den GPLv3 für den Linux-Kernel nicht zu übernehmen, wiederholte seine Kritik noch Jahre später. Loading kernel Module Es wird diskutiert, ob einige beladbare Kernel-Module (LKMs) im Urheberrecht als Derivatwerke angesehen werden sollen und damit unter die Bedingungen der GPL fallen. Gemäß den Lizenzregeln sind LKMs, die nur eine öffentliche Teilmenge der Kernel-Schnittstellen verwenden, nicht-erprobte Werke, so dass Linux Systemadministratoren die Mechanismen gibt, um aus dem Stammbaum binäre Objekte in den Kernel-Adressenraum zu laden.Es gibt einige fehlerbehaftete Module, die die Funktion dma_buf kernel legitim nutzen. GPL-konformer Code kann es sicher verwenden. Ein anderer Anwendungsfall wäre jedoch Nvidia Optimus, der eine schnelle GPU mit einer Intel integrierten GPU verbindet, wobei die Nvidia GPU in den Intel Framebuffer schreibt, wenn sie aktiv ist. Nvidia kann diese Infrastruktur aber nicht nutzen, weil sie eine Regel umgeht, die nur von LKMs verwendet werden kann, die auch GPL sind. Alan Cox antwortete auf LKML und lehnte eine Anfrage von einem ihrer Ingenieure ab, um diese technische Durchsetzung von der API zu entfernen. Torvalds eindeutig auf der LKML angegeben, dass ["I] behaupten, dass binär-nur Kernel-Module ARE-Derivat "nach Standard"". Auf der anderen Seite hat Torvalds auch gesagt, dass ["ein] Graubereich vor allem etwas ist wie ein Treiber, der ursprünglich für ein anderes Betriebssystem geschrieben wurde (d.h. eindeutig kein abgeleitetes Werk von Linux in Origin). THAT ist ein grauer Bereich, und das ist der Bereich, in dem ich persönlich glaube, dass einige Module als nicht abgeleitete Werke angesehen werden können, nur weil sie nicht für Linux konzipiert wurden und nicht von einem speziellen Linux-Verhalten abhängen." Insbesondere proprietäre Grafiktreiber werden stark diskutiert. Firmware binäre Blobs Der offizielle Kernel, das ist der Linus git Zweig am kernel.org Repository, enthält keine Art von proprietären Code; aber Linux kann die Dateisysteme suchen, um proprietäre Firmware, Treiber und andere ausführbare Module zu lokalisieren (zusammen als "binäre Blobs" bezeichnet), dann kann es laden und in den Kernelraum verknüpfen. Wenn proprietäre Module in Linux geladen werden, markiert sich der Kernel als befleckt, und daher werden Fehlerberichte von befleckten Kerneln oft von Entwicklern ignoriert. Wenn es benötigt wird (z.B. für den Zugriff auf Boot-Geräte oder für Geschwindigkeit) Firmware zum Kernel eingebaut werden kann, bedeutet dies, die Firmware in vmlinux zu bauen; dies ist jedoch nicht immer eine tragfähige Option für technische oder rechtliche Probleme (z.B. ist es nicht erlaubt, Firmware, die nicht-GPL kompatibel ist). Marke Linux ist eine eingetragene Marke von Linus Torvalds in den Vereinigten Staaten, der Europäischen Union und einigen anderen Ländern. Eine rechtliche Schlacht über die Marke begann 1996, als William Della Croce, ein Anwalt, der nie an der Entwicklung von Linux beteiligt war, begann, Lizenzgebühren für die Verwendung des Wortes Linux zu verlangen. Nachdem nachgewiesen wurde, dass das Wort bereits lange vor der ersten Verwendung von Della Croce verwendet wurde, wurde die Marke an Torvalds vergeben. Siehe auch Betriebssystem Kernel Monolithic Kernel Microkernel Linux-Kernel-Versionsgeschichte Vergleich der Betriebssystem-Kernel Linux Minix 3 macOS Microsoft Windows Referenzen Weiter lesen Externe Links Offizielle Website Linux-Kernel-Dokumentationsindex Linux-Kernel-Mannseiten Kernel bugzilla und Regressionen für jede neue Kernel-Version Kernel Newbies, eine Quelle von verschiedenen Kernel-bezogenen Informationen Der Flug wird im Januar 2022 starten und vier Personen an die ISS für einen achttägigen Aufenthalt senden: Michael López-Alegría ein professionell ausgebildeter Astronaut von Axiom Space, Eytan Stibbe für Israel, Larry Connor aus den Vereinigten Staaten und Mark Pathy aus Kanada. Es war erwartet worden, dass Tom Cruise und Doug Liman Passagiere für ein Filmprojekt sein würden, aber es wurde später angekündigt, dass sie auf einem späteren Flug fliegen. Hintergrund Axiom Space wurde 2016 mit dem Ziel gegründet, die weltweit erste kommerzielle Raumstation zu schaffen. Anfang 2020 kündigte die NASA an, dass Axiom Zugang zum vorderen Hafen des Harmony-Moduls der ISS erhalten hatte, auf den Axiom plant, das Axiom Orbital Segment anzudocken; ein Komplex, der nach 2024 mit einem großen Beobachtungsfenster – ähnlich der Cupola – zu drei Druckmodulen wachsen könnte, der die Aktivitäten des Unternehmens in der Low Earth Orbit erleichtern wird. Vor dem Start des ersten Moduls bis zum Jahr 2024 plante Axiom, die Besatzungsmissionen an die ISS zu organisieren und zu fliegen, bestehend aus entweder zahlenden Raumtouristen oder Astronauten von öffentlichen Einrichtungen oder privaten Organisationen. Im März 2020 gab Axiom bekannt, dass sie bereits Ende 2021 einen Flug zur ISS mit SpaceX's Crew Dragon Raumschiff Chartern würden. Diese Mission wird die erste vollständig kommerziell betriebene Crew-Mission der ISS sein, und eine der ersten dedizierten orbitalen Raum-Tourismus-Missionen, neben Roscosmos' Soyuz MS-20 Mission, auch für Ende 2021. Nach ihrem ersten Flug plant Axiom, Flugbegleiter in die ISS so oft wie zweimal pro Jahr anzubieten, ["Ausrichtung] mit den Flugmöglichkeiten, wie sie von der NASA zur Verfügung gestellt werden." Crew Ursprünglich waren Michael López-Alegría, Tom Cruise und Doug Liman und Eytan Stibbe auf dem Flug geplant. Jeder der für Touristen reservierten Sitze wurde angekündigt, US$55 Millionen zu kosten. Anfang 2021 wurde bekannt gegeben, dass der Cruise/Liman Teil der Crew von "ein Jahr oder zwei" aus as-yet unrevealed Gründen verschoben wurde. Nach dem Start von Crew Dragon Demo-2, der erste Crew-Testflug von Dragon 2, Axiom CEO Michael Suffredini sagte, dass sie planten, die Namen der Crew in "einen Monat oder so" bekanntgeben; Ars Technica berichtete, dass die gesamte Crew-Ergänzung "wahrscheinlich im Januar 2021 enthüllt werden würde". Am 26. Januar 2021 enthüllte Axiom die gesamte Crew der Mission, bestehend aus Michael López-Alegría, Larry Connor, Mark Pathy und Eytan Stibbe. Sie haben auch angekündigt Peggy Whitson als Backup-Befehl für die Mission und John Shoffner als Backup-Pilot. Michael Lopez-Alegria ist ein ehemaliger NASA-Astronaut und Axiom Space VP. John Shoffner ist ein Pilot und Unternehmer, und nicht ein Axiom-Mitarbeiter oder eine Regierung ausgebildet Astronaut. Peggy Whitson ist ein ehemaliger NASA Astronaut und Axiom Berater. Hauptmannschaft Backup Crew Mission Die Mission wird voraussichtlich im Januar 2022 starten, auf einem Falcon 9 Block 5 Start-Fahrzeug von Kennedy Space Center's Launch Complex 39A (LC-39A), einem NASA-Eigenen Start-Pad, das für Falcon 9 an SpaceX vermietet wurde. Laut Missionskommandeur Michael López-Alegría wird die Mission an Bord von Crew Dragon Resilience geflogen. Von dort aus wird das Raumschiff zwei Tage im Transit zum Bahnhof verbringen und mit Harmony anlegen, wo sie dann acht Tage an der Internationalen Raumstation (ISS) verbringen werden. Nach ihrer Zeit auf der ISS wird das Raumschiff über einen Absturz im Atlantik auf die Erde stoßen und zurückkommen. Der israelische Teil der Mission heißt Rakia, der Titel des Buches, das mit den Fragmenten des Tagebuchs Ilan Ramon veröffentlicht wurde, das die Katastrophe von Space Shuttle Columbia 2003 überlebte. Siehe auch Liste der Flüge Dragon 2 Liste der menschlichen Raumflights zur Internationalen Raumstation Raum Abenteuer Crew Dragon Mission Inspiration4 == Referenzen ==