In der Informatik sind eine Maske oder Bitmask Daten, die für bitweise Operationen, insbesondere in einem Bitfeld, verwendet werden. Mit einer Maske, mehrere Bits in einem Byte, Nibble, Wort etc. kann entweder ein-, aus- oder ausgeschaltet werden (oder umgekehrt) in einem einzigen bitweisen Betrieb. Eine zusätzliche Verwendung und Bedeutung von Masking ist die Vorgabe in der Vektorverarbeitung, wobei die Bitmask verwendet wird, um auszuwählen, welche Elementoperationen im Vektor ausgeführt werden sollen (Maskenbit ist aktiviert) und welche nicht (Maskenbit ist klar) Um bestimmte Bits einschalten zu können, kann der bitweise ODER-Betrieb nach dem Prinzip Y OR 1 = 1 und Y OR 0 = Y verwendet werden. Um sicherzustellen, dass ein bisschen auf, OR kann mit einem 1 verwendet werden. Um ein bisschen unverändert zu lassen, wird OR mit 0 verwendet. Beispiel:Auf dem höheren Nibbel (bits 4, 5, 6, 7) wird der untere Nibbel (bits 0, 1, 2, 3) unverändert. 10101 101001 ODER 11110000 11110000 = 11110101 11110101 Maskierung von Bits bis 0 Häufiger in der Praxis werden Bits "maskiert" (oder auf 0 maskiert) als "maskiert" (oder maskiert auf 1). Wenn ein Bit mit einem 0 gespeist wird, ergibt sich immer 0, d.h. Y UND 0 = 0. Um die anderen Bits wie ursprünglich zu verlassen, können sie mit 1 als Y UND 1 = Y Beispiel gespeist werden: Abmassieren der höheren Nibble (Bits 4, 5, 6, 7) die untere Nibble (Bits 0, 1, 2, 3) unverändert. 10010101 101001 UND 0000111100001111 = 00000101 00000101 Abfrage des Status eines Bits Es ist möglich, Bitmasken zu verwenden, um den Zustand einzelner Bits unabhängig von den anderen Bits leicht zu überprüfen. Dazu erfolgt das Abschalten aller anderen Bits mit dem Bitwise AND wie oben beschrieben und der Wert mit 0 verglichen. Wenn es gleich 0 ist, dann war das Bit aus, aber wenn der Wert ein anderer Wert ist, dann war das Bit an. Was macht dies bequem ist, dass es nicht notwendig ist, herauszufinden, was der Wert tatsächlich ist, nur dass es nicht 0 ist. Beispiel:Querying der Status des 4. Bits 10011101 100101 UND 00001000 00001000 = 00001000 000000 Togging von Bitwerten Bisher hat der Artikel abgedeckt, wie man Bits einschaltet und Bits ausschaltet, aber nicht beide auf einmal. Manchmal ist es nicht wirklich wichtig, was der Wert ist, aber es muss das Gegenteil von dem gemacht werden, was es derzeit ist. Dies kann durch den XOR (ausschließlich oder) Betrieb erreicht werden. XOR gibt 1 zurück, wenn und nur, wenn eine ungerade Anzahl von Bits 1 sind. Wenn also zwei entsprechende Bits 1 sind, wird das Ergebnis ein 0 sein, aber wenn nur einer von ihnen 1 ist, wird das Ergebnis 1 sein. Daher erfolgt die Inversion der Bitwerte durch XORing mit einem 1. Wenn das ursprüngliche Bit 1 war, gibt es 1 XOR 1 = 0 zurück.Wenn das ursprüngliche Bit 0 war, gibt es 0 XOR 1 = 1.Auch beachten Sie, dass XOR Maskierung Bit-sicher ist, was bedeutet, dass es unmaskierte Bits nicht beeinflussen wird, weil Y XOR 0=Y, genau wie ein OR. Beispiel:Verknüpfung von Bitwerten 10011101 100101XOR 0000111111111111 = 1001001001101010 Um willkürliche 1s und 0s zu einer Teilmenge von Bits zu schreiben, schreiben Sie zuerst 0s zu dieser Teilmenge, stellen Sie dann die hohen Bits: registrieren = (Register & ~bitmask) | Wert; Verwenden von Bitmasks Arguments zu Funktionen In Programmiersprachen wie C sind Bitfelder eine nützliche Möglichkeit, eine Reihe von benannten booleschen Argumenten einer Funktion zu übergeben. Beispielsweise gibt es in der Grafik API OpenGL einen Befehl, glClear(), der den Bildschirm oder andere Puffer freigibt. Es kann bis zu vier Puffer (Farbe, Tiefe, Akkumulation und Schablonenpuffer) löschen, so dass die API-Autoren hätten es vier Argumente. Aber dann würde ein Anruf darauf aussehen, wie das nicht sehr beschreibend ist. Stattdessen gibt es vier definierte Feldbits, GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, GL_ACCUM_BUFFER_BIT und GL_STENCIL_BUFFER_BIT und glClear() wird als Dann ein Aufruf zur Funktion sieht so intern aus, eine Funktion, die ein solches Bitfeld einnimmt, kann binär verwenden und die einzelnen Bits extrahieren. Beispielsweise könnte eine Implementierung von glClear() aussehen wie: Der Vorteil dieses Ansatzes ist, dass das Funktionsargument über Kopf verringert wird. Da die minimale Datumsgröße ein Byte ist, würde die Trennung der Optionen in separate Argumente sieben Bits pro Argument versäumen und mehr Stapelplatz einnehmen. Stattdessen akzeptieren Funktionen typischerweise eine oder mehrere 32-Bit-Integer mit jeweils bis zu 32 Options-Bits. Während elegant, in der einfachsten Umsetzung ist diese Lösung nicht typsicher. A GLbitfield ist einfach als unbezeichnetes Int definiert, so dass der Compiler einen sinnlosen Aufruf zu glClear(42) oder sogar glClear(GL_POINTS) erlauben würde. In C+ wäre eine Alternative, eine Klasse zu schaffen, um die Reihe von Argumenten zu verkapseln, die glClear akzeptiert und in einer Bibliothek sauber verkapselt werden könnte.Inverse Masken Masken werden mit IP-Adressen in IP ACLs (Access Control Lists) verwendet, um anzugeben, was erlaubt und verweigert werden sollte. Um IP-Adressen an Schnittstellen zu konfigurieren, starten Masken mit 255 und haben die großen Werte auf der linken Seite: z.B. IP-Adresse 203.0.113.129 mit einer 255.255.255.224 Maske. Masken für IP ACLs sind die Rückseite: zum Beispiel Maske 0.0.0.255. Das nennt man manchmal eine Inverse-Maske oder eine Wildcard-Maske. Wenn der Wert der Maske in binäre (0s und 1s) zerlegt wird, bestimmen die Ergebnisse, welche Adressbits bei der Verarbeitung des Verkehrs berücksichtigt werden sollen. Ein 0-Bit gibt an, dass das Adreßbit als (genaues Spiel) betrachtet werden muss, ein 1-Bit in der Maske ist ein "nicht kümmern". Diese Tabelle erklärt das Konzept weiter. Mask Beispiel: Netzwerkadresse (Verkehr, die verarbeitet werden soll:) 192.0.2.0 Maske: 0.0.0.255 Netzwerkadresse (binary:) 11000000.0000000000000000010.00000000 Maske (binary:) 00000000.00000000,0000.111111 Basierend auf der binären Maske ist zu erkennen, dass die ersten drei Sätze (Oktetts) genau auf die angegebene binäre Netzwerkadresse (11000000.00000000.00000010) passen müssen. Der letzte Zahlensatz besteht aus "Nichts interessiert" (11111111). Der Verkehr, der mit 192.0.2 beginnt, stimmt daher überein, da das letzte Oktett "keine Sorge" ist. Mit dieser Maske werden daher Netzwerkadressen 192.0.2.0.1 bis 192.0.2.0.255 (192.0.2.0.x) verarbeitet. Subtrahieren Sie die normale Maske von 255.255.255.255, um die ACL inverse Maske zu bestimmen. In diesem Beispiel wird die inverse Maske für die Netzwerkadresse 198.51.100.0 mit einer normalen Maske von 255.255.255.0.255.255.255.255.255 - 255.255.255.0 (normale Maske) = 0,0.0.255 (inverse Maske)ACL-Äquivalente bestimmt. Die Source/source-wildcard von 0,0.0.0/255.255.255.255.255.255 bedeutet alle". Die Source/Wildcard von 198.51.100.2/0.0.0.0 ist die gleiche wie "Host 198.51.100.2" Bildmasken In Computergrafiken, wenn ein bestimmtes Bild über einen Hintergrund platziert werden soll, können die transparenten Bereiche durch eine binäre Maske vorgegeben werden. Auf diese Weise gibt es für jedes beabsichtigte Bild tatsächlich zwei Bitmaps: das eigentliche Bild, in dem die ungenutzten Bereiche einen Pixelwert mit allen auf 0s gesetzten Bits erhalten, und eine zusätzliche Maske, in der die korrespondierenden Bildbereiche einen Pixelwert aller auf 0s gesetzten Bits und die Umgebungen einen Wert aller auf 1s gesetzten Bits erhalten. In der rechten Probe haben schwarze Pixel die All-Null-Bits und weiße Pixel die All-One-Bits. Zur Laufzeit, um das Bild auf den Bildschirm über den Hintergrund zu setzen, maskiert das Programm zunächst die Bits des Bildschirmpixels mit der Bildmaske an den gewünschten Koordinaten unter Verwendung des bitweisen UND-Betriebs. Dadurch werden die Hintergrundpixel der transparenten Bereiche erhalten, während die Bits der Pixel, die durch das überlappte Bild verdeckt werden, mit Nullen zurückgesetzt werden. Dann macht das Programm die Bits des Bildpixels, indem es sie mit den Bits des Hintergrundpixels mit dem Bitwise-ODER-Betrieb kombiniert. Auf diese Weise werden die Bildpixel entsprechend platziert, während der Hintergrund umgebende Pixel erhalten bleiben. Das Ergebnis ist eine perfekte Verbindung des Bildes über den Hintergrund. Diese Technik wird zum Malen von Zeiger-Gerät Cursors, in typischen 2-D-Videospielen für Zeichen, Kugeln und so weiter (die Sprite,) für GUI-Symbole, und für Video-Titling und andere Bild-Mixing-Anwendungen verwendet. Obwohl verwandte (wegen der Verwendung für die gleichen Zwecke) transparente Farben und Alpha-Kanäle sind Techniken, die nicht die Bildpixel-Mixierung durch binäre Maskierung beinhalten. Hash-Tabellen Um eine Hashing-Funktion für eine Hash-Tabelle zu erstellen, wird häufig eine Funktion verwendet, die eine große Domäne aufweist. Um einen Index aus dem Ausgang der Funktion zu erstellen, kann ein Modul verwendet werden, um die Größe der Domain auf die Größe des Arrays zu reduzieren; es ist jedoch oft schneller auf vielen Prozessoren, um die Größe der Hashtabelle auf Leistungen von zwei Größen einzuschränken und stattdessen ein Bitmask zu verwenden. Ein Beispiel für Modulo und Maskierung in C: Siehe auch Affinity-Maske Bit-Feld Bit Manipulation Bitwise Operation SubnetworkTagged Zeiger umask == Referenzen ==