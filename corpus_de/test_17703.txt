The McCarthy 91 Funktion ist eine recursive Funktion, die vom Computerwissenschaftler John McCarthy als Testfall für die förmliche Überprüfung in der Computerwissenschaft definiert wird. The McCarthy 91 Funktion ist definiert als M (n ) = { n − 10 , wenn n° 100 M ( M ( n + 11 ) , wenn n ≤ 100 {\displaystyle M(n)= n {cases}n-10, & Logmbox{if } 100 }M(n+11)), & {m } } }n\q 100m Die Ergebnisse der Bewertung der Funktion werden von M(n) = 91 für alle Vorfälle n ≤ 100 und M(n) = n n n° 100.Indeed angegeben, das Ergebnis von M(101) ist ebenfalls 91 (101 - 10 = 91). Alle Ergebnisse von M(n) nach n = 101 steigen kontinuierlich um 1, z.B. M(102)= 92, M(103)= 93. Geschichte Die 91 Funktion wurde 1970 in Papieren von Zohar Manna, Amir Pnueli und John McCarthy eingeführt. In diesen Papieren wurden frühzeitige Entwicklungen im Hinblick auf die Anwendung formaler Methoden zur Programmprüfung vorgenommen. 91 Funktion wurde gewählt, um Nested-recursive (kontinuiiert mit einmaliger Wiederbelebung, wie z.B. Definition f (n ) faserstyle f(n)} durch f (n − 1 ) Memestyle f(n-1)}. Das Beispiel wurde von Mannas Buch, der mathematischen Theorie der Komputation (1974) begrüßt. Da das Feld der Formalmethoden fortgeschritten ist, wurde dieses Beispiel in der Forschungsliteratur wiederholt. Insbesondere gilt es als ein "Herausforderungsproblem" für die automatische Programmprüfung. Leichter Grund für den rückwirkenden Kontrollfluss ist dies eine gleichwertige Definition (ausgezeichnet): M t ( ) = M t  t ( , 1 ) {\ {t}(n)=M_{t}“(n,1 t ′ q {\ q     ,    c  0 } } 0 M} (n   10  10 10  1  1  1 1  1  1  1  1  1  1  1  11  11  11  M  11  11  11  11  11  11  11  11  11  11  11  11  11  11  M  M  M  M  M  M  M  M  11  M  11  11  11  M  M  M  M  M  M  M  M  M  M  M  M  M  M  M  M  M  M  M  M  M  M  M  M  M  M  M  M  M  M  M  M  M  M  M  M  Als eines der Beispiele, die zum Nachweis einer solchen Begründung verwendet werden, enthält das Buch von Manna einen rückverfolgten Algorithmus, der dem Nested-recursive 91-Funktion entspricht. Viele der Papiere, die eine "automatisierte Überprüfung" (oder Kündigungsnachweis) der 91 Funktion melden, sind nur mit der nachgelagerten Fassung fertig. Hierbei handelt es sich um eine gleichwertige, sich gegenseitig vernachlässigende Definition: M m t ( ) = M m t ′ ( n , 0 ) Memedisplaystyle M_{mt}(n)=M_{mt}“(n,0 M t ́ ( n , c) = { Mn · n − 10 , c ) , wenn n° 100 m t ′ ( n + 11 , c + 1 ) , wenn n ≤ 100 displaystyle M_{mt}'(n,c)= {cases}M_{M_{mt}''(n-10,c), Tonbox } 100 m} M}(n)11,c) Laut Artikel Mitchell Wand, der sich auf die Verwendung von Fortbesetzungen stützt, wurde 1980 eine förmliche Ableitung der gegenseitigen Abrissversion aus der Nested-Recursive gegeben. Beispiel A: M(99) = M(110) seit 99 ≤ 100 = M(100) seit 110 Grad 100 = M(M(111) Seit 100 ≤ 100 = M(101) seit 111/100 = 91 seit 101 Grad 100 Beispiel B: M(87) = M(M(98) = M(M(109) = M(99) = M(M(110) = M(M) = M(100) = M(M(M) = M(M) = M(100) = M(M) = M(M) = M(95) = M(95) CodeHere ist eine Umsetzung des Nested-Recursive-Algorithmus in Lisp: Hierbei handelt es sich um eine Umsetzung des Nested-Recursivegorithmus in Haskell: Hierbei handelt es sich um eine Umsetzung des Nested-Recursivegorithmus in OCaml: Hierbei handelt es sich um eine Umsetzung des rückwirkenden Algorithmus in OCaml: Hierbei handelt es sich um eine Umsetzung des Nested-Recursive-Algorithmus in Python: Hierbei handelt es sich um die Umsetzung des Nested-Recursive-Algorithmus in C: Hier handelt es sich um eine Umsetzung des rückständigen Algorithmus in C: Hier ist ein Beweis dafür, dass M (n ) = { n ‐ 10 , wenn n= 100 91 , wenn n ≤ 100 {\displaystyle M(n)= cubegins}n-10, & WELLmbox{if }100 }91, &002mbox{if }n\q 100 \{Endcases, die einen gleichwertigen Non-recursive-Recursive-Algorithmus zu Mstyle Mstyle 100 Mstyle, E- For 100 M. } . . . . } . } } } } } } } } } . . Für 90 ≤ 100, M(n) = M(M(n + 11,) nach Definition = M(n + 11 - 10) seit n + 11 · 100 =M(n + 1) So M(n) = M(n) = M(101)=91 für 90 n ≤ 100. Dies kann als Basisfall verwendet werden. Lassen Sie sich für den Induktionsschritt ≤ 89 und übernehmen M(i)= 91 für alle n  i i ≤ 100, dann M(n) = M(n + 11,) nach Definition = M(91) durch Hypothesis, da n n  +  11  11 ≤ 100 = 91, im Basisfall. Dies zeigt M(n)= 91for alle n ≤ 100, einschließlich negativer Werte. Knuths Generalisierung Donald Knuth bezog die 91 Funktion, zusätzliche Parameter aufzunehmen. John Cowles hat einen förmlichen Nachweis entwickelt, dass die Generalisierte Funktion von Knuth mit Hilfe der ACL2 desorem prover insgesamt funktioniert. Referenzen Manna, Zohar; Pnueli, Amir (Juli 1970)."Formalisierung der Eigenschaften der Funktionsprogramme". Manna, Zohar; McCarthy, John0%)."Properties of Programme und partielle Funktionslogik. Maschinennachrichten.5.OCLC 35422131. Manna, Zohar (1974). mathematische Theorie der Computation (4. ed). McGraw-Hill.ISBN 9780070399105. Wand, Mitchell (Januar 1980). "Continuation-Based Program Transformationsstrategien"