Eine kryptographische Hash-Funktion (CHF) ist ein mathematischer Algorithmus, der Daten beliebiger Größe (oft die Nachricht genannt) auf ein Bit-Array fester Größe (der "Hash-Wert", Hash, oder "Message-Dau") abbildet. Es handelt sich um eine Einwegfunktion, d.h. eine Funktion, die praktisch unfehlbar ist, die Berechnung invertieren oder umkehren zu können. Idealerweise ist der einzige Weg, eine Nachricht zu finden, die eine gegebene Hash erzeugt, um eine brutale Kraft Suche nach möglichen Eingaben zu versuchen, um zu sehen, ob sie ein Spiel erzeugen, oder verwenden Sie eine Regenbogentabelle von abgestimmten Hashes. Kryptographische Hash-Funktionen sind ein grundlegendes Werkzeug der modernen Kryptographie. Die ideale kryptographische Hash-Funktion hat die folgenden Haupteigenschaften: es ist deterministisch, d.h., dass die gleiche Nachricht immer im gleichen Hash ergibt, ist es schnell, den Hash-Wert für jede gegebene Nachricht zu berechnen, es ist unfehlbar, eine Nachricht zu erzeugen, die einen bestimmten Hash-Wert liefert (d.h., um den Prozess umzukehren, ist insbesondere bekannt, dass der angegebene Hash-Wert erzeugt wird). Sie können auch als gewöhnliche Hash-Funktionen verwendet werden, um Daten in Hash-Tabellen zu indexieren, zum Fingerabdrucken, um doppelte Daten zu erkennen oder eindeutig Dateien zu identifizieren, und als Prüfsummen, um versehentliche Daten Korruption zu erkennen. In Informations-Sicherheits-Kontexten werden kryptographische Hash-Werte manchmal als (digitale) Fingerabdrücke, Prüfsummen oder nur Hash-Werte bezeichnet, obwohl alle diese Begriffe für allgemeinere Funktionen mit eher unterschiedlichen Eigenschaften und Zwecken stehen. Eigenschaften Die meisten kryptographischen Hash-Funktionen sind entworfen, um einen String beliebiger Länge als Eingabe zu nehmen und einen Fix-Länge Hash-Wert zu erzeugen. Eine kryptographische Hashfunktion muss allen bekannten Arten von kryptanalytischen Angriffen standhalten können. In der theoretischen Kryptographie wurde der Sicherheitspegel einer kryptographischen Hash-Funktion mit folgenden Eigenschaften definiert: Bei einem Hash-Wert h sollte es schwierig sein, jede Nachricht m so zu finden, dass h = hash(m). Dieses Konzept ist mit dem einer Einwegfunktion verbunden. Funktionen, die diese Eigenschaft nicht haben, sind anfällig für Preimage-Angriffe. Zweiter Vorbildwiderstand Bei einem Eingang m1 sollte es schwierig sein, einen anderen Eingang m2 so zu finden, dass hash(m1) = hash(m2) ist. Diese Eigenschaft wird manchmal als schwache Kollisionsbeständigkeit bezeichnet. Funktionen, die diese Eigenschaft nicht haben, sind gegen Angriffe auf das zweite Vorbild anfällig. Kollisionsbeständigkeit Es sollte schwierig sein, zwei verschiedene Nachrichten m1 und m2 so zu finden, dass hash(m1) = hash(m2). Ein solches Paar wird als kryptographische Hashkollision bezeichnet. Diese Eigenschaft wird manchmal als starker Kollisionswiderstand bezeichnet. Es erfordert einen Hash-Wert mindestens doppelt so lange, wie dies für den Vorbildwiderstand erforderlich ist; andernfalls können Kollisionen durch einen Geburtstagsangriff gefunden werden. Kollisionswiderstand impliziert den zweiten Vorbildwiderstand, bedeutet aber nicht den Vorbildwiderstand. Die schwächere Annahme ist in der theoretischen Kryptographie immer bevorzugt, aber in der Praxis wird eine nur zweite Vorbild-resistente Hash-Funktion als unsicher betrachtet und daher für reale Anwendungen nicht empfohlen. Informell bedeuten diese Eigenschaften, dass ein böswilliger Gegner die Eingabedaten nicht ersetzen oder ändern kann, ohne seine Verdauung zu ändern. Wenn also zwei Saiten die gleiche Verdauung haben, kann man sehr zuversichtlich sein, dass sie identisch sind. Der zweite Vorbildwiderstand verhindert, dass ein Angreifer ein Dokument mit dem gleichen Hash anfertigt wie ein Dokument, das der Angreifer nicht kontrollieren kann. Kollisionswiderstand verhindert, dass ein Angreifer zwei verschiedene Dokumente mit demselben Hash erstellt. Eine Funktion, die diese Kriterien erfüllt, kann noch unerwünschte Eigenschaften aufweisen. Derzeit sind beliebte kryptographische Hash-Funktionen anfällig für Long-Extension-Angriffe: gegeben Hash(m) und len(m) aber nicht m, durch die Wahl eines geeigneten m' kann ein Angreifer hash(m ERT m',) berechnen, wo ERT Concatenation bezeichnet. Diese Eigenschaft kann verwendet werden, um naive Authentifizierungsschemata basierend auf Hash-Funktionen zu brechen. Die HMAC-Konstruktion arbeitet um diese Probleme. In der Praxis ist Kollisionsbeständigkeit für viele praktische Anwendungen unzureichend. Neben der Kollisionsbeständigkeit sollte es für einen Gegner unmöglich sein, zwei Meldungen mit im Wesentlichen ähnlichen Verdauungsstörungen zu finden oder nützliche Informationen über die Daten zu erteilen, wenn nur deren Verdau gegeben ist.Insbesondere sollte sich eine Hash-Funktion wie eine zufällige Funktion (oft ein zufälliges Orakel in Sicherheitsnachweisen genannt) möglichst verhalten, während sie noch deterministisch und effizient rechnerisch ist. Diese regeln Funktionen wie die SWIFFT-Funktion, die sich streng als kollisionsbeständig erweisen kann, vorausgesetzt, dass bestimmte Probleme an idealen Gittern rechnerisch schwierig sind, aber als lineare Funktion diese zusätzlichen Eigenschaften nicht erfüllt. Prüfsummenalgorithmen, wie CRC32 und andere zyklische Redundanzprüfungen, sind darauf ausgelegt, viel schwächere Anforderungen zu erfüllen und sind in der Regel als kryptographische Hash-Funktionen ungeeignet. Zum Beispiel wurde ein CRC für die Nachrichtenintegrität im WEP-Verschlüsselungsstandard verwendet, aber ein Angriff wurde leicht entdeckt, der die Linearität der Prüfsumme ausnutzte. Schwierigkeitsgrad In der kryptographischen Praxis bedeutet "fast sicher über die Reichweite eines Gegners hinaus, der daran gehindert werden muss, das System zu brechen, solange die Sicherheit des Systems als wichtig gilt". Die Bedeutung des Begriffs hängt daher etwas von der Anwendung ab, da der Aufwand, den ein Schadmittel in die Aufgabe einbringen kann, in der Regel proportional zu ihrem erwarteten Gewinn ist. Da jedoch der erforderliche Aufwand in der Regel mit der Verdauungslänge multipliziert, kann sogar ein tausendfacher Vorteil in der Verarbeitungsleistung durch Zugabe von einigen Dutzend Bits zu dieser neutralisiert werden. Für Nachrichten aus einem begrenzten Satz von Nachrichten, z.B. Passwörter oder andere kurze Nachrichten, kann es möglich sein, einen Hash zu invertieren, indem Sie alle möglichen Nachrichten im Set ausprobieren. Da kryptographische Hash-Funktionen typischerweise schnell berechnet werden sollen, wurden spezielle Schlüsselableitungsfunktionen entwickelt, die größere Rechenressourcen erfordern, die solche brutalen Angriffe erschweren. In einigen theoretischen Analysen hat schwierig eine bestimmte mathematische Bedeutung, wie "nicht in asymmetrischer Polynomzeit solvierbar". Solche Deutungen von Schwierigkeiten sind bei der Untersuchung von nachweislich sicheren kryptographischen Hash-Funktionen wichtig, haben aber in der Regel keine starke Verbindung zur praktischen Sicherheit. Beispielsweise kann ein Exponentiell-Zeit-Algorithmus manchmal noch schnell genug sein, um einen möglichen Angriff zu machen. Umgekehrt kann ein Polynom-Zeit-Algorithmus (z.B. ein, der n20 Schritte für n-stellit Schlüssel benötigt) für jede praktische Anwendung zu langsam sein. Abbildung Eine Darstellung der möglichen Verwendung einer kryptographischen Hash ist wie folgt: Alice stellt ein hartes Mathe-Problem für Bob und behauptet, dass sie es gelöst hat. Bob würde es gerne selbst versuchen, aber möchte dennoch sicher sein, dass Alice nicht blufft. Deshalb schreibt Alice ihre Lösung, berechnet ihre Hash und sagt Bob der Hash-Wert (whilst die Lösung geheim halten). Dann, wenn Bob mit der Lösung selbst ein paar Tage später kommt, kann Alice beweisen, dass sie die Lösung früher hatte, indem sie es enthüllt und Bob hash es und überprüfen, dass es dem Hash-Wert entspricht, der ihm zuvor gegeben wurde. ( Dies ist ein Beispiel für ein einfaches Engagement-Schema; in der Praxis werden Alice und Bob oft Computerprogramme sein, und das Geheimnis wäre etwas weniger leicht spoofed als eine beanspruchte Puzzlelösung.) Anwendungen Überprüfung der Integrität von Nachrichten und Dateien Eine wichtige Anwendung sicherer Hashes ist die Überprüfung der Nachrichtenintegrität. Vergleich von Meldungsverdauungen (Hash-Verdau über die Nachricht) vor und nach, Übertragung kann feststellen, ob Änderungen in der Nachricht oder Datei vorgenommen wurden. MD5, SHA-1 oder SHA-2 Hash-Dauungen werden manchmal auf Websites oder Foren veröffentlicht, um die Überprüfung der Integrität für heruntergeladene Dateien zu ermöglichen, einschließlich Dateien, die mit Dateifreigabe wie Spiegelung abgerufen werden. Diese Praxis stellt eine Vertrauenskette fest, solange die Hashes auf einer vertrauenswürdigen Website – in der Regel der Ursprungsseite – von HTTPS authentifiziert werden. Mit einem kryptographischen Hash und einer Kette von Vertrauen erkennt schädliche Änderungen an der Datei. Andere fehlerbehaftete Codes wie zyklische Redundanzprüfungen verhindern nur gegen nicht-malicious Änderungen der Datei, die von anderen gemacht werden. Signatur-Generierung und -Verifikation Fast alle digitalen Signatur-Systeme erfordern eine kryptographische Hash über die Nachricht berechnet werden. Auf diese Weise kann die Signaturberechnung auf dem relativ kleinen, statisch bemessenen Hash-Dau durchgeführt werden. Die Nachricht wird als authentisch angesehen, wenn die Unterschriftsprüfung mit der Unterschrift gelingt und Hash-Dau über die Nachricht neu berechnet. So wird die Nachrichtenintegritätseigenschaft der kryptographischen Hash verwendet, um sichere und effiziente digitale Signatursysteme zu erstellen.Passwort-Verifikation Passwort-Verifikation stützt sich häufig auf kryptographische Hasen. Die Speicherung aller Benutzerpasswörter als Klartext kann zu einem massiven Sicherheitsverstoß führen, wenn die Passwortdatei beeinträchtigt wird. Eine Möglichkeit, diese Gefahr zu reduzieren, ist nur die Hash-Dauung jedes Passworts zu speichern. Um einen Benutzer zu authentifizieren, wird das vom Benutzer präsentierte Passwort gelöscht und mit dem gespeicherten Hash verglichen. Ein Passwort-Reset-Verfahren ist erforderlich, wenn das Passwort-Lauschen durchgeführt wird; Original-Passwörter können nicht aus dem gespeicherten Hash-Wert neu berechnet werden. Standard-Kryptographische Hash-Funktionen sind so konzipiert, dass sie schnell berechnet werden, und so ist es möglich, erratene Passwörter zu hohen Preisen auszuprobieren. Gemeinsame Grafikverarbeitungseinheiten können Milliarden von möglichen Passwörtern pro Sekunde ausprobieren. Passwort Hash-Funktionen, die die Schlüsselstreckung durchführen – wie PBKDF2, Scrypt oder Argon2 – verwenden häufig wiederholte Invokationen einer kryptographischen Hash, um die Zeit (und in einigen Fällen Computerspeicher) erforderlich zu erhöhen, um Brute-force-Angriffe auf gespeicherte Passwort Hash-Verdauungen durchzuführen. Ein Passwort Hash erfordert die Verwendung eines großen zufälligen, nicht geheimen Salzwerts, der mit dem Passwort Hash gespeichert werden kann. Das Salz randomisiert die Ausgabe des Passwort Hash, so dass es für einen Gegner unmöglich, Tabellen von Passwörtern und vorbestellte Hash-Werte zu speichern, auf die das Passwort Hash-Dau verglichen werden kann. Die Ausgabe einer Passwort Hash-Funktion kann auch als kryptographischer Schlüssel verwendet werden. Password hashes werden daher auch als passwortbasierte Schlüsselableitungsfunktionen (PBKDFs) bezeichnet. Ein Beleg-of-work-System (oder Protokoll oder Funktion) ist eine wirtschaftliche Maßnahme zur Abwehr von Denial-of-Service-Angriffen und anderen Service-Missbrauchen wie Spam auf einem Netzwerk, indem es einige Arbeiten des Service-Anfragenden erfordert, in der Regel Verarbeitungszeit durch einen Computer. Ein wesentliches Merkmal dieser Systeme ist ihre Asymmetrie: Die Arbeit muss auf der Anfrageseite mäßig schwer (aber machbar) sein, aber leicht zu überprüfen für den Dienstleister. Ein beliebtes System, das in Bitcoin Bergbau und Hashcash verwendet wird, verwendet teilweise Hash-Inversionen, um zu beweisen, dass die Arbeit getan wurde, um eine Bergbaubelohnung in Bitcoin zu entsperren, und als Good-will-Token eine E-Mail in Hashcash zu senden. Der Sender muss eine Nachricht finden, deren Hash-Wert mit einer Anzahl von Nullbits beginnt. Die durchschnittliche Arbeit, die der Absender durchführen muss, um eine gültige Nachricht zu finden, ist exponentiell in der Anzahl der im Hash-Wert erforderlichen Nullbits, während der Empfänger die Gültigkeit der Nachricht durch Ausführen einer einzigen Hash-Funktion überprüfen kann. Beispielsweise wird in Hashcash ein Sender aufgefordert, einen Header zu erzeugen, dessen 160-Bit-SHA-1 Hash-Wert die ersten 20 Bit als Nullen aufweist. Der Absender muss im Durchschnitt 219 mal versuchen, einen gültigen Header zu finden. Datei- oder Datenkennung Ein Nachrichtenverdau kann auch als Mittel dienen, eine Datei zuverlässig zu identifizieren; mehrere Quellcode-Management-Systeme, einschließlich Git, Mercurial und Monotone, verwenden Sie die sha1sum von verschiedenen Arten von Inhalten (Dateiinhalt, Verzeichnisbäume, Vorfahreninformationen, etc.), um sie eindeutig zu identifizieren. Hashes werden verwendet, um Dateien auf Peer-to-Peer-Dateien zu identifizieren. Beispielsweise wird in einem ed2k-Link ein MD4-Variant Hash mit der Dateigröße kombiniert, so dass ausreichende Informationen zum Auffinden von Dateiquellen, zum Herunterladen der Datei und zur Überprüfung ihrer Inhalte bereitgestellt werden. Magnetverbindungen sind ein weiteres Beispiel. Solche Datei Hashes sind oft die oberste Hash einer Hash-Liste oder ein Hash-Baum, der zusätzliche Vorteile ermöglicht. Eine der wichtigsten Anwendungen einer Hash-Funktion ist, das schnelle Aufsehen von Daten in einer Hash-Tabelle zu ermöglichen. Als Hash-Funktionen bestimmter Art eignen sich kryptographische Hash-Funktionen auch für diese Anwendung gut. Im Vergleich zu herkömmlichen Hash-Funktionen sind kryptographische Hash-Funktionen jedoch viel teurer. Aus diesem Grund neigen sie dazu, in Kontexten zu verwenden, in denen es für Benutzer erforderlich ist, sich vor der Möglichkeit der Fälschung (die Erstellung von Daten mit der gleichen Verdauung wie die erwarteten Daten) durch potenziell bösartige Teilnehmer zu schützen. Hash-Funktionen basierend auf Block-Ciphers Es gibt mehrere Methoden, um eine Block-Chiffre zu verwenden, um eine kryptographische Hash-Funktion aufzubauen, und zwar eine Einweg-Kompressionsfunktion. Die Verfahren ähneln den für die Verschlüsselung üblicherweise verwendeten Block-Cipher-Betriebsarten. Viele bekannte Hash-Funktionen, einschließlich MD4, MD5, SHA-1 und SHA-2, sind aus blockschlüsselähnlichen Komponenten aufgebaut, die dafür ausgelegt sind, mit Rückmeldung, um sicherzustellen, dass die resultierende Funktion nicht invertierbar ist. SHA-3 Finalisten enthielten Funktionen mit blockschlüsselähnlichen Komponenten (z.B. Skein, BLAKE), obwohl die zuletzt ausgewählte Funktion Keccak auf einem kryptographischen Schwamm gebaut wurde.Anstelle dieser benutzerdefinierten Block-Chiffren kann eine Standard-Block-Cipherie wie AES verwendet werden; dies könnte nützlich sein, wenn ein eingebettetes System sowohl Verschlüsselung als auch Hashing mit minimaler Codegröße oder Hardware-Bereich implementieren muss. Dieser Ansatz kann jedoch Kosten in Effizienz und Sicherheit haben. Die Chiffre in Hash-Funktionen sind für Hashing gebaut: Sie verwenden große Schlüssel und Blöcke, können effizient Schlüssel jeden Block ändern, und wurden für Widerstand gegen verwandte Schlüsselangriffe entworfen und vetted. Allgemeiner Gebrauchsschlüssel neigen dazu, unterschiedliche Designziele zu haben. Insbesondere verfügt AES über Schlüssel- und Blockgrößen, die es nicht trivial machen, um lange Hash-Werte zu generieren; AES-Verschlüsselung wird weniger effizient, wenn der Schlüssel jeden Block ändert; und damit verbundene-Key-Angriffe es potenziell weniger sicher für die Verwendung in einer Hash-Funktion als für die Verschlüsselung. Hash Funktion Design Merkle-Damgård Konstruktion Eine Hash-Funktion muss in der Lage sein, eine willkürlich lange Nachricht in einen Festlängenausgang zu verarbeiten. Dies kann erreicht werden, indem der Eingang in eine Reihe von gleich großen Blöcken zerlegt und nacheinander mit einer Einwegkompressionsfunktion betrieben wird. Die Kompressionsfunktion kann entweder speziell für das Hashing ausgelegt oder aus einem Block-Cipher aufgebaut sein. Eine Hash-Funktion, die mit der Merkle-Damgård-Konstruktion aufgebaut ist, ist ebenso widerstandsfähig gegen Kollisionen wie ihre Kompressionsfunktion; jede Kollision für die volle Hash-Funktion kann auf eine Kollision in der Kompressionsfunktion zurückverfolgt werden. Der letzte bearbeitete Block sollte auch eindeutig lang gepolstert sein; dies ist für die Sicherheit dieser Konstruktion entscheidend. Diese Konstruktion heißt Merkle–Damgård. Die häufigsten klassischen Hash-Funktionen, einschließlich SHA-1 und MD5, nehmen dieses Formular. Breites Rohr gegen schmales Rohr Eine einfache Anwendung der Merkle-Damgård-Bauweise, bei der die Größe der Hash-Ausgangsleistung gleich der inneren Zustandsgröße (zwischen jedem Kompressionsschritt) ist, ergibt ein schmalrohriges Hash-Design. Dieses Design verursacht viele inhärente Fehler, einschließlich Längenausdehnung, Multikollisionen, lange Nachrichtenangriffe, Generierungs- und Pastenangriffe und kann auch nicht parallelisiert werden. Dadurch werden moderne Hash-Funktionen auf breitrohrigen Konstruktionen gebaut, die eine größere interne Zustandsgröße aufweisen – die von Tweets der Merkle-Damgård-Konstruktion bis hin zu Neubauten wie Schwammbau und HAIFA-Konstruktion reichen. Keiner der Teilnehmer im NIST Hash-Funktionswettbewerb nutzt eine klassische Merkle-Damgård-Konstruktion. Mittlerweile, die Ausgabe einer längeren Hash, wie in SHA-512/256 verwendet, auch besiegt viele dieser Angriffe. Mit anderen kryptographischen Primitiven können Hash-Funktionen verwendet werden, um andere kryptographische Primitiven zu bauen. Damit diese anderen Primitiven kryptographisch sicher sind, muss darauf geachtet werden, sie richtig zu bauen. Nachrichtenauthentifizierungscodes (MACs) (auch als Schlüssel Hash-Funktionen bezeichnet) werden oft aus Hash-Funktionen aufgebaut. HMAC ist so ein MAC. So wie Block-Ciphers verwendet werden können, um Hash-Funktionen zu bauen, können Hash-Funktionen verwendet werden, um Block-Ciphers aufzubauen. Luby-Rackoff-Konstruktionen mit Hash-Funktionen können nachweislich sicher sein, wenn die zugrunde liegende Hash-Funktion sicher ist. Auch viele Hash-Funktionen (einschließlich SHA-1 und SHA-2) werden durch die Verwendung einer speziellen Block-Chiffre in einem Davies-Meyer oder anderen Aufbau gebaut. Diese Chiffre kann auch in einer herkömmlichen Betriebsweise verwendet werden, ohne dass die gleichen Sicherheitsgarantien bestehen. Siehe SHACAL, BEAR und LION. Pseudorandom Zahlengeneratoren (PRNGs) können mit Hash-Funktionen gebaut werden. Dies geschieht durch die Kombination eines (geheimen) zufälligen Samens mit einem Zähler und hashing es. Einige Hash-Funktionen, wie Skein, Keccak und RadioGatún, geben einen willkürlich langen Strom aus und können als Stream-Chiffre verwendet werden, und Stream-Chiffre können auch aus festverlängerten Verdauung Hash-Funktionen gebaut werden. Oft geschieht dies, indem man zunächst einen kryptographisch sicheren Pseudorandom-Nummerngenerator baut und dann seinen Strom von zufälligen Bytes als Keystream verwendet. SEAL ist ein Stream-Cipher, der SHA-1 verwendet, um interne Tabellen zu erzeugen, die dann in einem Keystream-Generator mehr oder weniger unabhängig vom Hash-Algorithmus verwendet werden. SEAL ist nicht garantiert so stark (oder schwach) wie SHA-1. Ebenso macht die Schlüsselausdehnung der HC-128- und HC-256-Stream-Chiffren die SHA-256 Hash-Funktion schwer. Concatenation Concatenating-Ausgänge aus mehreren Hash-Funktionen bieten Kollisionswiderstand so gut wie der stärkste der Algorithmen, die in dem konzedierten Ergebnis enthalten sind. Zum Beispiel verwendete ältere Versionen von Transport Layer Security (TLS) und Secure Sockets Layer (SSL) konlatierte MD5 und SHA-1 Summen.Dadurch wird sichergestellt, dass ein Verfahren zum Auffinden von Kollisionen in einer der Hash-Funktionen keine durch beide Hash-Funktionen geschützten Daten besiegt. Für Merkle–Damgård-Bau Hash-Funktionen ist die präzisierte Funktion als kollisionsbeständig wie ihre stärkste Komponente, aber nicht kollisionsbeständiger. Antoine Joux beobachtete, dass 2-Kollisionen zu n-Kollisionen führen: Wenn es für einen Angreifer möglich ist, zwei Nachrichten mit demselben MD5 Hash zu finden, dann können sie so viele zusätzliche Nachrichten mit demselben MD5 Hash finden, wie sie wünschen, ohne größere Schwierigkeiten. Unter diesen n Nachrichten mit dem gleichen MD5 Hash gibt es wahrscheinlich eine Kollision in SHA-1. Die zusätzliche Arbeit, die benötigt wird, um die SHA-1 Kollision (über die exponentielle Geburtstagssuche hinaus) zu finden, erfordert nur Polynomzeit. Cryptographische Hash-Algorithmen Es gibt viele kryptographische Hash-Algorithmen; dieser Abschnitt listet einige Algorithmen, die relativ oft referiert werden. Eine umfangreichere Liste finden Sie auf der Seite mit einem Vergleich von kryptographischen Hash-Funktionen. MD5 MD5 wurde 1991 von Ronald Rivest entworfen, um eine frühere Hash-Funktion, MD4, zu ersetzen und wurde 1992 als RFC 1321 spezifiziert. Kollisionen gegen MD5 können innerhalb von Sekunden berechnet werden, was den Algorithmus für die meisten Anwendungsfälle ungeeignet macht, wenn eine kryptographische Hash benötigt wird. MD5 erzeugt einen Aufschluss von 128 Bit (16 Bytes). SHA-1 SHA-1 wurde im Rahmen des Capstone-Projekts der US-Regierung entwickelt. Die ursprüngliche Spezifikation – jetzt allgemein SHA-0 genannt – des Algorithmus wurde 1993 unter dem Titel Secure Hash Standard, FIPS PUB 180, von der US-Regierungsstandardagentur NIST (National Institute of Standards and Technology) veröffentlicht. Es wurde von der NSA kurz nach der Veröffentlichung zurückgezogen und wurde von der überarbeiteten Version überholt, veröffentlicht 1995 in FIPS PUB 180-1 und allgemein bezeichnet SHA-1.Collisions gegen den vollen SHA-1 Algorithmus kann mit dem zerbrochenen Angriff und die Hash-Funktion sollte als gebrochen betrachtet werden. SHA-1 produziert einen Hash-Dau von 160 Bit (20 Bytes). Die Dokumente können sich auf SHA-1 als nur SHA beziehen, auch wenn dies mit den anderen Secure Hash Algorithmen wie SHA-0, SHA-2 und SHA-3 widersprechen kann. RIPEMD-160 RIPEMD (RACE Integrity Primitives Evaluation Message Digest) ist eine Familie kryptographischer Hash-Funktionen, die in Leuven, Belgien, von Hans Dobbertin, Antoon Bosselaers und Bart Preneel an der COSIC-Forschungsgruppe an der Katholieke Universiteit Leuven entwickelt und 1996 erstmals veröffentlicht wurde. RIPEMD basiert auf den Konstruktionsprinzipien, die in MD4 verwendet werden, und ist ähnlich in der Leistung wie die beliebtere SHA-1. RIPEMD-160 wurde jedoch nicht gebrochen. Wie der Name schon sagt, produziert RIPEMD-160 einen Hash-Dau von 160 Bit (20 Bytes). Whirlpool ist eine kryptographische Hash-Funktion von Vincent Rijmen und Paulo S. L. M. Barreto, die es erstmals im Jahr 2000 beschrieben. Whirlpool basiert auf einer im Wesentlichen modifizierten Version des Advanced Encryption Standard (AES). Whirlpool produziert einen Hasch-Verdau von 512 Bit (64 Bytes.) SHA-2 SHA-2 (Secure Hash Algorithm 2) ist eine Reihe kryptografischer Hash-Funktionen, die von der National Security Agency (NSA) der Vereinigten Staaten entwickelt wurden, die im Jahr 2001 veröffentlicht wurde. Sie werden mit der Merkle-Damgård-Struktur gebaut, von einer Einweg-Komprimationsfunktion selbst, die mit der Davies-Meyer-Struktur aus einer (klassifizierten) spezialisierten Block-Cipherie aufgebaut wird. SHA-2 besteht im Wesentlichen aus zwei Hash-Algorithmen: SHA-256 und SHA-512.SHA-224 ist eine Variante von SHA-256 mit unterschiedlichen Startwerten und verkürztem Ausgang. SHA-384 und die weniger bekannten SHA-512/224 und SHA-512/256 sind alle Varianten von SHA-512.SHA-512 ist sicherer als SHA-256 und ist häufig schneller als SHA-256 auf 64-Bit-Maschinen wie AMD64. Die Ausgangsgröße in Bits wird durch die Erweiterung auf den SHA-Namen angegeben, so dass SHA-224 eine Ausgangsgröße von 224 Bits (28 Bytes;) SHA-256, 32 Bytes; SHA-384, 48 Bytes; und SHA-512, 64 Bytes aufweist. SHA-3SHA-3 (Secure Hash Algorithm 3) wurde am 5. August 2015 von NIST veröffentlicht. SHA-3 ist eine Untergruppe der breiteren kryptographischen primitiven Familie Keccak. Der Keccak-Algorithmus ist die Arbeit von Guido Bertoni, Joan Daemen, Michael Peeters und Gilles Van Assche. Keccak basiert auf einer Schwammkonstruktion, die auch verwendet werden kann, um andere kryptographische Primitiven wie eine Strom-Chiffre zu bauen. SHA-3 liefert die gleichen Ausgangsgrößen wie SHA-2: 224, 256, 384 und 512 Bit. Konfigurierbare Ausgangsgrößen können auch mit den Funktionen SHAKE-128 und SHAKE-256 erreicht werden. Hier bedeuten die Erweiterungen -128 und -256 auf den Namen die Sicherheitsstärke der Funktion anstelle der Ausgabegröße in Bits.BLAKE2 BLAKE2, eine verbesserte Version von BLAKE, wurde am 21. Dezember 2012 bekannt gegeben. Es wurde von Jean-Philippe Aumasson, Samuel Neves, Zooko Wilcox-O'Hearn und Christian Winnerlein mit dem Ziel geschaffen, die weit verbreiteten, aber gebrochenen MD5 und SHA-1 Algorithmen zu ersetzen. Bei 64-Bit x64 und ARM-Architekturen ist BLAKE2b schneller als SHA-3, SHA-2, SHA-1 und MD5. Obwohl BLAKE und BLAKE2 nicht wie SHA-3 standardisiert wurden, wurde BLAKE2 in vielen Protokollen, einschließlich des Argon2-Passwort-Hashs, für die hohe Effizienz verwendet, die es auf modernen CPUs bietet. Da BLAKE Kandidat für SHA-3 war, bieten BLAKE und BLAKE2 beide die gleichen Ausgangsgrößen wie SHA-3 – einschließlich einer konfigurierbaren Ausgangsgröße. BLAKE3 BLAKE3, eine verbesserte Version von BLAKE2, wurde am 9. Januar 2020 bekannt gegeben. Es wurde von Jack O'Connor, Jean-Philippe Aumasson, Samuel Neves und Zooko Wilcox-O'Hearn erstellt. BLAKE3 ist ein einziger Algorithmus, im Gegensatz zu BLAKE und BLAKE2, die Algorithmusfamilien mit mehreren Varianten sind. Die Kompressionsfunktion BLAKE3 basiert eng auf der von BLAKE2s, wobei die Anzahl der Runden von 10 auf 7 reduziert ist. Intern ist BLAKE3 ein Merkle-Baum und unterstützt höhere Parallelitätsgrade als BLAKE2. Angriffe auf kryptographische Hash-Algorithmen Es gibt eine lange Liste von kryptographischen Hash-Funktionen, aber viele wurden als verletzlich gefunden und sollten nicht verwendet werden. Zum Beispiel wählte NIST 51 Hash-Funktionen als Kandidaten für die Runde 1 des SHA-3 Hash-Wettbewerbs, von denen 10 als gebrochen angesehen wurden und 16 signifikante Schwächen zeigten und daher nicht in die nächste Runde geschafft haben; weitere Informationen finden Sie auf dem Hauptartikel über die NIST Hash-Funktionswettbewerbe. Auch wenn eine Hash-Funktion noch nie gebrochen wurde, kann ein erfolgreicher Angriff auf eine geschwächte Variante das Vertrauen der Experten untergraben. So wurden im August 2004 Kollisionen in mehreren damals beliebten Hash-Funktionen, einschließlich MD5, gefunden. Diese Schwächen forderten die Sicherheit von stärkeren Algorithmen aus den schwachen Hash-Funktionen in Frage – insbesondere SHA-1 (eine verstärkte Version von SHA-0,) RIPEMD-128 und RIPEMD-160 (beide verstärkte Versionen von RIPEMD). Am 12. August 2004 gaben Joux, Carribault, Lemuel und Jalby eine Kollision für den vollen SHA-0-Algorithmus bekannt. Joux et al.accomplished this using a generalization of the Chabaud and Joux attack. Sie fanden heraus, dass die Kollision Komplexität 251 hatte und etwa 80.000 CPU-Stunden auf einem Supercomputer mit 256 Itanium 2 Prozessoren dauerte – entspricht 13 Tagen Vollzeit-Nutzung des Supercomputers. Im Februar 2005 wurde ein Angriff auf SHA-1 gemeldet, der bei etwa 269 Hashing-Operationen Kollision finden würde, anstatt die 280 für eine 160-Bit Hash-Funktion erwartet. Im August 2005 wurde ein weiterer Angriff auf SHA-1 gemeldet, der Kollisionen in 263 Operationen finden würde. Andere theoretische Schwächen von SHA-1 sind bekannt: und im Februar 2017 kündigte Google eine Kollision in SHA-1 an.Sicherheitsforscher empfehlen, dass neue Anwendungen diese Probleme vermeiden können, indem spätere Mitglieder der SHA-Familie, wie SHA-2, oder mit Techniken wie randomisiertes Hashing, die keine Kollisionsbeständigkeit erfordern. Ein erfolgreicher, praktischer Angriff brach MD5 in Zertifikaten für Transport Layer Security im Jahr 2008. Viele kryptographische Hasen basieren auf der Merkle-Damgård-Konstruktion. Alle kryptographischen Hashes, die direkt die volle Leistung einer Merkle-Damgård-Konstruktion nutzen, sind anfällig für Längenverlängerungsangriffe. Dies macht die MD5, SHA-1, RIPEMD-160, Whirlpool und die SHA-256 / SHA-512 Hash Algorithmen alle anfällig für diesen spezifischen Angriff. SHA-3, BLAKE2, BLAKE3 und die verkürzten SHA-2 Varianten sind für diese Art von Angriffen nicht gefährdet. Angriffe auf Hashed-Passwörter Eine häufige Verwendung von Hashes ist die Speicherung von Passwort-Authentifizierungsdaten. Anstatt den Klartext von Benutzerkennwörtern zu speichern, speichert ein kontrolliertes Zugriffssystem den Hash des Benutzerkennworts in einer Datei oder Datenbank. Wenn jemand Zugriff verlangt, wird das von ihm eingegebene Passwort überholt und mit dem gespeicherten Wert verglichen. Wenn die Datenbank gestohlen wird (ein allzu häufiges Auftreten), wird der Dieb nur die Hash-Werte haben, nicht die Passwörter. Die meisten Leute wählen jedoch Passwörter in vorhersehbarer Weise. Listen von gemeinsamen Passwörtern sind weit verbreitet und viele Passwörter sind kurz genug, dass alle möglichen Kombinationen getestet werden können, wenn schnelle Hasen verwendet werden. Die Verwendung von kryptographischem Salz verhindert einige Angriffe, wie z.B. das Erstellen von Dateien von precomputing Hash-Werten, z.B. Regenbogentabellen. Aber Recherchen in der Größenordnung von 100 Milliarden Tests pro Sekunde sind mit High-End-Grafikenprozessoren möglich, so dass direkte Angriffe auch mit Salz möglich sind.Das United States National Institute of Standards and Technology empfiehlt die Speicherung von Passwörtern mit speziellen Hashes genannt Schlüsselableitungsfunktionen (KDFs), die erstellt wurden, um brutale Kraftsuche zu verlangsamen. Slow hashes umfassen pbkdf2, bcrypt, scrypt, argon2, Ballon und einige neuere Modi von Unix crypt. Für KSFs, die mehrere Hasen zur langsamen Ausführung ausführen, empfiehlt NIST eine Iterationszahl von 10.000 oder mehr. Siehe auch Referenzen Zitate Quellen Externe Links Paar, Christof; Pelzl, Jan (2009)."11: Hash Functions". Cryptographie verstehen, Ein Lehrbuch für Studenten und Praktizierende. Springer. Archiviert aus dem Original auf 2012-12-08.(Firmen-Website enthält Online-Kryptographie-Kurs, der Hash-Funktionen umfasst) "Die ECRYPT Hash-Funktion Website". Buldas, A. (2011)."Serie von Mini-Lesern über kryptographische Hash-Funktionen". Archiviert aus dem Original am 2012-12-06.