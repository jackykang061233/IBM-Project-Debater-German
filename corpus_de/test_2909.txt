Ein eingebettetes System ist ein Computersystem - eine Kombination aus einem Computerprozessor, Computerspeicher und Ein-/Ausgabe-Peripheriegeräten -, das innerhalb eines größeren mechanischen oder elektronischen Systems eine eigene Funktion hat. Es ist im Rahmen eines kompletten Gerätes eingebettet, das oft elektrische oder elektronische Hardware und mechanische Teile umfasst. Da ein eingebettetes System typischerweise physische Operationen der Maschine steuert, in die es eingebettet ist, hat es oft Echtzeit-Computing-Zwänge. Embedded-Systeme steuern viele Geräte heute im gemeinsamen Einsatz. 2009 wurde geschätzt, dass in eingebetteten Systemen neunundvierzig Prozent aller Mikroprozessoren eingesetzt wurden. Moderne eingebettete Systeme basieren oft auf Mikrocontrollern (d.h. Mikroprozessoren mit integrierten Speicher- und Peripherieschnittstellen), aber auch gewöhnliche Mikroprozessoren (mit externen Chips für Speicher und periphere Schnittstellenschaltungen) sind häufig, insbesondere in komplexeren Systemen. In beiden Fällen können die verwendeten Prozessor(en) Typen sein, die von allgemeinem Zweck bis zu denen, die auf eine bestimmte Klasse von Berechnungen spezialisiert sind, oder sogar benutzerdefinierte für die Anwendung zur Hand. Eine gemeinsame Standardklasse von dedizierten Prozessoren ist der digitale Signalprozessor (DSP). Da das eingebettete System auf spezifische Aufgaben ausgerichtet ist, können Design-Ingenieure es optimieren, um die Größe und Kosten des Produkts zu reduzieren und die Zuverlässigkeit und Leistung zu erhöhen. Einige eingebettete Systeme sind massiv produziert und profitieren von Skalenökonomien. Embedded-Systeme reichen von tragbaren Geräten wie Digital-Uhren und MP3-Playern bis hin zu großen stationären Anlagen wie Ampel-Controllern, programmierbaren Logik-Controllern und großen komplexen Systemen wie Hybrid-Fahrzeugen, medizinischen Abbildungssystemen und Avionik. Die Komplexität variiert von niedrig, mit einem einzigen Mikrocontroller-Chip, sehr hoch mit mehreren Einheiten, Peripherie und Netzwerken in einem großen Geräte-Rack montiert. Geschichte Hintergrund Die Herkunft des Mikroprozessors und des Mikrocontrollers kann auf die MOS-Integralschaltung zurückverfolgt werden, die ein integrierter, aus MOSFETs (Metalloxid-Halbleiter-Feldeffekttransistoren) hergestellter Schaltungschip ist und Anfang der 1960er Jahre entwickelt wurde. Bis 1964 hatten MOS-Chips höhere Transistordichte und geringere Fertigungskosten als bipolare Chips erreicht. MOS-Chips steigerten die Komplexität in einer von Moore's Gesetz vorhergesagten Rate weiter, was zu einer groß angelegten Integration (LSI) mit Hunderten von Transistoren auf einem einzigen MOS-Chip bis Ende der 1960er Jahre führte. Die Anwendung von MOS LSI-Chips auf die Berechnung war die Basis für die ersten Mikroprozessoren, da Ingenieure erkannten, dass ein komplettes Computerprozessorsystem auf mehreren MOS LSI-Chips enthalten sein könnte. Die ersten Multichip-Mikroprozessoren, die Four-Phase-Systeme AL1 1969 und die Garrett AiResearch MP944 1970 wurden mit mehreren MOS LSI-Chips entwickelt. Der erste Einzelchip-Mikroprozessor war der 1971 freigegebene Intel 4004. Es wurde von Federico Faggin entwickelt, mit seiner Silizium-Gate-MOS-Technologie, zusammen mit Intel-Ingenieuren Marcian Hoff und Stan Mazor, und Busicom-Ingenieur Masatoshi Shima. Entwicklung Eines der ersten erkennbar modernen Embedded-Systeme war der Apollo Guidance Computer, der ca.1965 von Charles Stark Draper am MIT Instrumentation Laboratory entwickelt wurde. Bei der Einleitung des Projekts wurde der Apollo-Leitrechner als riskantestes Element im Apollo-Projekt betrachtet, da es die damals neu entwickelten monolithischen integrierten Schaltungen verwendet, um die Größe und das Gewicht des Computers zu reduzieren. Ein frühes Massenproduziertes Embedded-System war der Autonetics D-17-Leitrechner für die Minuteman-Rakete, veröffentlicht im Jahr 1961. Als der Minuteman II 1966 in die Produktion ging, wurde die D-17 durch einen neuen Computer ersetzt, der den ersten hochvolumigen Einsatz integrierter Schaltungen darstellte. Seit diesen frühen Anwendungen in den 1960er Jahren sind eingebettete Systeme im Preis zurückgegangen und es gab einen dramatischen Anstieg der Verarbeitungsleistung und Funktionalität. Ein früher Mikroprozessor, der Intel 4004 (released in 1971,) wurde für Rechner und andere kleine Systeme, aber immer noch benötigt externe Speicher und Support-Chips. Anfang der 1980er Jahre waren Speicher-, Eingangs- und Ausgangssystemkomponenten in den gleichen Chip integriert worden, wie der Prozessor einen Mikrocontroller bildet. Mikrocontroller finden Anwendungen, bei denen ein allgemeiner Computer zu teuer wäre. Da die Kosten von Mikroprozessoren und Mikrocontrollern die Prävalenz von eingebetteten Systemen erhöht. Heute kann ein vergleichsweise kostengünstiger Mikrocontroller programmiert werden, um die gleiche Rolle wie eine große Anzahl von separaten Komponenten zu erfüllen.Mit Mikrocontrollern wurde es möglich, auch bei Verbraucherprodukten teure knopfbasierte analoge Komponenten wie Potentiometer und variable Kondensatoren durch von einem Mikroprozessor ausgelesene Up/down-Tasten oder Knöpfe zu ersetzen. Obwohl in diesem Zusammenhang ein eingebettetes System in der Regel komplexer ist als eine herkömmliche Lösung, ist der größte Teil der Komplexität im Mikrocontroller selbst enthalten. Es können sehr wenige zusätzliche Komponenten benötigt werden und der größte Teil des Designaufwands ist in der Software. Software-Prototypen und -test können schneller verglichen mit der Konstruktion und Konstruktion einer neuen Schaltung, nicht mit einem eingebetteten Prozessor. Anwendungen Embedded-Systeme finden sich häufig in Verbraucher-, Industrie-, Automobil-, Haushaltsgeräten, medizinischen, Telekommunikations-, Handels- und Militäranwendungen. Telekommunikationssysteme nutzen zahlreiche eingebettete Systeme von Telefonschaltern für das Netzwerk bis zu Mobiltelefonen am Endbenutzer. Computer-Networking verwendet dedizierte Router und Netzwerk-Brücken zu Routendaten. Unterhaltungselektronik umfassen MP3-Player, Fernseher, Mobiltelefone, Videospielkonsolen, Digitalkameras, GPS-Empfänger und Drucker. Zu den Haushaltsgeräten wie Mikrowellenöfen, Waschmaschinen und Geschirrspülern gehören Embedded-Systeme, die Flexibilität, Effizienz und Ausstattung bieten. Fortgeschrittene HVAC-Systeme verwenden vernetzte Thermostate, um die Temperatur, die sich nach Zeit und Jahreszeit ändern kann, genauer und effizienter zu steuern. Home Automation verwendet drahtgebundene und drahtlose Netzwerkarbeit, die verwendet werden kann, um Lichter, Klima, Sicherheit, Audio/visuell, Überwachung, etc. zu steuern, die alle eingebettete Geräte zum Messen und Steuern verwenden. Transportsysteme von Flug zu Automobilen nutzen zunehmend eingebettete Systeme. Neue Flugzeuge enthalten fortgeschrittene Avionik, wie inertiale Leitsysteme und GPS-Empfänger, die auch erhebliche Sicherheitsanforderungen haben. Verschiedene Elektromotoren — bürstenlose Gleichstrommotoren, Induktionsmotoren und Gleichstrommotoren — verwenden elektronische Motorsteuerungen. Automobile, Elektrofahrzeuge und Hybridfahrzeuge nutzen zunehmend eingebettete Systeme, um die Effizienz zu maximieren und die Verschmutzung zu reduzieren. Andere Fahrzeugsicherheitssysteme mit eingebetteten Systemen umfassen Antiblockiersystem (ABS,) Elektronische Stabilitätskontrolle (ESC/ESP,) Zugsteuerung (TCS) und automatisches Vierradgetriebe. Medizinische Geräte verwenden eingebettete Systeme zur Überwachung und verschiedene medizinische Bildgebung (PET, SPECT, CT und MRT) für nicht-invasive interne Inspektionen. Embedded Systeme innerhalb medizinischer Geräte werden oft von Industriecomputern betrieben. Embedded Systeme werden für sicherheitskritische Systeme eingesetzt. Sofern nicht über on-chip 3G-zellulare oder andere Methoden zur IoT-Überwachung und -Steuerung mit drahtgebundenen oder drahtlosen Netzwerken verbunden ist, können diese Systeme vom Hacken isoliert und somit sicherer sein. Für die Brandsicherheit können die Systeme so ausgelegt sein, dass sie eine größere Fähigkeit haben, höhere Temperaturen zu bewältigen und weiter zu arbeiten. Im Umgang mit der Sicherheit können die eingebetteten Systeme selbstständig sein und mit geschnittenen elektrischen und Kommunikationssystemen umgehen können. Miniatur-WLAN-Geräte namens Motes sind vernetzte drahtlose Sensoren. Die drahtlose Sensor-Netzwerkierung nutzt die Miniaturisierung, die durch fortschrittliches IC-Design ermöglicht wird, um voll kabellose Subsysteme an anspruchsvolle Sensoren zu koppeln, die es Menschen und Unternehmen ermöglichen, eine Vielzahl von Dingen in der physischen Welt zu messen und über Überwachungs- und Kontrollsysteme auf diese Informationen einzuwirken. Diese Motes sind vollständig in sich abgeschlossen und werden typischerweise eine Batteriequelle für Jahre ablaufen, bevor die Batterien geändert oder geladen werden müssen. Merkmale Embedded-Systeme sind darauf ausgelegt, bestimmte Aufgaben zu erledigen, anstatt ein universeller Computer für mehrere Aufgaben zu sein. Einige haben auch Echtzeit-Leistungsbeschränkungen, die erfüllt werden müssen, aus Gründen wie Sicherheit und Usability; andere können geringe oder keine Leistungsanforderungen haben, so dass die Systemhardware vereinfacht werden kann, um Kosten zu reduzieren. Embedded Systeme sind nicht immer eigenständige Geräte. Viele eingebettete Systeme bestehen aus kleinen Teilen innerhalb eines größeren Geräts, das einem allgemeineren Zweck dient. Zum Beispiel verfügt der Gibson Robot Guitar über ein eingebettetes System zum Abstimmen der Saiten, aber der Gesamtzweck des Robot Guitar ist natürlich, Musik zu spielen. Ebenso bietet ein eingebettetes System in einem Automobil eine bestimmte Funktion als Teilsystem des Autos selbst. Die für Embedded-Systeme geschriebenen Programmanweisungen werden als Firmware bezeichnet und in Lesespeicher- oder Flash-Speicherchips gespeichert. Sie laufen mit begrenzten Computer-Hardware-Ressourcen: wenig Speicher, kleine oder nicht vorhandene Tastatur oder Bildschirm.Embedded-Systeme reichen von keiner Benutzeroberfläche, in Systemen, die nur einer Aufgabe gewidmet sind, bis hin zu komplexen grafischen Benutzeroberflächen, die modernen Computer-Desktop-Betriebssystemen ähneln. Einfache Embedded-Geräte verwenden Tasten, LEDs, Grafik- oder Zeichen-LCDs (z.B. HD44780 LCD) mit einem einfachen Menüsystem. Mehr ausgefeilte Geräte, die einen grafischen Bildschirm mit Touch-Sensing oder Screen-Edge Soft-Tasten verwenden, bieten Flexibilität, während der Minimierung von Raum verwendet: die Bedeutung der Tasten kann sich mit dem Bildschirm ändern, und die Auswahl beinhaltet das natürliche Verhalten der Anzeige auf das, was gewünscht wird. Einige Systeme bieten die Benutzeroberfläche remote mit Hilfe einer seriellen (z.B. RS-232) oder Netzwerk (z.B. Ethernet) Verbindung. Dieser Ansatz erweitert die Fähigkeiten des eingebetteten Systems, vermeidet die Kosten eines Displays, vereinfacht BSP und ermöglicht es Designern, eine reiche Benutzeroberfläche auf dem PC aufzubauen. Ein gutes Beispiel hierfür ist die Kombination eines eingebetteten HTTP-Servers, der auf einem eingebetteten Gerät (z.B. einer IP-Kamera oder einem Netzwerkrouter) läuft. Die Benutzeroberfläche wird in einem Webbrowser auf einem mit dem Gerät verbundenen PC angezeigt. Prozessoren in Embedded-Systemen Beispiele für Eigenschaften typischer eingebetteter Computer, im Vergleich zu universellen Gegenstücken, sind geringe Stromaufnahme, geringe Größe, robuste Betriebsbereiche und niedrige Kosten pro Einheit. Dies kommt zum Preis begrenzter Verarbeitungsressourcen. Für den Einsatz von eingebetteten Systemen wurden zahlreiche Mikrocontroller entwickelt. Allgemeine Mikroprozessoren werden auch in eingebetteten Systemen eingesetzt, benötigen aber im allgemeinen mehr Unterstützungsschaltung als Mikrocontroller. Ready-made Computer Boards PC/104 und PC/104+ sind Beispiele für Standards für fertige Computer-Boards für kleine, Low-Volume eingebettete und robuste Systeme. Diese sind meist x86-basiert und oft physisch klein im Vergleich zu einem Standard-PC, obwohl noch ziemlich groß im Vergleich zu den einfachsten (8/16-Bit) eingebetteten Systemen. Sie können DOS, Linux, NetBSD oder ein eingebettetes Echtzeit-Betriebssystem wie MicroC/OS-II, QNX oder VxWorks verwenden. Bei bestimmten Anwendungen, bei denen kleine Größe oder Leistungseffizienz nicht primäre Anliegen sind, können die verwendeten Komponenten mit denen in allgemeiner x86-Personalcomputer verwendet werden. Boards wie die VIA EPIA-Serie helfen, die Lücke zu überbrücken, indem sie PC-kompatibel, aber hochintegriert, physisch kleiner oder andere Attribute haben, die sie für Embedded Engineers attraktiv machen. Der Vorteil dieses Ansatzes ist, dass kostengünstige Rohstoffkomponenten zusammen mit den gleichen Software-Entwicklungstools zur allgemeinen Softwareentwicklung eingesetzt werden können. So aufgebaute Systeme werden immer noch als eingebettet angesehen, da sie in größere Geräte integriert sind und eine Rolle erfüllen. Beispiele für Geräte, die diesen Ansatz annehmen können, sind Geldautomaten und Arcade-Maschinen, die einen für die Anwendung spezifischen Code enthalten. Allerdings sind die meisten fertigen Embedded-Systeme Boards nicht PC-zentriert und verwenden nicht die ISA oder PCI-Busse. Wenn ein System-on-a-Chip-Prozessor beteiligt ist, kann es von Vorteil sein, eine standardisierte Busverbindung diskrete Komponenten zu haben, und die Umgebung für Hardware- und Software-Tools kann sehr unterschiedlich sein. Ein gemeinsamer Design-Stil verwendet ein kleines System-Modul, vielleicht die Größe einer Visitenkarte, hält hohe Dichte BGA-Chips wie einen ARM-basierten System-on-a-Chip-Prozessor und Peripherie, externe Flash-Speicher für Speicher, und DRAM für Laufzeit-Speicher. Der Modul-Anbieter wird in der Regel Boot-Software bereitstellen und sicherstellen, dass es eine Auswahl an Betriebssystemen gibt, in der Regel einschließlich Linux und einige Echtzeit-Optionen. Diese Module können in hohem Volumen hergestellt werden, von Organisationen, die mit ihren spezialisierten Testthemen vertraut sind, und kombiniert mit viel niedrigeren Lautstärke benutzerdefinierte Mainboards mit anwendungsspezifischen externen Peripheriegeräten. Die Implementierung von Embedded-Systemen hat sich so entwickelt, dass sie mit bereits erstellten Boards, die auf weltweit akzeptierten Plattformen basieren, leicht implementiert werden können. Diese Plattformen umfassen, sind aber nicht beschränkt auf, Arduino und Raspberry Pi. ASIC und FPGA SoC Lösungen Ein häufiges Array für hochvolumige Embedded Systeme wie Mobiltelefone und Smartphones, aber auch für (nicht-so-hochvolume) Embedded Systeme mit besonderen Bedürfnissen in Art von Signalverarbeitung Leistung, Schnittstellen und Zuverlässigkeit, wie in Avionik, ist das System auf einem Chip (SoC). Ein SoC enthält ein komplettes System - bestehend aus mehreren Prozessoren, Multiplikatoren, Caches, sogar verschiedenen Arten von Speichern und häufig verschiedenen Peripheriegeräten wie Schnittstellen für drahtgebundene oder drahtlose Kommunikation auf einem einzigen Chip.Oft sind Grafikverarbeitungseinheiten (GPU) und digitale Signalprozessoren (DSP) solche Chips enthalten. SoCs können als anwendungsspezifische integrierte Schaltung (ASIC) oder mittels eines feldprogrammierbaren Gate-Arrays (FPGA) realisiert werden, das typischerweise rekonfiguriert werden kann. Peripherie Embedded Systeme sprechen mit der Außenwelt über Peripheriegeräte, wie: Serial Communication Interfaces (SCI:) RS-232, RS-422, RS-485, etc.Synchronous Serielle Kommunikation Schnittstelle: I2C, SPI, SSC und ESSI (Enhanced Synchronous Serial Interface)Universal Serial Bus (USB) Multi Media Cards (SD Karten, Compact Flash, etc.) Netzwerke: Ethernet, LonWorks, etc. Feldbusse: CAN-Bus, LIN-Bus, PROFIBUS, etc. Timer: PLL(s,) Capture/Compare und Time Processing Units Diskrete IO: aka General Purpose Input/Output (GPIO) Analog zu Digital/Digital zu Analog (ADC/DAC)Debugging: JTAG, ISP, BDM Port, BITP und DB9 Ports. Werkzeuge Wie bei anderen Software verwenden Embedded System Designer Compiler, Assembler und Debugger, um Embedded System Software zu entwickeln. Sie können jedoch auch einige spezifischere Werkzeuge verwenden: In Schaltung Debugger oder Emulatoren (siehe nächsten Abschnitt). Utilities, um eine Prüfsumme oder CRC zu einem Programm hinzuzufügen, so kann das eingebettete System überprüfen, ob das Programm gültig ist. Für Systeme mit digitaler Signalverarbeitung können Entwickler einen Mathe-Workbench verwenden, um die Mathematik zu simulieren. System-Level-Modellierungs- und Simulationstools helfen Designern, Simulationsmodelle eines Systems mit Hardwarekomponenten wie Prozessoren, Speichern, DMA, Schnittstellen, Bussen und Software-Verhaltensfluss als Zustandsdiagramm oder Flussdiagramm mit konfigurierbaren Bibliotheksblöcken zu konfigurieren. Die Simulation wird durchgeführt, um die richtigen Komponenten zu wählen, indem Power gegen Performance-Trade-off, Zuverlässigkeitsanalyse und Engpassanalyse durchgeführt wird. Typische Berichte, die einem Designer helfen, Architekturentscheidungen zu treffen, umfassen Anwendung Latenz, Gerätedurchsatz, Geräteauslastung, Stromverbrauch des gesamten Systems sowie Geräte-Level Stromverbrauch. Ein modellbasiertes Entwicklungstool erstellt und simuliert grafischen Datenfluss und UML-Zustandsdiagramme von Komponenten wie Digitalfiltern, Motorsteuerungen, Kommunikationsprotokoll-Decodierung und Mehrratenaufgaben. Benutzerdefinierte Compiler und Linker können verwendet werden, um spezialisierte Hardware zu optimieren. Ein eingebettetes System kann eine eigene spezielle Sprache oder Design-Tool haben oder Erweiterungen zu einer bestehenden Sprache wie Forth oder Basic hinzufügen. Eine weitere Alternative besteht darin, ein Echtzeit-Betriebssystem oder ein eingebettetes Betriebssystem hinzuzufügen Modellierungs- und Code-Generierungswerkzeuge, die oft auf staatlichen Maschinen basieren Software-Tools können aus mehreren Quellen kommen: Software-Unternehmen, die sich auf den eingebetteten Markt spezialisiert Ported aus den GNU Software-Entwicklungstools Manchmal können Entwicklungstools für einen persönlichen Computer verwendet werden, wenn der eingebettete Prozessor ein enger Bezug zu einem gemeinsamen PC-Prozessor ist Da die Komplexität eingebetteter Systeme wächst, wandern hochrangige Werkzeuge und Betriebssysteme in Maschinen, wo es Sinn macht. Zum Beispiel benötigen Handys, persönliche digitale Assistenten und andere Verbrauchercomputer oft eine signifikante Software, die von einer anderen Person als dem Hersteller der Elektronik gekauft oder bereitgestellt wird. In diesen Systemen ist eine offene Programmierumgebung wie Linux, NetBSD, OSGi oder Embedded Java erforderlich, so dass der Drittanbieter an einen großen Markt verkaufen kann. Embedded-Systeme finden sich häufig in Verbraucher-, Koch-, Industrie-, Automobil- und medizinischen Anwendungen. Einige Beispiele für eingebettete Systeme sind MP3-Player, Mobiltelefone, Videospielkonsolen, Digitalkameras, DVD-Player und GPS. Zu den Haushaltsgeräten wie Mikrowellenöfen, Waschmaschinen und Geschirrspülern gehören Embedded-Systeme, die Flexibilität und Effizienz bieten. Debugging Embedded Debugging kann auf verschiedenen Ebenen durchgeführt werden, je nach den verfügbaren Einrichtungen. Die unterschiedlichen Metriken, die die verschiedenen Formen der eingebetteten Debugging charakterisieren, sind: verlangsamt die Hauptanwendung, wie nah ist das debugged-System oder die Anwendung auf das eigentliche System oder die Anwendung, wie ausdrucksstark sind die Trigger, die zum Debuggen gesetzt werden können (z.B. inspizieren des Speichers, wenn ein bestimmter Programm-Zählerwert erreicht ist), und was im Debugging-Prozess (z. Vom einfachsten bis anspruchsvollsten können sie grob in die folgenden Bereiche gruppiert werden: Interaktive ortsansässige Debugging, mit der einfachen Shell, die vom eingebetteten Betriebssystem (z.B. Forth und Basic) bereitgestellt wird Externes Debugging mit Protokollierung oder seriellem Port-Ausgang, um den Betrieb mit entweder einem Monitor in Flash oder mit einem Debug-Server wie dem Remedy Debugger zu verfolgen, der auch für heterogene Multicore-Systeme arbeitet.Ein In-Schaltungs-Debugger (ICD), ein Hardwaregerät, das über eine JTAG- oder Nexus-Schnittstelle mit dem Mikroprozessor verbunden ist. Dies ermöglicht eine externe Steuerung des Mikroprozessors, ist jedoch typischerweise auf bestimmte Debugging-Funktionen im Prozessor beschränkt. Ein In-Kreislauf-Emulator (ICE) ersetzt den Mikroprozessor durch ein simuliertes Äquivalent und sorgt für eine vollständige Kontrolle über alle Aspekte des Mikroprozessors. Ein kompletter Emulator bietet eine Simulation aller Aspekte der Hardware, so dass alles gesteuert und geändert werden kann und ein Debugging auf einem normalen PC ermöglicht. Die Nachteile sind Kosten und langsame Operation, in einigen Fällen bis zu 100 mal langsamer als das endgültige System. Für SoC-Designs ist der typische Ansatz, das Design auf einem FPGA-Prototypboard zu überprüfen und zu debuggen. Werkzeuge wie Certus werden verwendet, um Sonden im FPGA RTL einzufügen, die Signale zur Beobachtung zur Verfügung stellen. Dies wird verwendet, um Hardware-, Firmware- und Software-Interaktionen über mehrere FPGA-Funktionen zu debugen, die einem Logikanalysator ähnlich sind. Software-only Debugger haben den Vorteil, dass sie keine Hardware-Änderung benötigen, sondern sorgfältig kontrollieren müssen, was sie aufnehmen, um Zeit und Speicherplatz zu erhalten. Sofern nicht auf externe Debugging beschränkt, kann der Programmierer typischerweise Software durch die Werkzeuge laden und ausführen, den im Prozessor laufenden Code ansehen und seinen Betrieb starten oder stoppen. Die Ansicht des Codes kann als HLL Quellcode, Montagecode oder Mischung von beiden sein. Da ein eingebettetes System oft aus einer Vielzahl von Elementen besteht, kann die Debugging-Strategie variieren. So unterscheidet sich z.B. das Debuggen eines software- (und mikroprozessor-)zentrischen Embedded-Systems vom Debuggen eines Embedded-Systems, bei dem die meisten Verarbeitungen von Peripheriegeräten (DSP, FPGA und Co-Prozessor) durchgeführt werden. Eine zunehmende Anzahl eingebetteter Systeme verwendet heute mehr als einen einzigen Prozessorkern. Ein häufiges Problem bei der Multi-Core-Entwicklung ist die richtige Synchronisation der Software-Ausführung. In diesem Fall kann die eingebettete Systemauslegung den Datenverkehr auf den Bussen zwischen den Prozessorkernen überprüfen wollen, was eine sehr pegelarme Debugging z.B. auf Signal/Bus-Ebene mit einem Logikanalysator erfordert. Die Verfolgung von Echtzeit-Betriebssystemen (RTOS) unterstützt oft die Verfolgung von Betriebssystemereignissen. Eine grafische Ansicht wird von einem Host-PC-Tool dargestellt, basierend auf einer Aufnahme des Systemverhaltens. Die Trace-Aufzeichnung kann in Software, durch das RTOS oder durch spezielle Tracing-Hardware durchgeführt werden. RTOS-Tracing ermöglicht es Entwicklern, Timing- und Performance-Probleme des Softwaresystems zu verstehen und gibt ein gutes Verständnis der hochrangigen Systemverhalten. Zuverlässigkeit Embedded-Systeme befinden sich oft in Maschinen, die für Jahre ohne Fehler laufen sollen, und sich in einigen Fällen von selbst erholen, wenn ein Fehler auftritt. Daher wird die Software in der Regel sorgfältiger entwickelt und getestet als für Personalcomputer, und unzuverlässige mechanische bewegte Teile wie Laufwerke, Schalter oder Tasten werden vermieden. Spezifische Zuverlässigkeitsprobleme können umfassen: Das System kann nicht sicher zur Reparatur abgeschaltet werden, oder es ist zu unzugänglich zu reparieren. Beispiele sind Raumsysteme, Unterwasserkabel, Navigationsbaken, Bohrlochsysteme und Automobile. Das System muss aus Sicherheitsgründen laufen gehalten werden. "Limp-Modi" sind weniger tolerierbar. Oft werden Backups von einem Bediener ausgewählt. Beispiele sind Flugzeugnavigation, Reaktorsteuerungen, sicherheitskritische chemische Fabriksteuerungen, Zugsignale. Das System wird große Mengen an Geld verlieren, wenn geschlossen: Telefonschalter, Werkssteuerungen, Brücken- und Aufzugssteuerungen, Geldtransfer und Marketing, automatisierter Vertrieb und Service. Eine Vielzahl von Techniken werden verwendet, manchmal in Kombination, um sich von Fehlern zu erholen - sowohl Software-Bugs wie Speicherlecks, als auch Soft-Fehler in der Hardware: Watchdog-Timer, der den Computer zurücksetzt, es sei denn, die Software regelmäßig notifiziert die Watchdog-Subsysteme mit redundanten Ersatzteilen, die auf Software "Limp-Modi" umgeschaltet werden können, die Teilfunktion Designing with a Trusted Computing Base (TCB) gewährleistet eine hochsichere und zuverlässige eingebettete Umgebung Diese Verkapselung hält Fehler von der Ausbreitung von einem Teilsystem zu einem anderen, wodurch die Zuverlässigkeit verbessert wird.Dadurch kann auch ein Teilsystem bei der Fehlererkennung automatisch abgeschaltet und neu gestartet werden. Immunität Aware Programmierung High vs. niedriges Volumen Für High-Volumen-Systeme wie tragbare Musik-Player oder Handys, Minimierung Kosten ist in der Regel die primäre Design-Betrachtung. Ingenieure wählen typischerweise Hardware, die nur „gut genug“ ist, um die notwendigen Funktionen umzusetzen. Für Low-Volume oder Prototyp eingebettete Systeme können allgemeine Computer durch Begrenzung der Programme oder durch Ersatz des Betriebssystems durch ein Echtzeit-Betriebssystem angepasst werden. Embedded Software-Architekturen Im Jahr 1978 veröffentlichte die National Electrical Manufacturers Association einen Standard für programmierbare Mikrocontroller, darunter fast alle computergestützten Controller, wie Einplatinenrechner, numerische und ereignisbasierte Controller. Es gibt mehrere verschiedene Arten von Software-Architektur in der gemeinsamen Nutzung heute. Einfache Regelschleife In diesem Design hat die Software einfach eine Schleife. Die Schleife ruft Unterprogramme an, die jeweils einen Teil der Hardware oder Software verwalten. Es wird also eine einfache Regelschleife oder Regelschleife genannt. Interrupt-gesteuertes System Einige eingebettete Systeme werden überwiegend durch Unterbrechungen gesteuert. Dies bedeutet, dass von dem System ausgeführte Aufgaben durch verschiedene Arten von Ereignissen ausgelöst werden; ein Interrupt könnte beispielsweise durch einen Timer in einer vorgegebenen Frequenz erzeugt werden, oder durch eine serielle Portsteuerung, die einen Byte empfängt. Diese Arten von Systemen werden verwendet, wenn Event-Handler eine geringe Latenz benötigen, und die Event-Handler sind kurz und einfach. In der Regel laufen diese Arten von Systemen eine einfache Aufgabe auch in einer Hauptschleife, aber diese Aufgabe ist nicht sehr empfindlich auf unerwartete Verzögerungen. Manchmal wird der Interrupt-Handler längere Aufgaben zu einer Warteschlangenstruktur hinzufügen. Später werden diese Aufgaben nach Beendigung des Interrupt-Handlers durch die Hauptschleife ausgeführt. Diese Methode bringt das System in der Nähe eines Multitasking-Kernels mit diskreten Prozessen. Kooperative Multitasking Ein nicht-präemptives Multitasking-System ist sehr ähnlich wie das einfache Regelschleifensystem, außer dass die Schleife in einer API versteckt ist. Der Programmierer definiert eine Reihe von Aufgaben, und jede Aufgabe bekommt eine eigene Umgebung zu „laufen“ in. Wenn eine Aufgabe leer ist, nennt sie eine Leerlaufroutine, in der Regel "Pause", "Warte", "Ausbeute", "Nop" (Stand für keine Operation,) etc. Die Vor- und Nachteile sind ähnlich wie die der Regelschleife, mit der Ausnahme, dass das Hinzufügen neuer Software einfacher ist, durch einfaches Schreiben einer neuen Aufgabe oder Hinzufügen der Warteschlange. Präemptive Multitasking oder Multi-Threading Bei dieser Art von System schaltet ein Low-Level-Stück von Code zwischen Aufgaben oder Threads basierend auf einem Timer (verbunden mit einem Interrupt). Dies ist die Ebene, auf der das System allgemein als "Betriebssystem"-Kernel betrachtet wird. Je nachdem, wie viel Funktionalität erforderlich ist, führt sie mehr oder weniger die Komplexitäten des Managements mehrerer Aufgaben ein, die konzeptuell parallel laufen. Da jeder Code die Daten einer anderen Aufgabe (außer bei größeren Systemen mit einem MMU) möglicherweise beschädigen kann, müssen die Programme sorgfältig gestaltet und getestet werden, und der Zugriff auf gemeinsame Daten muss durch eine Synchronisationsstrategie gesteuert werden, wie Nachrichtenwarten, Semaphoren oder ein nicht blockierendes Synchronisationssystem. Aufgrund dieser Komplexitäten ist es für Organisationen üblich, ein Echtzeit-Betriebssystem (RTOS) zu verwenden, das es den Anwendungsprogrammierern ermöglicht, sich auf Gerätefunktionen zu konzentrieren und nicht auf Betriebssystemdienste, zumindest für große Systeme; kleinere Systeme können aufgrund von Einschränkungen in Bezug auf Speichergröße, Leistung oder Akkulaufzeit oft nicht den mit einem generischen Echtzeitsystem verbundenen Overhead leisten. Die Wahl, dass ein RTOS erforderlich ist, bringt jedoch eigene Probleme mit sich, da die Auswahl vor Beginn des Anwendungsentwicklungsprozesses getroffen werden muss. Diese Timing zwingt Entwickler, das eingebettete Betriebssystem für ihr Gerät basierend auf aktuellen Anforderungen auszuwählen und so zukünftige Optionen weitgehend einzuschränken. Die Beschränkung zukünftiger Optionen wird mehr als ein Problem, da die Produktlebensdauer abnimmt. Darüber hinaus wächst die Komplexität kontinuierlich, da Geräte erforderlich sind, um Variablen wie serielle, USB, TCP/IP, Bluetooth, Wireless LAN, Stammfunk, mehrere Kanäle, Daten und Stimme, verbesserte Grafiken, mehrere Zustände, mehrere Threads, zahlreiche Wartezustände und so weiter zu verwalten. Diese Trends führen neben einem Echtzeit-Betriebssystem zur Aufnahme von Embedded Middleware. Mikrokerne und Exokerne Ein Mikrokernel ist ein logischer Schritt aus einem Echtzeit-Betriebssystem. Die übliche Anordnung ist, dass der Betriebssystemkern den Speicher zuordnet und die CPU auf verschiedene Ausführungsfäden schaltet.User-Mode-Prozesse implementieren wichtige Funktionen wie Dateisysteme, Netzwerkschnittstellen, etc. Im Allgemeinen gelingt es Mikrokernen, wenn Task-Schaltung und Intertask-Kommunikation schnell ist und scheitert, wenn sie langsam sind. Exokernels kommunizieren effizient durch normale Unterroutine-Anrufe. Die Hardware und die gesamte Software im System sind durch Anwendungsprogrammierer verfügbar und erweiterbar. Monolithische Kerne In diesem Fall wird ein relativ großer Kernel mit ausgefeilten Fähigkeiten an eine eingebettete Umgebung angepasst. Dies gibt Programmierern eine Umgebung ähnlich einem Desktop-Betriebssystem wie Linux oder Microsoft Windows, und ist daher sehr produktiv für die Entwicklung; auf der Unterseite erfordert es erheblich mehr Hardware-Ressourcen, ist oft teurer, und aufgrund der Komplexität dieser Kernel kann weniger vorhersehbar und zuverlässig sein. Gemeinsame Beispiele für eingebettete monolithische Kerne sind eingebettete Linux, VXWorks und Windows CE. Trotz der erhöhten Kosten in der Hardware steigt diese Art von Embedded-System in der Popularität, vor allem auf den leistungsfähigeren Embedded-Geräten wie drahtlose Router und GPS-Navigation-Systeme. Hier sind einige der Gründe: Ports zu gemeinsamen Embedded-Chip-Sets sind verfügbar. Sie ermöglichen eine erneute Nutzung des öffentlich verfügbaren Codes für Gerätetreiber, Webserver, Firewalls und anderen Code. Entwicklungssysteme können mit breiten Feature-Sets beginnen, und dann kann die Distribution konfiguriert werden, um nicht benötigte Funktionalität auszuschließen und den Aufwand des Speichers zu sparen, den sie verbrauchen würde. Viele Ingenieure glauben, dass der laufende Anwendungscode im Benutzermodus zuverlässiger und einfacher zu debug ist, wodurch der Entwicklungsprozess einfacher und der Code tragbarer wird. Eigenschaften, die eine schnellere Reaktion erfordern als garantiert werden können, können oft in Hardware platziert werden. Zusätzliche Softwarekomponenten Neben dem Kernbetriebssystem weisen viele eingebettete Systeme zusätzliche Oberschicht-Softwarekomponenten auf. Diese Komponenten bestehen aus Netzwerk-Protokoll-Stacks wie CAN, TCP/IP, FTP, HTTP und HTTPS und enthalten auch Speichermöglichkeiten wie FAT und Flash-Speicher-Management-Systeme. Wenn das eingebettete Gerät Audio- und Videofunktionen hat, werden die entsprechenden Treiber und Codecs im System vorhanden sein. Bei den monolithischen Kernen sind viele dieser Softwareschichten enthalten. In der Kategorie RTOS hängt die Verfügbarkeit der zusätzlichen Softwarekomponenten vom kommerziellen Angebot ab. Domain-spezifische Architekturen Im Automobilbereich ist AUTOSAR eine Standardarchitektur für Embedded Software. Siehe auch Hinweise ReferenzenWeiterlesen John Catsoulis (Mai 2005). Designing Embedded Hardware, 2. Edition.O'Reilly. ISBN 0-596-00755-8. James M. Conrad; Alexander G. Dean (September 2011). Embedded Systems, Eine Einführung mit dem Renesas RX62N Microcontroller.Micrium.ISBN 978-1935-7729-96. Klaus Elk (August 2016). Embedded Software Entwicklung für das Internet der Dinge, die Grundlagen, die Technologien und Best Practices. ISBN 978-1534602533. Externe Links Embedded Systems Kurs mit mbed YouTube, laufende ab 2015 Trends in Cyber Security und Embedded Systems Dan Geer, November 2013Moderne Embedded Systems Programming Video Course YouTube, laufende 2013 Embedded Systems Week (ESWEEK) jährliche Veranstaltung mit Konferenzen, Workshops und Tutorials, die alle Aspekte eingebetteter Systeme und Software abdecken Workshop zum Thema Embedded und Cyber-Physical Systems Education, Workshop zum Thema Bildungsaspekte eingebetteter Systeme