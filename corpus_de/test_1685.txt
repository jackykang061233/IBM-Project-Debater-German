Bei der Computerprogrammierung ist die Gen-Expressions-Programmierung (GEP) ein evolutionärer Algorithmus, der Computerprogramme oder Modelle erstellt. Diese Computerprogramme sind komplexe Baumstrukturen, die lernen und anpassen, indem sie ihre Größen, Formen und Zusammensetzung ändern, ähnlich wie ein lebendiger Organismus. Und wie Lebewesen werden auch die Computerprogramme von GEP in einfachen linearen Chromosomen fester Länge kodiert. So ist GEP ein Genotyp-Phenotyp-System, das von einem einfachen Genom profitiert, um die genetischen Informationen und einen komplexen Phänotyp zu halten und zu übertragen, um die Umwelt zu erkunden und sich an sie anzupassen. Hintergrund Evolutionsalgorithmen verwenden Populationen von Individuen, wählen Sie Individuen nach Fitness, und führen genetische Variation mit einem oder mehreren genetischen Operatoren. Ihr Einsatz in künstlichen Rechensystemen stammt aus den 1950er Jahren, wo sie zur Lösung von Optimierungsproblemen verwendet wurden (z.B. Box 1957 und Friedman 1959). Aber mit der Einführung von Evolutionsstrategien von Rechenberg im Jahr 1965 gewannen evolutionäre Algorithmen Popularität. Ein guter Überblickstext zu evolutionären Algorithmen ist das Buch "Eine Einführung in genetische Algorithmen" von Mitchell (1996). Genexpressions-Programmierung gehört zur Familie evolutionärer Algorithmen und ist eng mit genetischen Algorithmen und genetischer Programmierung verbunden. Von genetischen Algorithmen erbte es die linearen Chromosomen von fester Länge; und von der genetischen Programmierung erbte es die expressive Parse Bäume von verschiedenen Größen und Formen. Bei der Genexpressions-Programmierung arbeiten die linearen Chromosomen als Genotyp und die Parse Bäume als Phänotyp, wodurch ein Genotyp/Phenotyp-System entsteht. Dieses Genotyp/Phenotyp-System ist multigen, so kodieren mehrere Parse Bäume in jedem Chromosom. Das bedeutet, dass die von GEP erstellten Computerprogramme aus mehreren Parsebäumen bestehen. Da diese Parse Bäume das Ergebnis der Genexpression sind, werden sie in GEP als Expressionsbäume bezeichnet. Kodierung: der Genotyp Das Genom der Genexpressions-Programmierung besteht aus einem linearen, symbolischen String oder Chromosomen fester Länge, bestehend aus einem oder mehreren Genen gleicher Größe. Diese Gene, trotz ihrer festen Länge, Code für Expression Bäume unterschiedlicher Größe und Formen. Ein Beispiel für ein Chromosom mit zwei Genen, jede der Größe 9, ist der String (Position Null gibt den Start jedes Gens an:) 012345678012345678 L+a-baccd**cLabacdwo "L" die natürliche Logarithmfunktion darstellt und "a", "b", "c" und "d" die Variablen und Konstanten darstellen, die in einem Problem verwendet werden. Ausdrucksbäume: der Phänotyp Wie oben gezeigt, haben die Gene der Genexpressions-Programmierung dieselbe Größe. Diese festen Längenstrings Code für Ausdruck Bäume unterschiedlicher Größe. Dies bedeutet, dass die Größe der kodierenden Regionen von Gen zu Gen variiert, so dass Anpassung und Evolution reibungslos auftreten können. Beispielsweise kann der mathematische Ausdruck: (a - b ) (c + d ) \{displaystyle \{sqrt {a-b)(c+d}\, auch als Expressionsbaum dargestellt werden: wobei "Q" die Quadratwurzelfunktion darstellt. Diese Art von Expressionsbaum besteht aus der phenotypischen Expression von GEP-Genen, während die Gene lineare Strings sind, die diese komplexen Strukturen kodieren. Für dieses spezielle Beispiel entspricht der lineare String: 01234567 Q*-+abcd, das ist das einfache Lesen des Expressionsbaums von oben nach unten und von links nach rechts. Diese linearen Strings werden k-Expressionen (aus Karva-Notation) genannt. Von k-expressionen zur Expression von Bäumen zu gehen ist auch sehr einfach. Beispielsweise die folgende k-Expression: 01234567890 Q*b**+ba Qbais besteht aus zwei verschiedenen Terminals (die Variablen "a" und "b"), zwei verschiedenen Funktionen von zwei Argumenten ("*" und "+") und einer Funktion eines Arguments ("Q"). Seine Expression gibt: K-Expressionen und Gene Die k-Expressionen der Genexpressions-Programmierung entsprechen der Region der Gene, die exprimiert wird. Das bedeutet, dass es Sequenzen in den Genen geben könnte, die nicht exprimiert werden, was für die meisten Gene wahr ist. Der Grund für diese nichtkodierenden Bereiche ist, einen Puffer von Terminals bereitzustellen, so dass alle in GEP-Genen kodierten k-Expressionen stets gültigen Programmen oder Expressionen entsprechen. Die Gene der Genexpressions-Programmierung bestehen daher aus zwei unterschiedlichen Domänen – einem Kopf und einem Schwanz – mit jeweils unterschiedlichen Eigenschaften und Funktionen. Der Kopf wird hauptsächlich verwendet, um die zur Lösung des Problems gewählten Funktionen und Variablen zu kodieren, während der Schwanz, während auch zur Kodierung der Variablen verwendet, im Wesentlichen ein Reservoir von Terminals liefert, um sicherzustellen, dass alle Programme fehlerfrei sind. Für GEP-Gene wird die Länge des Schwanzes durch die Formel gegeben: t = h (n max - 1 ) + 1 \{Displaystyle t=h(n_{\max -1)+1, wobei h die Länge des Kopfes und nmax die maximale Arität ist. Beispielsweise für ein Gen, das unter Verwendung des Satzes der Funktionen F = {Q, +, -, *, /} und des Satzes der Terminals T = {a, b}, nmax = 2.Und wenn wir eine Kopflänge von 15, dann t = 15 (2–1) + 1 = 16 wählen, was eine Genlänge g von 15+ 16 = 31 ergibt. Die nachfolgend zufällig erzeugte Saite ist ein Beispiel für ein solches Gen: 01234567890123456789012345678901234567890 *b+aQab+//+b+babbababbaaaa Es kodiert den Expressionsbaum: der hier nur 8 der 31 Elemente verwendet, die das Gen bilden. Es ist nicht schwer zu erkennen, dass jedes Gen trotz seiner festen Länge das Potential zur Expression von Bäumen unterschiedlicher Größe und Formen hat, wobei das einfachste aus nur einem Knoten (wenn das erste Element eines Gens ein Terminal ist) und das größte aus so vielen Knoten besteht, wie es Elemente im Gen gibt (wenn alle Elemente im Kopf Funktionen mit maximaler Arität sind). Es ist auch nicht schwer zu sehen, dass es trivial ist, alle Arten von genetischer Modifikation (Mutation, Inversion, Insertion, Rekombination usw.) mit der Garantie, dass alle resultierenden Nachkommen kodieren korrekte, fehlerfreie Programme. Multigene Chromosomen Die Chromosomen der Genexpressions-Programmierung bestehen üblicherweise aus mehr als einem Gen gleicher Länge. Jedes Gen kodiert für einen Subexpressionsbaum (Sub-ET) oder Unterprogramm. Dann können die Sub-ETs auf unterschiedliche Weise miteinander interagieren und ein komplexeres Programm bilden. Die Figur zeigt ein Beispiel eines Programms aus drei Teil-ETs. Im Endprogramm könnten die Sub-ETs durch Addition oder eine andere Funktion verknüpft werden, da es keine Einschränkungen bezüglich der Art der Verknüpfungsfunktion gibt, die man wählen könnte. Einige Beispiele komplexerer Linker sind die Aufnahme des Durchschnitts, der Median, die Mittellinie, die Schwelle ihrer Summe, um eine binomiale Klassifizierung zu machen, die Anwendung der Sigmoid-Funktion, um eine Wahrscheinlichkeit zu berechnen, und so weiter. Diese Verknüpfungsfunktionen werden in der Regel a priori für jedes Problem gewählt, sie können aber auch elegant und effizient durch das zelluläre System der Genexpressions-Programmierung entwickelt werden. Wiederverwendung von Zellen und Codes In der Genexpressions-Programmierung steuern Homeotische Gene die Interaktionen der verschiedenen Sub-ETs oder Module des Hauptprogramms. Die Expression solcher Gene führt zu unterschiedlichen Hauptprogrammen oder Zellen, d.h. sie bestimmen, welche Gene in jeder Zelle exprimiert werden und wie die Sub-ETs jeder Zelle miteinander interagieren. Mit anderen Worten bestimmen homöotische Gene, welche Sub-ETs aufgerufen werden und wie oft in welchem Hauptprogramm oder Zelle und welche Art von Verbindungen sie miteinander aufbauen. Homeotische Gene und das zelluläre System Homeotische Gene haben genau die gleiche Art von Strukturorganisation wie normale Gene und werden mit einem identischen Prozess gebaut. Sie enthalten auch eine Kopfdomäne und eine Schwanzdomäne, mit dem Unterschied, dass die Köpfe jetzt Verknüpfungsfunktionen und eine spezielle Art von Terminals – Genic Terminals – enthalten, die die normalen Gene repräsentieren. Die Expression der normalen Gene ergibt sich wie üblich in verschiedenen Sub-ETs, die im Zellsystem ADFs (automatisch definierte Funktionen) genannt werden. Was die Schwänze betrifft, enthalten sie nur genische Terminals, d.h. abgeleitete Features, die auf der Fliege durch den Algorithmus erzeugt werden. Beispielsweise hat das Chromosom in der Figur drei normale Gene und ein homöotisches Gen und kodiert ein Hauptprogramm, das insgesamt viermal drei verschiedene Funktionen anruft und diese in besonderer Weise verknüpft. Aus diesem Beispiel ist klar, dass das zelluläre System nicht nur die untrainierte Entwicklung von Verknüpfungsfunktionen, sondern auch die Code-Wiederverwendung erlaubt. Und es sollte nicht schwer sein, Rekursion in diesem System zu implementieren. Mehrere Hauptprogramme und multizelluläre Systeme Multizelluläre Systeme bestehen aus mehr als einem homeotischen Gen. Jedes homeotische Gen in diesem System setzt eine andere Kombination von Subexpressionsbäumen oder ADFs zusammen, wodurch mehrere Zellen oder Hauptprogramme erzeugt werden. Beispielsweise wurde das in der Figur gezeigte Programm mit einem zellulären System mit zwei Zellen und drei normalen Genen erstellt. Die Anwendungen dieser multizellulären Systeme sind vielfältig und vielfältig und können ebenso wie die multigenen Systeme sowohl bei Problemen mit nur einem Ausgang als auch bei Problemen mit mehreren Ausgängen eingesetzt werden. Andere Komplexitätsstufen Die Kopf-Tail-Domain von GEP-Genen (sowohl normal als auch homeotisch) ist der Grundbaustein aller GEP-Algorithmen. Die Gen-Expressions-Programmierung untersucht jedoch auch andere chromosomale Organisationen, die komplexer sind als die Kopf-/Tail-Struktur. Diese komplexen Strukturen bestehen im Wesentlichen aus funktionellen Einheiten oder Genen mit einer Grund-Kopf-Tail-Domain plus einer oder mehreren Extra-Domains. Diese zusätzlichen Domänen kodieren in der Regel zufällige numerische Konstanten, die der Algorithmus unerbittlich Feinabstimmungen, um eine gute Lösung zu finden. Diese Zahlenkonstanten können beispielsweise die Gewichte oder Faktoren in einem Funktionsapplikationsproblem sein (siehe unten der GEP-RNC-Algorithmus); sie können die Gewichte und Schwellenwerte eines neuronalen Netzes sein (siehe unten der GEP-NN-Algorithmus); die für die Gestaltung von Entscheidungsbäumen erforderlichen Zahlenkonstanten (siehe unten der GEP-DT-Algorithmus); die für die polynomielle Induktion erforderlichen Gewichte; oder die zufälligen Zahlenkonstanten, die zur Entdeckung der Parameter. Der grundlegende Genexpressionsalgorithmus Die grundlegenden Schritte des basischen Genexpressionsalgorithmus sind nachfolgend unter Pseudocode aufgeführt: Wählen Sie den Funktionssatz; Wählen Sie den Terminalsatz; laden Sie den Datensatz für die Fitness-Auswertung; Erstellen Sie Chromosomen der ersten Population zufällig; Für jedes Programm in der Bevölkerung: Überprüfen Sie die Stop-Zustand; Wählen Sie Programme; Replizieren Sie ausgewählte Programme, um die nächste Population zu bilden; Ändern Sie Chromosomen mit genetischen Operatoren; Gehen Sie zu Schritt 5. Die ersten vier Schritte bereiten alle Zutaten vor, die für die iterative Schleife des Algorithmus benötigt werden (Schritte 5 bis 10). Von diesen präparativen Schritten ist es entscheidend, die anfängliche Bevölkerung zu schaffen, die zufällig unter Verwendung der Elemente der Funktion und der Terminal-Sets erstellt wird. Wie alle evolutionären Algorithmen funktioniert die Genexpressions-Programmierung mit Populationen von Individuen, die in diesem Fall Computerprogramme sind. Daher muss eine Art anfänglicher Bevölkerung geschaffen werden, um Dinge zu beginnen. Nachfolgende Populationen sind Nachkommen, über Selektion und genetische Veränderung, der ursprünglichen Bevölkerung. Im Genotyp/Phenotyp-System der Gen-Expressions-Programmierung ist es nur erforderlich, die einfachen linearen Chromosomen der Individuen zu schaffen, ohne sich um die strukturelle Klangfähigkeit der von ihnen kodierten Programme zu kümmern, da ihre Expression immer zu syntaktisch korrekten Programmen führt. Fitness-Funktionen und die Auswahlumgebung Fitness-Funktionen und Selektionsumgebungen (genannte Trainingsdatensätze im maschinellen Lernen) sind die beiden Facetten der Fitness und sind daher kompliziert verbunden. In der Tat hängt die Fitness eines Programms nicht nur von der Kostenfunktion ab, die zur Messung seiner Leistung verwendet wird, sondern auch von den Trainingsdaten, die zur Bewertung der Fitness ausgewählt wurden. Auswahlumgebung oder Trainingsdaten Die Auswahlumgebung besteht aus dem Satz von Trainingsakten, die auch Fitness-Fälle genannt werden. Diese Fitness-Fälle könnten eine Reihe von Beobachtungen oder Messungen über einige Probleme sein, und sie bilden das, was der Trainingsdatensatz genannt wird. Die Qualität der Trainingsdaten ist für die Entwicklung guter Lösungen unerlässlich. Ein gutes Trainingsset sollte repräsentativ für das Problem sein und auch gut ausbalanciert sein, sonst könnte der Algorithmus an einem lokalen Optimum hängen bleiben. Darüber hinaus ist es auch wichtig, unnötig große Datensätze für die Ausbildung zu vermeiden, da dies die Dinge unnötig verlangsamt. Eine gute Regel des Daumens ist, genügend Datensätze für die Ausbildung zu wählen, um eine gute Verallgemeinerung der Validierungsdaten zu ermöglichen und die restlichen Datensätze für Validierung und Prüfung zu verlassen. Fitness-Funktionen Im Allgemeinen gibt es drei verschiedene Arten von Problemen basierend auf der Art der Vorhersage gemacht: Probleme mit numerischen (kontinuierlichen) Vorhersagen; Probleme mit kategorischen oder nominellen Vorhersagen, sowohl binomial als auch multinomial; Probleme mit binären oder booleschen Vorhersagen. Die erste Art von Problem geht unter dem Namen der Regression; die zweite ist als Klassifikation bekannt, mit logistischer Regression als Sonderfall, wo neben den knackigen Klassifikationen wie Ja oder Nein auch eine Wahrscheinlichkeit an jedem Ergebnis angebracht ist; und die letzte ist mit Boolean Algebra und Logiksynthese verbunden. Fitnessfunktionen für Regression Bei der Regression ist die Antwort- bzw. abhängige Größe numerisch (in der Regel kontinuierlich) und damit auch die Ausgabe eines Regressionsmodells kontinuierlich. So ist es ganz einfach, die Fitness der sich entwickelnden Modelle zu bewerten, indem die Ausgabe des Modells mit dem Wert der Antwort in den Trainingsdaten verglichen wird. Es gibt mehrere Basis-Fitness-Funktionen zur Bewertung der Modellleistung, wobei die häufigsten auf dem Fehler oder Rest zwischen Modellausgang und Istwert beruhen. Solche Funktionen umfassen den mittleren quadratischen Fehler, Wurzelmittel quadratischen Fehler, mittleren absoluten Fehler, relativ quadratischen Fehler, Wurzel relativ quadratischen Fehler, relativen absoluten Fehler, und andere. Alle diese Standardmaßnahmen bieten eine feine Granularität oder Glätte für den Lösungsraum und arbeiten daher für die meisten Anwendungen sehr gut. Einige Probleme könnten jedoch eine gröbere Evolution erfordern, z.B. die Bestimmung, ob eine Vorhersage innerhalb eines bestimmten Intervalls liegt, beispielsweise weniger als 10% des tatsächlichen Wertes. Doch auch wenn man nur daran interessiert ist, die Hits zu zählen (d.h. eine Vorhersage, die innerhalb des gewählten Intervalls liegt), so dass sich die Populationen von Modellen entwickeln, basierend auf nur der Anzahl der Treffer, die jedes Programm erzielt, ist in der Regel nicht sehr effizient durch die grobe Granularität der Fitness-Landschaft. So besteht in der Lösung üblicherweise die Kombination dieser groben Maßnahmen mit einer Art glatter Funktion wie den oben aufgeführten Standardfehlern. Auch Fitnessfunktionen auf Basis des Korrelationskoeffizienten und R-Square sind sehr glatt. Bei Regressionsproblemen arbeiten diese Funktionen am besten durch Kombination mit anderen Maßnahmen, weil sie selbst nur dazu neigen, Korrelation zu messen, nicht für den Wertebereich der Modellausgabe. Durch die Kombination mit Funktionen, die bei der Annäherung der Reichweite der Zielwerte arbeiten, bilden sie also sehr effiziente Fitnessfunktionen, um Modelle mit guter Korrelation und guter Passform zwischen vorhergesagten und tatsächlichen Werten zu finden. Fitnessfunktionen für Klassifizierung und logistische Regression Das Design von Fitness-Funktionen für die Klassifizierung und logistische Regression nutzt drei verschiedene Eigenschaften von Klassifikationsmodellen. Das Offensichtlichste ist nur das Zählen der Treffer, das heißt, wenn ein Datensatz korrekt klassifiziert wird, wird es als Treffer gezählt. Diese Fitness-Funktion ist sehr einfach und funktioniert gut für einfache Probleme, aber für komplexere Probleme oder Datensätze hoch unausgeglichen gibt es schlechte Ergebnisse. Eine Möglichkeit, diese Art von hits-basierten Fitness-Funktion zu verbessern besteht darin, den Begriff der korrekten und falschen Klassifizierungen zu erweitern. In einer binären Klassifikationsaufgabe können richtige Klassifikationen 00 oder 11 sein. Die 00-Darstellung bedeutet, dass ein negativer Fall (repräsentiert durch "0") korrekt klassifiziert wurde, während die 11 bedeutet, dass ein positiver Fall (repräsentiert durch "1") korrekt klassifiziert wurde. Klassifizierungen vom Typ 00 werden als echte Negative (TN) und 11 wahre Positive (TP) bezeichnet. Es gibt auch zwei Arten falscher Klassifikationen und sie sind durch 01 und 10 dargestellt. Sie werden als falsche Positive (FP) bezeichnet, wenn der Istwert 0 ist und das Modell a 1 vorhersagt; und falsche Negative (FN), wenn das Ziel 1 ist und das Modell a 0 vorhersagt. Die Zählungen von TP, TN, FP und FN werden in der Regel auf einem Tisch gehalten, der als Verwirrungsmatrix bekannt ist. Durch Zählen der TP, TN, FP und FN und weitere Zuordnung von unterschiedlichen Gewichten zu diesen vier Arten von Klassifikationen ist es möglich, glattere und damit effizientere Fitnessfunktionen zu schaffen. Einige beliebte Fitness-Funktionen auf Basis der Verwirrungsmatrix umfassen Empfindlichkeit/Spezifität, Rückruf/Präzision, F-Messung, Jaccard Ähnlichkeit, Matthews Korrelationskoeffizient und Kosten/Gang-Matrix, die die Kosten und Gewinne, die den 4 verschiedenen Arten von Klassifikationen zugeordnet sind, kombiniert. Diese Funktionen auf der Basis der Verwirrungsmatrix sind ziemlich ausgereift und sind ausreichend, um die meisten Probleme effizient zu lösen. Aber es gibt eine andere Dimension zu Klassifizierungsmodellen, die entscheidend ist, um den Lösungsraum effizienter zu erforschen und so die Entdeckung besserer Klassifikatoren zu bewirken. Diese neue Dimension beinhaltet die Erkundung der Struktur des Modells selbst, die nicht nur die Domäne und Reichweite, sondern auch die Verteilung der Modellleistung und der Klassifikator-Marge umfasst. Durch die Erkundung dieser anderen Dimension von Klassifikationsmodellen und anschließende Kombination der Informationen über das Modell mit der Verwirrungsmatrix können sehr anspruchsvolle Fitnessfunktionen entwickelt werden, die eine reibungslose Erkundung des Lösungsraums ermöglichen. So kann man z.B. auf der Verwechslungsmatrix basierend eine Maßnahme mit dem zwischen den Rohmodellausgängen und den Istwerten ausgewerteten mittleren Quadratfehler kombinieren. Oder kombinieren Sie die F-Messung mit dem für die Rohmodellausgabe und das Ziel bewerteten R-Quadrat oder die Kosten/Gang-Matrix mit dem Korrelationskoeffizienten und so weiter. Mehr exotische Fitness-Funktionen, die Modell-Granulat erkunden, umfassen die Fläche unter der ROC-Kurve und Rangmaß. Auch in Bezug auf diese neue Dimension der Klassifizierungsmodelle ist die Idee, die Wahrscheinlichkeiten der Modellausgabe zuzuordnen, was in logistischer Regression geschieht. Dann ist es auch möglich, diese Wahrscheinlichkeiten zu nutzen und den mittleren quadratischen Fehler (oder ein anderes ähnliches Maß) zwischen den Wahrscheinlichkeiten und den tatsächlichen Werten auszuwerten, diese dann mit der Verwirrungsmatrix zu kombinieren, um sehr effiziente Fitnessfunktionen für die logistische Regression zu schaffen. Zu den beliebten Beispielen von Fitness-Funktionen basierend auf den Wahrscheinlichkeiten gehören maximale Wahrscheinlichkeitsschätzung und Scharnierverlust. Fitnessfunktionen für Boolean Probleme In der Logik gibt es keine Modellstruktur (wie oben für die Klassifizierung und logistische Regression definiert) zu erkunden: Die Domäne und der Bereich der logischen Funktionen umfasst nur 0's und 1's oder falsch und wahr. So können die für Boolean Algebra zur Verfügung stehenden Fitnessfunktionen nur auf den Treffern oder auf der Verwirrungsmatrix basieren, wie im obigen Abschnitt erläutert. Auswahl und elitism Roulette-Rad Auswahl ist vielleicht das beliebteste Auswahlschema, das in der evolutionären Berechnung verwendet wird. Es beinhaltet die Zuordnung der Fitness jedes Programms zu einer Scheibe des Rouletterads proportional zu seiner Fitness. Dann wird die Roulette so oft versponnen, wie es Programme in der Bevölkerung gibt, um die Bevölkerungsgröße konstant zu halten. So werden mit Roulette-Rad Auswahlprogramme sowohl nach Fitness als auch nach dem Glück der Ziehung ausgewählt, was bedeutet, dass einige Male die besten Eigenschaften verloren gehen könnten. Durch die Kombination von Roulette-Rad-Auswahl mit dem Klonen des besten Programms jeder Generation wird jedoch gewährleistet, dass zumindest die besten Eigenschaften nicht verloren gehen.Diese Technik des Klonens des Best-of-Generation-Programms ist als einfaches Elitism bekannt und wird von den meisten stochastischen Auswahlsystemen verwendet. Reproduktion mit Modifikation Die Wiedergabe von Programmen beinhaltet zunächst die Auswahl und dann die Wiedergabe ihrer Genome. Genome Modifikation ist nicht für die Reproduktion erforderlich, aber ohne sie Anpassung und Evolution nicht stattfinden. Replikation und Auswahl Der Auswahloperator wählt die Programme für den Replikationsoperator zum Kopieren aus. Je nach Auswahlschema kann die Anzahl der Kopien eines Programms variieren, wobei einige Programme mehr als einmal kopiert werden, während andere nur einmal kopiert werden oder gar nicht. Darüber hinaus wird in der Regel die Auswahl so eingerichtet, dass die Bevölkerungsgröße von einer Generation zur anderen konstant bleibt. Die Replikation von Genomen in der Natur ist sehr komplex und es dauerte lange, um die DNA-Doppelhelix zu entdecken und einen Mechanismus für ihre Replikation vorzuschlagen. Aber die Replikation von Strings ist trivial in künstlichen evolutionären Systemen, wo nur eine Anleitung zum Kopieren von Strings erforderlich ist, um alle Informationen im Genom von Generation zu Generation zu übergeben. Die Replikation der ausgewählten Programme ist ein grundlegendes Stück aller künstlichen evolutionären Systeme, aber für die Evolution muss sie nicht mit der üblichen Präzision einer Kopieranweisung, sondern mit einigen Fehlern umgesetzt werden. Tatsächlich wird genetische Vielfalt mit genetischen Operatoren wie Mutation, Rekombination, Transposition, Inversion und vielen anderen erzeugt. Mut Bei der Genexpression ist die Programmierung Mutation der wichtigste genetische Operator. Es ändert Genome durch Veränderung eines Elements durch ein anderes. Die Anhäufung vieler kleiner Veränderungen im Laufe der Zeit kann große Vielfalt schaffen. Bei der Genexpression ist die Programmierungsmutation völlig unbeschränkt, was bedeutet, dass in jeder Gendomäne jedes Domänensymbol durch ein anderes ersetzt werden kann. Beispielsweise kann in den Genköpfen jede Funktion durch ein Terminal oder eine andere Funktion ersetzt werden, unabhängig von der Anzahl der Argumente in dieser neuen Funktion, und ein Terminal kann durch eine Funktion oder ein anderes Terminal ersetzt werden. Recombination Recombination beinhaltet in der Regel zwei Eltern-Chromosomen, um zwei neue Chromosomen zu schaffen, indem verschiedene Teile von den Eltern-Chromosomen kombiniert werden. Und solange die Elternchromosomen ausgerichtet sind und die ausgetauschten Fragmente homolog sind (d.h. die gleiche Position im Chromosom einnehmen), werden die neuen Chromosomen durch Rekombination immer syntaktisch korrekte Programme kodieren. Verschiedene Arten von Überkreuzungen sind leicht entweder durch Änderung der Anzahl der beteiligten Eltern (es gibt keinen Grund für die Wahl nur zwei); die Anzahl der Spaltpunkte; oder die Art, wie man wählt, um die Fragmente zu tauschen, zum Beispiel entweder zufällig oder in irgendeiner geordneten Weise. Beispielsweise kann die Genrekombination, die ein besonderer Fall der Rekombination ist, durch den Austausch homologer Gene (Gene, die dieselbe Position im Chromosom einnehmen) oder durch den Austausch von zufällig ausgewählten Genen aus jeder Position im Chromosom erfolgen. Transposition Transposition beinhaltet die Einführung einer Insertionssequenz irgendwo in einem Chromosom. Bei der Genexpression können Insertionssequenzen irgendwo im Chromosom erscheinen, aber sie werden nur in die Köpfe der Gene eingefügt. Dieses Verfahren gewährleistet, dass auch Insertionssequenzen aus den Schwänzen zu fehlerfreien Programmen führen. Um richtig zu arbeiten, muss es Chromosomenlänge und Genstruktur bewahren. So kann in der Genexpressions-Programmierungstransposition mit zwei verschiedenen Methoden implementiert werden: Die erste schafft eine Verschiebung an der Insertionsstelle, gefolgt von einer Deletion am Ende des Kopfes; die zweite überschreibt die lokale Sequenz an der Zielstelle und ist daher einfacher zu implementieren. Beide Verfahren können zum Betrieb zwischen Chromosomen oder innerhalb eines Chromosoms oder sogar innerhalb eines einzigen Gens durchgeführt werden. Inversion Inversion ist ein interessanter Bediener, besonders leistungsstark für die kombinatorische Optimierung. Es besteht darin, eine kleine Sequenz innerhalb eines Chromosoms zu invertieren. Bei der Genexpressions-Programmierung lässt sich diese leicht in allen Gendomänen implementieren und in allen Fällen ist die erzeugte Nachkommen stets syntaktisch korrekt. Für jede Gendomäne wird eine Sequenz (von mindestens zwei Elementen so groß wie die Domäne selbst) zufällig innerhalb dieser Domäne gewählt und dann invertiert. Andere genetische Operatoren Mehrere andere genetische Operatoren existieren und in der Genexpressions-Programmierung, mit ihren verschiedenen Genen und Gendomänen, sind die Möglichkeiten endlos. Beispielsweise sind genetische Operatoren wie Einpunktrekombination, Zweipunktrekombination, Genrekombination, einheitliche Rekombination, Gentransposition, Wurzeltransposition, Domänenspezifische Mutation, Domänenspezifische Inversion, Domänenspezifische Transposition usw. leicht implementiert und weit verbreitet. Der GEP-RNC-Algorithmus Numerische Konstanten sind wesentliche Elemente mathematischer und statistischer Modelle und daher ist es wichtig, ihre Integration in die von evolutionären Algorithmen entworfenen Modelle zu ermöglichen. Die Genexpressions-Programmierung löst dieses Problem sehr elegant durch die Verwendung einer extra Gendomäne – der Dc – für die Behandlung von zufälligen numerischen Konstanten (RNC). Durch die Kombination dieser Domain mit einem speziellen Terminal-Platzhalter für die RNCs kann ein reich ausdrucksstarkes System geschaffen werden. Strukturell kommt der Dc nach dem Schwanz, hat eine Länge gleich der Größe des Schwanzes t und besteht aus den Symbolen, die verwendet werden, um die RNCs zu repräsentieren. So zeigt sich unten ein einfaches Chromosom, bestehend aus nur einem Gen eine Kopfgröße von 7 (der Dc erstreckt sich über die Positionen 15–22:) 01234567890123456789012 *+aaa???aaa68083295, wo das Terminal "?" den Platzhalter für die RNCs darstellt. Diese Art von Chromosom wird genau wie oben angegeben ausgedrückt, geben: Dann werden die '?s im Expressionsbaum von links nach rechts und von oben nach unten durch die Symbole (für Einfachheit dargestellt durch Ziffern) im Dc ersetzt, wobei: Die diesen Symbolen entsprechenden Werte werden in einem Array gehalten.( Die mit der Ziffer dargestellte Zahl gibt die Reihenfolge im Array an.) So gibt z.B. für das folgende 10 Elementarfeld von RNCs: C = {0.611, 1.184, 2.449, 2.98, 0.496, 2.286, 0.93, 2.305, 2.737, 0.755} der oben angegebene Expressionsbaum: Diese elegante Struktur zum Umgang mit zufälligen numerischen Konstanten liegt im Herzen verschiedener GEP-Systeme, wie GEP-Neuralnetzwerke und GEP-Entscheidungsbäume. Wie der grundlegende Genexpressionsalgorithmus ist auch der GEP-RNC-Algorithmus multigen und seine Chromosomen werden wie üblich decodiert, indem man ein Gen nach dem anderen exprimiert und anschließend durch die gleiche Art von Verknüpfungsprozess miteinander verknüpft. Die genetischen Operatoren, die im GEP-RNC-System verwendet werden, sind eine Erweiterung der genetischen Operatoren des GEP-Grundalgorithmus (siehe oben), und sie alle können in diesen neuen Chromosomen direkt implementiert werden. Andererseits werden im GEP-RNC-Algorithmus auch die Basisoperatoren der Mutation, Inversion, Transposition und Rekombination eingesetzt. Darüber hinaus dienen auch spezielle Dc-spezifische Operatoren wie Mutation, Inversion und Transposition, um in einer effizienteren Zirkulation der RNCs unter einzelnen Programmen zu helfen. Darüber hinaus gibt es auch einen speziellen Mutationsoperator, der die permanente Einführung von Variationen im Satz von RNCs ermöglicht. Der Anfangssatz von RNCs wird zu Beginn eines Laufs zufällig erstellt, was bedeutet, dass für jedes Gen in der Anfangspopulation eine bestimmte Anzahl von Zahlenkonstanten, die aus einem bestimmten Bereich gewählt werden, zufällig erzeugt werden. Dann wird ihre Zirkulation und Mutation durch die genetischen Operatoren ermöglicht. Neurale Netze Ein künstliches neuronales Netz (ANN oder NN) ist ein Rechengerät, das aus vielen einfachen angeschlossenen Einheiten oder Neuronen besteht. Die Verbindungen zwischen den Einheiten werden in der Regel durch reale Gewichte gewichtet. Diese Gewichte sind die primären Mittel des Lernens in neuronalen Netzwerken und ein Lernalgorithmus wird in der Regel verwendet, um sie anzupassen. Strukturell hat ein neuronales Netz drei verschiedene Einheitenklassen: Eingabeeinheiten, versteckte Einheiten und Ausgabeeinheiten. An den Eingabeeinheiten wird ein Aktivierungsmuster dargestellt, das dann in Vorwärtsrichtung von den Eingabeeinheiten über eine oder mehrere Schichten von versteckten Einheiten zu den Ausgabeeinheiten verteilt wird. Die Aktivierung aus einer anderen Einheit wird mit den Gewichten auf den Gliedern multipliziert, über die sie verteilt. Alle eintreffenden Aktivierungen werden dann gemeinsam hinzugefügt und die Einheit wird nur dann aktiviert, wenn das eintreffende Ergebnis über der Schwelle der Einheit liegt. Zusammenfassend sind die Grundkomponenten eines neuronalen Netzes die Einheiten, die Verbindungen zwischen den Einheiten, die Gewichte und die Schwellen. Um also ein künstliches neuronales Netz vollständig zu simulieren, muss man diese Komponenten irgendwie in einem linearen Chromosom kodieren und dann sinnvoll ausdrücken können. In GEP-Neuralnetzen (GEP-NN oder GEP-Netze) wird die Netzwerkarchitektur in der üblichen Struktur einer Kopf-Tail-Domain codiert. Der Kopf enthält spezielle Funktionen/Neuronen, die die versteckten und Ausgabeeinheiten aktivieren (im GEP-Kontext werden alle diese Einheiten entsprechend als Funktionseinheiten bezeichnet) und Terminals, die die Eingabeeinheiten darstellen. Der Schwanz enthält wie üblich nur Klemmen/Eingangseinheiten. Neben Kopf und Schwanz enthalten diese neuronalen Netzwerkgene zwei weitere Domänen Dw und Dt, um die Gewichte und Schwellen des neuronalen Netzes zu kodieren. Strukturell kommt der Dw nach dem Schwanz und seine Länge dw hängt von der Kopfgröße h und der maximalen Arität nmax und wird durch die Formel ausgewertet: d w = h n max \{displaystyle ) Der Dt kommt nach Dw und hat eine Länge dt gleich t. Beide Domänen bestehen aus Symbolen, die die Gewichte und Schwellen des neuronalen Netzes darstellen. Für jedes NN-Gen werden die Gewichte und Schwellenwerte zu Beginn eines jeden Laufs erzeugt, deren Durchblutung und Anpassung jedoch durch die üblichen genetischen Operatoren der Mutation, Transposition, Inversion und Rekombination gewährleistet ist. Darüber hinaus werden auch spezielle Operatoren verwendet, um einen konstanten Fluss der genetischen Variation in der Menge der Gewichte und Schwellen zu ermöglichen. Im folgenden ist beispielsweise ein neuronales Netz mit zwei Eingangseinheiten (i1 und i2), zwei versteckten Einheiten (h1 und h2) und einer Ausgangseinheit (o1) dargestellt. Es hat insgesamt sechs Verbindungen mit sechs entsprechenden, mit den Ziffern 1-6 dargestellten Gewichten (für Einfachheit sind die Schwellen alle gleich 1 und entfallen:) Diese Darstellung ist die kanonale neuronale Netzdarstellung, aber auch neuronale Netzwerke können durch einen Baum dargestellt werden, der in diesem Fall entspricht: wobei "a" und "b" die beiden Eingänge i1 und i2 und "D" eine Funktion mit Konnektivität zwei darstellen. Diese Funktion fügt alle gewichteten Argumente hinzu und schwellt diese Aktivierung, um die weitergeleitete Ausgabe zu bestimmen. Dieser Ausgang (Null oder eins in diesem einfachen Fall) hängt von der Schwelle jeder Einheit ab, d.h. wenn die insgesamt eintreffende Aktivierung gleich oder größer als die Schwelle ist, dann ist der Ausgang eins, null. Die obige NN-Straße kann wie folgt linearisiert werden: 0123456789012 DDDab654321, wo die Struktur in den Positionen 7-12(Dw) die Gewichte kodiert. Die Werte jedes Gewichts werden in einem Array gehalten und bei Bedarf zur Expression abgerufen. Als konkreteres Beispiel wird nachfolgend ein neuronales Netzgen für das exklusive oder Problem dargestellt. Es hat eine Kopfgröße von 3 und Dw Größe von 6: 0123456789012 DDDab393257 Sein Ausdruck ergibt das folgende neuronale Netz: das für die Gewichtsmenge W = {-1.978, 0.514, -0.465, 1.22, -1.686, -1.797, 0.197, 1.606, 0, 1.753} es gibt: Das ist eine perfekte Lösung für die Exklusiv-oder Funktion. Neben einfachen Booleschen Funktionen mit binären Eingängen und binären Ausgängen kann der GEP-Netz-Algorithmus alle Arten von Funktionen oder Neuronen (lineare Neuron, Tanh Neuron, Atan Neuron, logistische Neuron, Grenzneuron, radiale Basis und dreieckige Basisneuronen, alle Arten von Stufenneuronen, und so weiter) behandeln. Interessant ist auch, dass der GEP-Netzwerk-Algorithmus alle diese Neuronen zusammen verwenden kann und die Evolution entscheiden lässt, welche am besten funktionieren, um das Problem zu lösen. So können GEP-Netze nicht nur in Booleschen Problemen, sondern auch in logistischen Regressionen, Klassifikation und Regression eingesetzt werden. In allen Fällen können GEP-Netze nicht nur mit multigenen Systemen, sondern auch zellularen Systemen, sowohl einzellig als auch mehrzellig, realisiert werden. Darüber hinaus können multinomiale Klassifikationsprobleme auch von GEP-Netzen sowohl mit multigenen Systemen als auch multizellulären Systemen angegangen werden. Entscheidung Bäume Entscheidung Bäume (DT) sind Klassifikationsmodelle, bei denen eine Reihe von Fragen und Antworten mit Knoten und gerichteten Kanten abgebildet werden. Entscheidungsbäume haben drei Arten von Knoten: einen Wurzelknoten, interne Knoten und Blatt- oder Endknoten. Der Wurzelknoten und alle internen Knoten stellen Testbedingungen für verschiedene Attribute oder Variablen in einem Datensatz dar. Blattknoten geben das Klassenlabel für alle verschiedenen Pfade im Baum an. Die meisten Entscheidungsbauminduktionsalgorithmen beinhalten die Auswahl eines Attributs für den Wurzelknoten und treffen dann die gleiche Art von informierter Entscheidung über alle Knoten in einem Baum. Entscheidungsbäume können auch durch Genexpressions-Programmierung erzeugt werden, mit dem Vorteil, dass alle Entscheidungen über das Wachstum des Baumes vom Algorithmus selbst ohne jede Art von menschlichem Input getroffen werden. Es gibt im Grunde zwei verschiedene Arten von DT-Algorithmen: eine zur Induktion von Entscheidungsbäumen mit nur nominalen Attributen und eine andere zur Induktion von Entscheidungsbäumen mit numerischen und nominalen Attributen. Dieser Aspekt der Entscheidungsbauminduktion führt auch zur Gen-Expressions-Programmierung und es gibt zwei GEP-Algorithmen für die Entscheidungsbauminduktion: den evolvierbaren Entscheidungsbäumen (EDT)-Algorithmus für die ausschließliche Behandlung von Nominalattributen und dem EDT-RNC (EDT mit Zufallszahlenkonstanten) für die Handhabung von Nominal- und Numerischen Attributen. Bei den durch Genexpressions-Programmierung induzierten Entscheidungsbäumen verhalten sich die Attribute als Funktionsknoten im Basisgenexpressionsalgorithmus, während sich die Klassenetiketten als Terminals verhalten. Dies bedeutet, dass Attribut-Knoten ihnen auch eine bestimmte Arität oder Anzahl von Zweigen zugeordnet haben, die ihr Wachstum und letztlich das Wachstum des Baumes bestimmen. Klassenetiketten verhalten sich wie Terminals, was bedeutet, dass für eine k-Klasse-Klassifikationsaufgabe ein Terminal mit k-Terminals verwendet wird, was die k verschiedenen Klassen darstellt. Die Regeln für die Kodierung eines Entscheidungsbaums in einem linearen Genom sind den Regeln, die zur Kodierung mathematischer Ausdrücke verwendet werden (siehe oben). Für die Entscheidungsbauminduktion haben die Gene also auch einen Kopf und einen Schwanz, wobei der Kopf Attribute und Terminals und der Schwanz nur Terminals enthält. Dies stellt wiederum sicher, dass alle von GEP entworfenen Entscheidungsbäume stets gültige Programme sind. Ferner wird die Größe des Schwanzes t auch durch die Kopfgröße h und die Anzahl der Zweige des Attributs mit mehr Zweigen nmax bestimmt und durch die Gleichung EPMATHMARKEREP evaluiert. Denken Sie beispielsweise an den untenstehenden Entscheidungsbaum, ob Sie draußen spielen sollen: Es kann linear kodiert werden wie: 01234567 HOWbaabawhere "H" repräsentiert das Attribut Feuchtigkeit, "O" das Attribut Outlook, "W" repräsentiert Windy, und "a" und "b" die Klassenlabels Ja bzw. Nein. Beachten Sie, dass die die Knoten verbindenden Kanten Eigenschaften der Daten sind, die Art und Anzahl der Zweige jedes Attributs angeben und daher nicht codiert werden müssen. Der Prozess der Entscheidungsbauminduktion mit Gen-Expressions-Programmierung beginnt, wie üblich, mit einer anfänglichen Population zufällig erstellter Chromosomen. Dann werden die Chromosomen als Entscheidungsbäume exprimiert und ihre Fitness gegen einen Trainingsdatensatz ausgewertet. Nach Fitness werden sie dann mit Modifikation reproduziert. Die genetischen Operatoren sind genau die gleichen, die in einem konventionellen ungenügenen System, beispielsweise Mutation, Inversion, Transposition und Rekombination verwendet werden. Entscheidungsbäume mit sowohl nominellen als auch numerischen Attributen lassen sich auch mit der Genexpressions-Programmierung mit dem oben beschriebenen Rahmen für die Behandlung von zufälligen numerischen Konstanten leicht induzieren. Die chromosomale Architektur umfasst eine zusätzliche Domäne zur Kodierung von Zufallszahlenkonstanten, die als Schwellen zur Aufteilung der Daten an jedem Verzweigungsknoten verwendet werden. So kodiert das nachfolgende Gen mit einer Kopfgröße von 5 (der Dc beginnt bei Position 16:) 012345678901234567890 WOTHababbbabba46336 den unten gezeigten Entscheidungsbaum: Bei diesem System ist jedem Knoten im Kopf unabhängig von seinem Typ (numerisches Attribut, Nominalat oder Terminal) eine zufällige numerische Konstante zugeordnet, die zur Einfachheit im obigen Beispiel mit einer Ziffer 0-9 dargestellt ist. Diese zufälligen Zahlenkonstanten werden in der Dc-Domäne kodiert und ihr Ausdruck folgt einem sehr einfachen Schema: von oben nach unten und von links nach rechts werden die Elemente in Dc eins nach dem anderen den Elementen im Entscheidungsbaum zugeordnet. Für das folgende Array von RNCs: C= {62, 51, 68, 83, 86, 41, 43, 44, 9, 67} ergibt sich der obenstehende Entscheidungsbaum: der auch als herkömmlicher Entscheidungsbaum bunt dargestellt werden kann: Der Kritiker GEP wurde kritisiert, weil er keine wesentliche Verbesserung gegenüber anderen genetischen Programmiertechniken darstellt. In vielen Versuchen hat es nicht besser als bestehende Methoden durchgeführt. GeneXproTools GeneXproTools ist eine prädiktive Analyse-Suite, die von Gepsoft entwickelt wurde. GeneXproTools Modellierungsrahmen umfassen logistische Regression, Klassifizierung, Regression, Zeitreihenvorhersage und Logiksynthese. GeneXproTools implementiert den Basis-Genexpressionsalgorithmus und den GEP-RNC-Algorithmus, die beide in allen Modellierungsgerüsten von GeneXproTools verwendet werden. Open-Source-Bibliotheken GEP4J – GEP für Java Project Erstellt von Jason Thomas ist GEP4J eine Open-Source-Implementierung der Genexpressions-Programmierung in Java. Es implementiert verschiedene GEP-Algorithmen, einschließlich entwickelnde Entscheidungsbäume (mit nominellen, numerischen oder gemischten Attributen) und automatisch definierte Funktionen. GEP4J ist Gastgeber bei Google Code.PyGEP – Gene Expression Programming for Python Erstellt von Ryan O'Neil mit dem Ziel, eine einfache Bibliothek zu schaffen, die für die akademische Studie der Genexpressions-Programmierung in Python geeignet ist, um eine einfache Anwendung und schnelle Implementierung zu ermöglichen. Es implementiert Standardmultigene Chromosomen und die genetischen Operatoren Mutation, Crossover und Transposition. PyGEP wird bei Google Code.jGEP gehostet – Java GEP Toolkit Erstellt von Matthew Sottile, um schnell Java-Prototypen-Codes zu erstellen, die GEP verwenden, die dann in einer Sprache wie C oder Fortran für echte Geschwindigkeit geschrieben werden können. jGEP wird bei SourceForge gehostet. Weitere Lesung Ferreira, C. (2006). Gene Expression Programmierung: Mathematische Modellierung durch eine künstliche Intelligenz.Springer-Verlag.ISBN 3-540-32796-7.Ferreira, C. (2002). Gene Expression Programmierung: Mathematische Modellierung durch eine künstliche Intelligenz. Portugal:Angra do Heroismo.ISBN 972-95890-5-4. Siehe auch Symbolische Regression Künstliche Intelligenz Entscheidung Bäume Evolutionsalgorithmen Genetische Algorithmen Genetische Programmierung GeneXproToolsMachine Lernen Neural Netzwerke Referenzen Externe Links GEP Startseite, gepflegt durch den Erfinder der Genexpression Programmierung. GeneXproTools, kommerzielle GEP-Software.