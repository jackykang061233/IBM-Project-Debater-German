Die Programmierung von Paradigmen ist eine Möglichkeit, Programmiersprachen basierend auf ihren Funktionen zu klassifizieren. Sprachen können in mehrere Paradigmen klassifiziert werden. Einige Paradigmen betreffen vor allem die Auswirkungen auf das Ausführungsmodell der Sprache, wie das Ermöglichen von Nebenwirkungen, oder ob die Reihenfolge der Operationen durch das Ausführungsmodell definiert ist. Andere Paradigmen betreffen hauptsächlich die Art und Weise, wie dieser Code organisiert wird, wie z.B. die Gruppierung eines Codes in Einheiten zusammen mit dem durch den Code geänderten Zustand. Doch andere sind vor allem mit dem Stil der Syntax und Grammatik beschäftigt. Zu den gemeinsamen Programmierparadigmen gehören: Imperativ, bei dem der Programmierer die Maschine anzeigt, wie er seinen Zustand ändert, verfahrensmäßige Anweisungen in Verfahrensymbol, objektorientiert, welche Gruppenanweisungen mit dem Teil des von ihnen betriebenen Zustands bezeichnen, deklarativ, in dem der Programmierer lediglich Eigenschaften des gewünschten Ergebnisses angibt, aber nicht wie er funktionell berechnet wird, in dem das gewünschte Ergebnis als Ergebnis einer Reihe von Funktionsapplikationsapplikationen angegeben wird, Logik, in welcher die gewünschte Ergebnis als gewünschter Folge angegeben wird. Dies ist jedoch mit den großen Paradigmen kompatibel und ist somit kein wirkliches Paradigma in seinem eigenen Recht. Beispielsweise haben Sprachen, die in das Imperativparadigma fallen, zwei Hauptmerkmale: Sie geben die Reihenfolge an, in der Operationen auftreten, mit Konstrukten, die diese Reihenfolge explizit steuern, und sie erlauben Nebenwirkungen, in denen Zustand zu einem Zeitpunkt geändert werden kann, innerhalb einer Codeeinheit, und dann später zu einem anderen Zeitpunkt innerhalb einer anderen Codeeinheit lesen. Die Kommunikation zwischen den Codeeinheiten ist nicht explizit. In der Zwischenzeit wird in der objektorientierten Programmierung Code in Objekte organisiert, die einen Zustand enthalten, der nur durch den Code geändert wird, der Teil des Objekts ist. Die meisten objektorientierten Sprachen sind auch zwingende Sprachen. Im Gegensatz dazu geben Sprachen, die dem deklarativen Paradigma entsprechen, nicht die Reihenfolge an, in der die Operationen ausgeführt werden sollen. Stattdessen liefern sie eine Reihe von verfügbaren Operationen im System, zusammen mit den Bedingungen, unter denen jeder ausführen darf. Die Implementierung der Ausführungsmodell-Tracks der Sprache, die Operationen frei auszuführen sind und die Bestellung unabhängig auswählen. Mehr zum Vergleich von Mehrparadigmen Programmiersprachen. Übersicht So wie Software Engineering (als Prozess) durch unterschiedliche Methoden definiert wird, so werden die Programmiersprachen (als Berechnungsmodelle) durch unterschiedliche Paradigmen definiert. Einige Sprachen sind so konzipiert, dass sie ein Paradigma unterstützen (Smalltalk unterstützt objektorientierte Programmierung, Haskell unterstützt funktionelle Programmierung), während andere Programmiersprachen mehrere Paradigmen unterstützen (wie Object Pascal, C,+ Java, JavaScript, C,# Scala, Visual Basic, Common Lisp, Scheme, Perl, PHP, Python, Ruby, Oz und F#). So können beispielsweise in C,+ Object Pascal oder PHP geschriebene Programme rein verfahrenstechnisch, rein objektorientiert sein oder Elemente beider oder anderer Paradigmen enthalten. Software-Designer und Programmierer entscheiden, wie man diese Paradigmenelemente verwendet. Bei der objektorientierten Programmierung werden Programme als eine Reihe von interagierenden Objekten behandelt. Bei der funktionellen Programmierung werden Programme als Folge von zustandslosen Funktionsauswertungen behandelt. Bei der Programmierung von Computern oder Systemen mit vielen Prozessoren werden in der prozessorientierten Programmierung Programme als Sätze von gleichzeitigen Prozessen behandelt, die auf eine logische gemeinsame Datenstruktur wirken. Viele Programmierparadigmen sind ebenso bekannt für die Techniken, die sie verbieten, wie für diejenigen, die sie aktivieren. Zum Beispiel, reine funktionelle Programmierung disallows Verwendung von Nebenwirkungen, während strukturierte Programmierung die Verwendung der goto-Anweisung deaktiviert. Teilweise werden aus diesem Grund neue Paradigmen oft als Doktrinär oder übermäßig starr von denen angesehen, die an frühere Stile gewöhnt sind. Doch die Vermeidung bestimmter Techniken kann es einfacher, das Programmverhalten zu verstehen und Theoremen über Programmkorrektheit zu beweisen. Die Programmierung von Paradigmen kann auch mit Programmiermodellen verglichen werden, die ein Ausführungsmodell mit nur einer API aufrufen können. Programmiermodelle können auch in Paradigmen basierend auf Merkmalen des Ausführungsmodells eingeteilt werden. Für die Parallelverarbeitung ist die Verwendung eines Programmiermodells anstelle einer Sprache üblich. Der Grund ist, dass Details der parallelen Hardware-Leck in die Abstraktionen verwendet, um die Hardware zu programmieren. Dies bewirkt, dass der Programmierer Muster im Algorithmus auf Muster im Ausführungsmodell (die durch Leckage von Hardware in die Abstraktion eingefügt wurden) abbilden muss. Infolgedessen kartiert niemand parallele Programmiersprachen gut zu allen Rechenproblemen. So ist es bequemer, eine Basis-Sequentialsprache zu verwenden und API-Aufrufe über ein Programmiermodell zu parallelen Ausführungsmodellen einzufügen. Solche parallelen Programmiermodelle können nach Abstraktionen klassifiziert werden, die die Hardware reflektieren, wie zum Beispiel geteilter Speicher, verteilter Speicher mit Nachrichtenübergabe, im Code sichtbare Platzerscheinungen usw. Diese können als Aromen der Programmierung Paradigmen betrachtet werden, die nur für parallele Sprachen und Programmiermodelle gelten. KritikEinige Programmiersprachenforscher kritisieren den Begriff der Paradigmen als Klassifizierung von Programmiersprachen, z.B. Harper, und Krishnamurthi. Sie argumentieren, dass viele Programmiersprachen nicht streng in ein Paradigma klassifiziert werden können, sondern enthalten Merkmale von mehreren Paradigmen. Siehe Vergleich der Programmiersprachen mit mehreren Paradigmen. Geschichte Verschiedene Ansätze zur Programmierung haben sich im Laufe der Zeit entwickelt, die als solche entweder zu der Zeit oder retrospektiv identifiziert werden. Ein früher Ansatz, der bewusst als solche identifiziert wird, ist eine strukturierte Programmierung, die seit Mitte der 1960er Jahre plädiert. Das Konzept eines "Programmierungsparadigmas" als solches stammt mindestens 1978, in der Turing Award-Vorlesung von Robert W. Floyd, mit dem Titel The Paradigmen of Programming, die den Begriff des Paradigmas beschreibt, wie Thomas Kuhn in seiner Struktur der wissenschaftlichen Revolutionen (1962) verwendet. Erzeugniscode Die niedrigsten Programmierparadigmen sind Maschinencode, der direkt die Anweisungen (der Inhalt des Programmspeichers) als Folge von Zahlen darstellt, und die Montagesprache, in der die Maschinenanweisungen durch mnemonics dargestellt werden und Speicheradressen symbolische Etiketten erhalten werden können. Diese werden manchmal als Sprachen der ersten und zweiten Generation bezeichnet. In den 1960er Jahren wurden die Montagesprachen entwickelt, um die Bibliothek COPY und die sehr hochentwickelten konditionierten Makro-Generierungs- und Vorverarbeitungsfähigkeiten zu unterstützen, CALL zu (Subroutinen,) externen Variablen und gemeinsamen Abschnitten (globals), die eine signifikante Code-Wiederverwendung und Isolation von Hardware-Spezifikationen über die Verwendung logischer Operatoren wie READ/WRITE/GET/PUT ermöglichen. Die Montage war und wird immer noch, für zeitkritische Systeme und oft in eingebetteten Systemen verwendet, da sie die direkteste Kontrolle über das, was die Maschine tut. Verfahrenssprachen Der nächste Vormarsch war die Entwicklung von Verfahrenssprachen. Diese Fremdsprachen der dritten Generation (die ersten, als hochrangige Sprachen bezeichneten) verwenden Vokabular im Zusammenhang mit dem Problem, das gelöst wird. Zum Beispiel, COmmon Business Oriented Language (COBOL) – verwendet Begriffe wie Datei, Bewegung und Kopie. FORmula TRANslation (FORTRAN) – mit mathematischer Sprachterminologie wurde sie hauptsächlich für wissenschaftliche und technische Probleme entwickelt. ALGOrithmic Language (ALGOL) – konzentrierte sich darauf, eine geeignete Sprache zu sein, um Algorithmen zu definieren, während mathematische Sprachterminologie verwendet wird, um wissenschaftliche und technische Probleme, wie FORTRAN. Programming Language One (PL/I) – eine hybride kaufmännisch-wissenschaftliche allgemeine Zielsprache, die Zeiger unterstützt. Anfänger Alle Zweck-Symbolic Instruction Code (BASIC) – es wurde entwickelt, um mehr Menschen zu ermöglichen, Programme zu schreiben. C – eine allgemeine Programmiersprache, die von Dennis Ritchie zwischen 1969 und 1973 bei AT&T Bell Labs entwickelt wurde. Alle diese Sprachen folgen dem Verfahrensparadigma. Das heißt, sie beschreiben Schritt für Schritt genau das Verfahren, nach dem zumindest der jeweilige Programmierer ein bestimmtes Problem lösen sollte. Die Wirksamkeit und Effizienz einer solchen Lösung sind daher völlig subjektiv und sehr abhängig von der Erfahrung, der Erfindung und der Fähigkeit des Programmierers. Objektorientierte Programmierung Nach der weit verbreiteten Verwendung von Verfahrenssprachen wurden objektorientierte Programmiersprachen (OOP) erstellt, wie Simula, Smalltalk, C,+ Eiffel, Python, PHP, Java und C#. In diesen Sprachen werden Daten und Methoden zur Manipulation als eine Einheit, die als Objekt bezeichnet wird, gespeichert. Bei perfekter Verkapselung ist eine der Unterscheidungsmerkmale von OOP die einzige Möglichkeit, dass ein anderes Objekt oder Benutzer auf die Daten zugreifen kann, über die Methoden des Objekts. So können die inneren Arbeiten des Objekts geändert werden, ohne dass irgendein Code, der das Objekt verwendet, beeinflusst wird. Es gibt noch einige Kontroversen, die von Alexander Stepanov, Richard Stallman und anderen Programmierern angesprochen wurden, über die Wirksamkeit des OOP Paradigmas gegenüber dem Verfahrensparadigma. Die Notwendigkeit für jedes Objekt assoziative Methoden zu haben führt einige Skeptiker OOP mit Software-Blut zu verknüpfen; ein Versuch, dieses Dilemma zu lösen, kam durch Polymorphismus. Da die objektorientierte Programmierung als Paradigma betrachtet wird, nicht als Sprache, kann auch eine objektorientierte Assemblersprache erstellt werden. Die High Level Assembly (HLA) ist ein Beispiel dafür, dass sie trotz ihrer frühen Entstehung voll und ganz fortschrittliche Datentypen und objektorientierte Montagesprachenprogrammierung unterstützt. So können unterschiedliche Programmierparadigmen eher als Motivationsmemememe ihrer Befürworter betrachtet werden, anstatt unbedingt Fortschritte von einer Ebene zur nächsten zu repräsentieren. Präzise Vergleiche der Wirksamkeit von konkurrierenden Paradigmen werden häufig wegen neuer und unterschiedlicher Terminologie, die auf ähnliche Wesen und Prozesse angewendet wird, sowie zahlreicher Implementierungsunterschiede in Sprachen erschwert. Weitere Paradigmen Literate Programmierung, als eine Form der zwingenden Programmierung, Strukturen Programme als human-zentriertes Web, wie in einem Hypertext Essay: Dokumentation ist integraler Bestandteil des Programms, und das Programm ist nach der Logik der Prose-Exposition strukturiert, anstatt Compiler Bequemlichkeit. Unabhängig von der zwingenden Branche wurden deklarative Programmierparadigmen entwickelt. In diesen Sprachen wird dem Computer mitgeteilt, was das Problem ist, nicht wie man das Problem löst – das Programm ist als eine Reihe von Eigenschaften strukturiert, um im erwarteten Ergebnis zu finden, nicht als ein Verfahren zu folgen. Bei einer Datenbank oder einer Reihe von Regeln versucht der Computer, eine Lösung zu finden, die alle gewünschten Eigenschaften entspricht. Ein Archetyp einer deklarativen Sprache ist die vierte Generationssprache SQL, und die Familie der Funktionssprachen und Logikprogrammierung. Funktionsprogrammierung ist eine Teilmenge deklarativer Programmierung. Programme, die mit diesen Paradigmen-Nutzungsfunktionen geschrieben werden, Blöcke von Code, die wie mathematische Funktionen verhalten sollen. Funktionelle Sprachen entmutigen Veränderungen des Wertes von Variablen durch Zuordnung, was statt dessen eine große Verwendung von Rekursion macht. Die Logik-Programmierung Paradigmen betrachtet Berechnung als automatisierte Argumentation über einen Körper des Wissens. Fakten über die Problemdomäne werden als logische Formeln ausgedrückt, und Programme werden durch Anwendung von Inferenzregeln über sie ausgeführt, bis eine Antwort auf das Problem gefunden wird, oder die Menge der Formeln wird als inkonsistent erwiesen. Symbolische Programmierung ist ein Paradigma, das Programme beschreibt, die Formeln und Programmkomponenten als Daten manipulieren können. Programme können sich so effektiv verändern und lernen, so dass sie für Anwendungen wie künstliche Intelligenz, Expertensysteme, natürliche Sprachverarbeitung und Computerspiele geeignet sind. Sprachen, die dieses Paradigma unterstützen, sind Lisp und Prolog. Unterschiedliche Programmierstrukturen Programme, so dass sie durchgängig differenziert werden können, meist über automatische Differenzierung. Unterstützung für mehrere Paradigmen Die meisten Programmiersprachen unterstützen mehr als ein Programmierparadigma, um Programmierern den am besten geeigneten Programmierstil und damit verbundene Sprachkonstrukte für einen bestimmten Job zu ermöglichen. Siehe auch Referenzen Externe Links Klassifizierung der wichtigsten Programmplanungsparadigmen Wie sich die Programmierung von Paradigmen weiterentwickelt und angenommen wird?