Im Bereich der künstlichen Intelligenz ist ein Inferenzmotor Bestandteil des Systems, das logische Regeln für die Wissensbasis zur Ableitung neuer Informationen anwendet. Die ersten Inferenzmotoren waren Komponenten von Expertensystemen. Das typische Expertensystem bestand aus einer Wissensbasis und einem Inferenzmotor. Die Wissensbasis hat Fakten über die Welt gespeichert. Die Inferenz-Engine wendet logische Regeln auf die Wissensbasis an und hat neue Kenntnisse abgeleitet. Dieser Prozess würde iterieren, da jede neue Tatsache in der Wissensbasis zusätzliche Regeln im Inferenzmotor auslösen könnte. Inferenzmotoren arbeiten in erster Linie in einem von zwei Modi entweder spezielle Regel oder Tatsachen: Vorwärtsketten und Rückwärtsketten. Vorwärtsketten beginnen mit den bekannten Tatsachen und behauptet neue Fakten. Backward Chaining beginnt mit Zielen und arbeitet rückwärts, um zu bestimmen, welche Fakten behauptet werden müssen, damit die Ziele erreicht werden können. Architektur Die Logik, die ein Inferenzmotor verwendet, wird typischerweise als IF-THEN-Regeln dargestellt. Das allgemeine Format dieser Regeln ist IF <logical expression> THEN <logical expression>. Vor der Entwicklung von Expertensystemen und Inferenzmotoren konzentrierten sich künstliche Intelligenz-Forscher auf leistungsfähigere Theorem-Prover-Umgebungen, die viel umfassendere Implementierungen der ersten Ordnungslogik boten. Zum Beispiel allgemeine Aussagen, die die universelle Quantifizierung enthalten (für alle X ist eine Aussage wahr) und existentielle Quantifizierung (es gibt einige X so, dass eine Aussage wahr ist). Was Forscher entdeckten, ist, dass die Macht dieser theorem-proving Umgebungen auch ihr Nachteil war. 1965 war es viel zu einfach, logische Ausdrücke zu schaffen, die eine unbestimmte oder sogar unendliche Zeit zum Abschluss nehmen könnten. Beispielsweise ist es in der universellen Quantifizierung üblich, Aussagen über einen unendlichen Satz wie den Satz aller natürlichen Zahlen zu machen. Solche Aussagen sind durchaus vernünftig und sogar in mathematischen Beweisen erforderlich, aber wenn in einem automatisierten Theorem Prover, der auf einem Computer ausgeführt wird, enthalten kann, kann der Computer in eine unendliche Schleife fallen. Die Fokussierung auf IF-THEN-Anweisungen (was Logiker modus ponens nennen) gab den Entwicklern immer noch einen sehr leistungsfähigen allgemeinen Mechanismus, um Logik zu repräsentieren, aber einen, der effizient mit rechnerischen Ressourcen verwendet werden könnte. Darüber hinaus gibt es einige psychologische Forschung, die den Menschen anzeigt, neigen auch dazu, IF-THEN Darstellungen zu bevorzugen, wenn komplexes Wissen gespeichert wird. Ein einfaches Beispiel von Modus ponens oft in einleitenden Logikbüchern verwendet ist "Wenn Sie Mensch sind, dann sind Sie sterblich". Dies kann in Pseudocode dargestellt werden wie: Regel1: Mensch(x) >=Mortal(x) Ein triviales Beispiel dafür, wie diese Regel in einem Inferenzmotor verwendet werden würde, ist wie folgt. Bei der Weiterverkettung würde die Inferenz-Engine alle Fakten in der Wissensbasis finden, die Human(x) und für jede gefundene Tatsache würde die neue Information Mortal(x) zur Wissensbasis hinzufügen. Wenn es also ein Objekt namens Sokrates gefunden hätte, das menschlich war, würde es dazu führen, dass Sokrates sterblich war. In der Rückwärtskette würde das System ein Ziel erhalten, z.B. die Frage zu beantworten ist Sokrates sterblich? Es würde durch die Wissensbasis suchen und bestimmen, ob Sokrates Mensch war und wenn ja, würde er auch sterblich behaupten. Bei der Rückwärtskette war jedoch eine gemeinsame Technik, die Inferenzmaschine mit einer Benutzeroberfläche zu integrieren. Auf diese Weise könnte das System nicht einfach automatisiert werden. In diesem trivialen Beispiel, wenn das System gegeben wurde das Ziel, die Frage zu beantworten, wenn Sokrates sterblich war und es noch nicht wusste, ob er menschlich war, würde es ein Fenster erzeugen, um dem Benutzer die Frage zu stellen "Ist Sokrates human?" und würde dann diese Informationen entsprechend verwenden. Diese Innovation der Integration des Inferenzmotors mit einer Benutzeroberfläche führte zur zweiten frühzeitigen Weiterentwicklung von Expertensystemen: Erklärungsfähigkeiten. Die explizite Darstellung von Wissen als Regeln statt Code ermöglichte es den Benutzern, Erklärungen zu erstellen: beide Erklärungen in Echtzeit und nach der Tatsache. Wenn das System den Benutzer "Is Socrates human?" fragte, fragt sich der Benutzer, warum sie gefragt wurde, dass Frage und das System würde die Kette von Regeln verwenden, um zu erklären, warum es derzeit versuchte, dieses Wissen zu ermitteln: das heißt, es muss bestimmen, ob Sokrates sterblich ist und das zu tun muss, ob er Mensch ist. Zuerst waren diese Erklärungen nicht viel anders als die Standard-Debugging-Informationen, mit denen Entwickler bei der Debugging eines Systems umgehen. Ein aktives Forschungsgebiet nutzte jedoch die natürliche Sprachtechnologie, um Fragen und Erläuterungen mit natürlichen Sprachen zu stellen, zu verstehen und zu erzeugen, anstatt Computerformalismen. Ein Inferenz-Engine-Zyklus durch drei aufeinanderfolgende Schritte: Spielregeln, Auswahlregeln und Ausführung von Regeln. Die Ausführung der Regeln wird oft dazu führen, dass neue Fakten oder Ziele der Wissensbasis hinzugefügt werden, die den Zyklus zur Wiederholung auslösen. Dieser Zyklus geht weiter, bis keine neuen Regeln aufeinander abgestimmt werden können. Im ersten Schritt, Spielregeln, findet der Inferenzmotor alle Regeln, die durch den aktuellen Inhalt der Wissensbasis ausgelöst werden. In der Vorwärtskette sucht der Motor nach Regeln, bei denen der Vorgesetzte (linke Handseite) in der Wissensbasis eine gewisse Tatsache übereinstimmt. Bei Rückwärtsketten sucht der Motor nach Vorgesetzten, die eines der aktuellen Ziele erfüllen können. Im zweiten Schritt Auswahlregeln priorisiert der Inferenzmotor die verschiedenen Regeln, die angepasst wurden, um die Reihenfolge zu bestimmen, um sie auszuführen. Im abschließenden Schritt führt der Motor in der in Schritt zwei bestimmten Reihenfolge jede angepasste Regel aus und iteriert dann wieder auf Schritt eins. Der Zyklus geht weiter, bis keine neuen Regeln übereinstimmen. Implementierungen Frühinterferenzmotoren konzentrierten sich vor allem auf die Weiterverkettung. Diese Systeme wurden in der Regel in der Programmiersprache Lisp implementiert. Lisp war eine häufige Plattform für die frühe KI-Forschung aufgrund seiner starken Fähigkeit, symbolische Manipulation zu tun. Auch als interpretierte Sprache bot es produktive Entwicklungsumgebungen, die geeignet sind, komplexe Programme zu entschärfen. Eine notwendige Folge dieser Vorteile war, dass Lisp-Programme eher langsamer und weniger robust als kompilierte Sprachen der Zeit wie C. Ein gemeinsamer Ansatz in diesen frühen Tagen war, eine Expertensystemanwendung zu ergreifen und den für dieses System verwendeten Inferenzmotor als wiederverwendbares Werkzeug neu zu verpacken, das andere Forscher für die Entwicklung anderer Expertensysteme nutzen konnten. Zum Beispiel war MYCIN ein frühes Expertensystem für die medizinische Diagnose und EMYCIN war ein Interferenz-Engine extrapoliert von MYCIN und für andere Forscher zur Verfügung gestellt. Da sich Expertensysteme von Forschungsprototypen auf eingesetzte Systeme bewegten, standen Themen wie Geschwindigkeit und Robustheit im Vordergrund. Einer der ersten und beliebtesten Vorwärtskettenmotoren war OPS5, die den Rete-Algorithmus verwendet, um die Effizienz der Regelfeuerung zu optimieren. Eine weitere sehr populäre Technologie, die entwickelt wurde, war die Prolog Logik Programmiersprache. Prolog konzentrierte sich vor allem auf Rückwärtsketten und verfügte auch über verschiedene kommerzielle Versionen und Optimierungen für Effizienz und Robustheit. Da Expert Systems großes Interesse aus der Geschäftswelt veranlasste, haben viele von ihnen von prominenten KI-Forschern begonnen oder geleitete Produktversionen von Inferenzmotoren erstellt. Zum Beispiel wurde Intellicorp zunächst von Edward Feigenbaum geleitet. Diese Inferenzmotor-Produkte wurden auch oft in Lisp entwickelt. Jedoch, Anforderungen an erschwinglichere und kommerziell lebensfähige Plattformen schließlich machte Personal Computer Plattformen sehr beliebt. Siehe auch Geometrische und Topologische Inferenz Aktionsauswahlmechanismus Backward chaining Expert systemForward chaining Induktive Inferenz == Referenzen ==