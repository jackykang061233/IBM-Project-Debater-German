In der Informatik ist eine Bibliothek eine Sammlung von nichtflüchtigen Ressourcen, die von Computerprogrammen verwendet werden, oft für die Softwareentwicklung. Diese können Konfigurationsdaten, Dokumentationen, Hilfedaten, Nachrichtenvorlagen, vorgeschriebenen Code und Unterprogrammen, Klassen, Werte oder Typspezifikationen umfassen. In IBMs OS/360 und seinen Nachfolgern werden sie als verteilte Datensätze bezeichnet. Eine Bibliothek ist auch eine Sammlung von Implementierungen des Verhaltens, geschrieben in Bezug auf eine Sprache, die eine gut definierte Schnittstelle, durch die das Verhalten aufgerufen wird. Zum Beispiel können Personen, die ein höheres Programm schreiben möchten, eine Bibliothek verwenden, um Systemanrufe zu tätigen, anstatt diese Systemanrufe immer wieder umzusetzen. Darüber hinaus ist das Verhalten zur Wiederverwendung durch mehrere unabhängige Programme vorgesehen. Ein Programm ruft das bibliotheksbereite Verhalten über einen Mechanismus der Sprache an. Beispielsweise wird in einer einfachen Imperativsprache wie C das Verhalten in einer Bibliothek durch die Verwendung von C's normaler Funktion aufgerufen. Was den Ruf als eine Bibliotheksfunktion unterscheidet, im Gegensatz zu einer anderen Funktion im gleichen Programm, ist die Art, wie der Code im System organisiert ist. Der Bibliothekscode ist so organisiert, dass er von mehreren Programmen verwendet werden kann, die keine Verbindung zueinander haben, während der Code, der Teil eines Programms ist, nur innerhalb dieses Programms verwendet wird. Diese Unterscheidung kann eine hierarchische Vorstellung gewinnen, wenn ein Programm groß wächst, wie ein Multi-Millionen-line-Programm. In diesem Fall können interne Bibliotheken vorhanden sein, die durch unabhängige Teilanteile des großen Programms wiederverwendet werden. Das Unterscheidungsmerkmal ist, dass eine Bibliothek zum Zwecke der Wiederverwendung durch unabhängige Programme oder Unterprogramme organisiert wird, und der Benutzer muss nur die Schnittstelle und nicht die internen Details der Bibliothek kennen. Der Wert einer Bibliothek liegt in der Wiederverwendung von standardisierten Programmelementen. Wenn ein Programm eine Bibliothek anruft, erhält es das innerhalb dieser Bibliothek implementierte Verhalten, ohne dieses Verhalten selbst umzusetzen. Bibliotheken fördern den Austausch von Code modular und erleichtern die Verteilung des Codes. Das von einer Bibliothek implementierte Verhalten kann an unterschiedlichen Programmlebensphasen mit dem Aufrufprogramm verbunden werden. Wird während des Aufbaus des Aufrufprogramms der Code der Bibliothek aufgerufen, so wird die Bibliothek als statische Bibliothek bezeichnet. Eine Alternative besteht darin, das ausführbare Programm zu erstellen und unabhängig von der Bibliotheks-Implementierung zu verbreiten. Das Bibliotheksverhalten ist verbunden, nachdem das ausführbare Verhalten entweder als Teil des Prozesses des Startens der Ausführung oder in der Mitte der Ausführung ausgeführt worden ist. In diesem Fall wird die Bibliothek als dynamische Bibliothek (zur Laufzeit geladen) bezeichnet. Eine dynamische Bibliothek kann bei der Erstellung eines Programms zur Ausführung vom Linker geladen und verknüpft werden. Alternativ kann eine Anwendung in der Mitte der Ausführung explizit verlangen, dass ein Modul geladen wird. Die meisten kompilierten Sprachen verfügen über eine Standardbibliothek, obwohl Programmierer auch eigene benutzerdefinierte Bibliotheken erstellen können. Die meisten modernen Software-Systeme bieten Bibliotheken, die die Mehrheit der Systemdienste implementieren. Solche Bibliotheken haben die Dienste organisiert, die eine moderne Anwendung erfordert. In diesen Systembibliotheken wird als solcher die meisten von modernen Anwendungen verwendeten Codes bereitgestellt. Geschichte Im Jahr 1947 spekulierten Goldstine und von Neumann, dass es nützlich wäre, eine Bibliothek von Unterprogrammen für ihre Arbeit an der IAS-Maschine zu erstellen, ein früher Computer, der damals noch nicht in Betrieb war. Sie sahen eine physikalische Bibliothek von Magnetdrahtaufnahmen vor, wobei jeder Draht wiederverwendbare Computercode speichert. Inspiriert von Neumann, bauten Wilkes und sein Team EDSAC. Ein Ablageschrank aus gestanztem Band hielt die Unterprogrammbibliothek für diesen Computer. Programme für EDSAC bestanden aus einem Hauptprogramm und einer Sequenz von Unterprogrammen, die aus der Unterprogrammbibliothek kopiert wurden. 1951 veröffentlichte das Team das erste Lehrbuch über die Programmierung, die Vorbereitung von Programmen für einen elektronischen digitalen Computer, die die Erstellung und den Zweck der Bibliothek detailliert. COBOL beinhaltete 1959 "primitive Fähigkeiten für ein Bibliothekssystem", aber Jean Sammet beschrieb sie im Nachhinein als "indequate Bibliothekseinrichtungen". JOVIAL hatte einen Kommunikationspool (COMPOOL), etwa eine Bibliothek von Header-Dateien. Ein weiterer wesentlicher Beitrag zum modernen Bibliothekskonzept kam in Form der Unterprogramminnovation von FORTRAN. FORTRAN Unterprogramme können unabhängig voneinander kompiliert werden, aber der Compiler fehlte an einem Linker.Vor der Einführung von Modulen in Fortran-90 war also eine Typprüfung zwischen FORTRAN-Unterprogrammen unmöglich. Bis Mitte der 1960er Jahre waren Kopier- und Makrobibliotheken für Assembler üblich. Ausgehend von der Popularität des IBM System/360 wurden auch Bibliotheken, die andere Arten von Textelementen, z.B. Systemparameter, enthalten, gemeinsam. Simula war die erste objektorientierte Programmiersprache, und seine Klassen waren fast identisch mit dem modernen Konzept, wie es in Java, C,+ und C# verwendet wurde.Das Klassenkonzept von Simula war auch ein Progenitor des Pakets in Ada und dem Modul von Modula-2. Auch wenn er ursprünglich 1965 entwickelt wurde, konnten Simula-Klassen in Bibliotheksdateien aufgenommen und zu kompilieren Zeit hinzugefügt werden. Linking Libraries sind wichtig im Programm-Linking- oder Bindungsprozess, der Referenzen, die als Links oder Symbole zu Bibliotheksmodulen bekannt sind, löst. Der Verknüpfungsprozess wird in der Regel automatisch von einem Linker- oder Binderprogramm durchgeführt, das eine Reihe von Bibliotheken und anderen Modulen in einer bestimmten Reihenfolge sucht. Normalerweise wird es nicht als Fehler angesehen, wenn ein Link-Ziel mehrfach in einem bestimmten Satz von Bibliotheken gefunden werden kann. Die Verknüpfung kann erfolgen, wenn eine ausführbare Datei erstellt wird, oder wenn das Programm zur Laufzeit verwendet wird. Die zu lösenden Referenzen können Adressen für Sprünge und andere Routineanrufe sein. Sie können im Hauptprogramm oder in einem Modul in Abhängigkeit von einem anderen sein. Sie werden durch Zuordnung von Laufzeitspeichern für die Speichersegmente jedes referenzierten Moduls in feste oder versetzbare Adressen (aus einer gemeinsamen Basis) aufgelöst. Einige Programmiersprachen verwenden eine Funktion, die als Smart Linking bezeichnet wird, wobei der Linker sich bewusst ist oder mit dem Compiler integriert ist, so dass der Linker weiß, wie externe Referenzen verwendet werden, und Code in einer Bibliothek, die nie verwendet wird, obwohl intern referiert, kann aus der zusammengestellten Anwendung verworfen werden. Beispielsweise kann ein Programm, das nur ganze Zahlen für arithmetische verwendet, oder überhaupt keine arithmetischen Operationen, Floating-Point-Bibliothek Routinen ausschließen. Diese Smart-Linking-Funktion kann zu kleineren Anwendungsdateigrößen und reduzierter Speichernutzung führen. Standort Einige Referenzen in einem Programm- oder Bibliotheksmodul werden in einer relativen oder symbolischen Form gespeichert, die nicht aufgelöst werden kann, bis alle Codes und Bibliotheken endgültigen statischen Adressen zugeordnet sind. Die Verlagerung ist der Prozess der Anpassung dieser Referenzen und erfolgt entweder durch den Linker oder den Loader. Generell kann eine Verlagerung nicht an einzelne Bibliotheken selbst vorgenommen werden, da die Adressen im Speicher je nach Programm mit ihnen und anderen Bibliotheken, mit denen sie kombiniert werden, variieren können. Positionsunabhängiger Code vermeidet Referenzen auf absolute Adressen und erfordert daher keine Umsiedlung. Statische Bibliotheken Bei der Verknüpfung bei der Erstellung einer ausführbaren oder einer anderen Objektdatei wird diese als statische Verknüpfung oder Frühbindung bezeichnet. In diesem Fall erfolgt die Verknüpfung meist durch einen Linker, kann aber auch durch den Compiler erfolgen. Eine statische Bibliothek, auch Archiv genannt, soll statisch verknüpft sein. Ursprünglich gab es nur statische Bibliotheken. Die statische Verknüpfung muss durchgeführt werden, wenn Module wieder kompiliert werden. Alle Module, die ein Programm benötigt, werden manchmal statisch verknüpft und in die ausführbare Datei kopiert. Dieser Vorgang und die daraus resultierende Stand-alone-Datei sind als statischer Aufbau des Programms bekannt. Ein statischer Aufbau kann keine weitere Verlagerung benötigen, wenn virtueller Speicher verwendet wird und keine Adressraumlayout-Tarifisierung gewünscht wird. Gemeinsame Bibliotheken Eine freigegebene Bibliothek oder geteiltes Objekt ist eine Datei, die von ausführbaren Dateien und weiteren freigegebenen Objektdateien geteilt werden soll. Module, die von einem Programm verwendet werden, werden von einzelnen geteilten Objekten zu Last- oder Laufzeit in den Speicher geladen, anstatt von einem Linker kopiert zu werden, wenn es eine einzige monolithische ausführbare Datei für das Programm erstellt. Geteilte Bibliotheken können während der Kompilierungszeit statisch verknüpft werden, so dass Referenzen zu den Bibliotheksmodulen aufgelöst werden und die Module beim Erstellen der ausführbaren Datei Speicher zugewiesen werden. Aber oft wird die Verknüpfung von gemeinsamen Bibliotheken verschoben, bis sie geladen werden. Die meisten modernen Betriebssysteme können freigegebene Bibliotheksdateien des gleichen Formats wie die ausführbaren Dateien haben. Dies bietet zwei Hauptvorteile: Erstens erfordert es, für beide nur einen Lader zu machen, anstatt zwei (da der Einzellader seine zusätzliche Komplexität wert ist). Zweitens können die Ausführbaren auch als gemeinsame Bibliotheken verwendet werden, wenn sie eine Symboltabelle haben. Typische kombinierte ausführbare und geteilte Bibliotheksformate sind ELF und Mach-O (beide in Unix) und PE (Windows.)In einigen älteren Umgebungen wie 16-Bit Windows oder MPE für den HP 3000 wurden nur stapelbasierte Daten (lokal) im Freigabecode erlaubt, oder andere signifikante Einschränkungen wurden auf den Freigabecode gesetzt. Speicher-Sharing-Bibliothek-Code kann im Speicher durch mehrere Prozesse, sowie auf Festplatte geteilt werden. Wenn virtueller Speicher verwendet wird, würden Prozesse die gleiche physikalische Seite von RAM ausführen, die in die verschiedenen Adressräume der Prozesse abgebildet wird. Dies hat Vorteile. Zum Beispiel waren auf dem OpenStep-System oft nur wenige hundert Kilobyte groß und schnell geladen; der Großteil ihres Codes lag in Bibliotheken, die bereits für andere Zwecke vom Betriebssystem geladen worden waren. Programme können RAM-Sharing durch die Verwendung von positionsunabhängigen Code, wie in Unix, die zu einer komplexen aber flexiblen Architektur führt, oder durch die Verwendung gemeinsamer virtueller Adressen, wie in Windows und OS/2. Diese Systeme sorgen dafür, dass durch verschiedene Tricks wie das Vor-Mapping des Adressraums und das Reservieren von Slots für jede freigegebene Bibliothek dieser Code eine große Wahrscheinlichkeit hat, geteilt zu werden. Eine dritte Alternative ist ein Single-Level-Store, wie vom IBM System/38 und seinen Nachfolgern verwendet. Dies ermöglicht positionsabhängigen Code, stellt aber keine signifikanten Einschränkungen auf, wo Code platziert werden kann oder wie es geteilt werden kann. In einigen Fällen können verschiedene Versionen von freigegebenen Bibliotheken Probleme verursachen, insbesondere wenn Bibliotheken verschiedener Versionen den gleichen Dateinamen haben, und verschiedene Anwendungen, die auf einem System installiert sind, benötigen jeweils eine bestimmte Version. Ein solches Szenario ist als DLL Hölle bekannt, benannt nach der Windows-und OS/2 DLL-Datei. Die meisten modernen Betriebssysteme haben nach 2001 Reinigungsmethoden, um solche Situationen zu beseitigen oder anwendungsspezifische private Bibliotheken zu verwenden. Dynamische Verknüpfung Dynamische Verknüpfung oder late-bindliche Verknüpfung wird durchgeführt, während ein Programm geladen wird (Lastzeit) oder ausgeführt (Laufzeit), anstatt wenn die ausführbare Datei erstellt wird. Eine dynamisch verknüpfte Bibliothek (Dynamik-Link-Bibliothek, oder DLL, unter Windows und OS/2; austauschbares Bild unter OpenVMS; dynamisches gemeinsames Objekt, oder DSO, unter Unix-ähnlichen Systemen) ist eine Bibliothek, die zur dynamischen Verknüpfung bestimmt ist. Bei der Erstellung der ausführbaren Datei wird vom Linker nur eine minimale Menge Arbeit geleistet; es erfasst nur, welche Bibliotheksroutinen das Programm benötigt und die Indexnamen oder Nummern der Routinen in der Bibliothek. Der Großteil der Verknüpfungsarbeit erfolgt zum Zeitpunkt der Beladung (Lastzeit) oder während der Ausführung (Laufzeit). Üblicherweise ist das notwendige Verknüpfungsprogramm, genannt "dynamischer Linker" oder "Linking Loader", tatsächlich Teil des zugrunde liegenden Betriebssystems. ( Es ist jedoch möglich und nicht schwer, ein Programm zu schreiben, das dynamische Verknüpfung verwendet und einen eigenen dynamischen Linker umfasst, auch für ein Betriebssystem, das selbst keine Unterstützung für dynamische Verknüpfung bietet.) Die Programmierer entwickelten ursprünglich eine dynamische Verknüpfung im Multics-Betriebssystem ab 1964 und das in den späten 1960er Jahren gebaute MTS (Michigan Terminal System). Optimierungen Da sich die freigegebenen Bibliotheken auf den meisten Systemen nicht oft ändern, können Systeme eine wahrscheinliche Lastadresse für jede freigegebene Bibliothek auf dem System berechnen, bevor sie benötigt wird und diese Informationen in den Bibliotheken und Ausführungsdateien speichern. Wenn jede freigegebene Bibliothek, die geladen wird, diesen Prozess durchlaufen hat, wird jeder mit seiner vorbestimmten Adresse laden, die den Prozess der dynamischen Verknüpfung beschleunigt. Diese Optimierung ist als Vorbindung in macOS und Vorverlinkung in Linux bekannt. Nachteile dieser Technik sind die Zeit, die erforderlich ist, um diese Adressen jedes Mal zu precomputieren, wenn sich die freigegebenen Bibliotheken ändern, die Unfähigkeit, die Adressraumlayout-Tarifisierung zu verwenden, und die Anforderung eines ausreichenden virtuellen Adressraums für die Nutzung (ein Problem, das durch die Annahme von 64-Bit-Architekturen zumindest für die Zeit verringert wird.) Die Lokalisierung von Bibliotheken zu Laufzeit Die Loader für freigegebene Bibliotheken variieren in der Funktionalität. Einige hängen von der ausführbaren Speicherung expliziter Pfade zu den Bibliotheken ab. Jede Änderung des Bibliotheksnamens oder Layouts des Dateisystems wird dazu führen, dass diese Systeme ausfallen. Allgemeiner wird nur der Name der Bibliothek (und nicht der Pfad) in der ausführbaren gespeichert, wobei das Betriebssystem ein Verfahren liefert, um die Bibliothek auf Festplatte zu finden, basierend auf einem bestimmten Algorithmus. Wenn eine freigegebene Bibliothek, von der ein ausführbares abhängt, gelöscht, verschoben oder umbenannt wird, oder wenn eine unvereinbare Version der Bibliothek an einen Ort kopiert wird, der früher in der Suche ist, würde das ausführbare nicht geladen. Dies nennt man Abhängigkeit Hölle, die auf vielen Plattformen vorhanden ist.Die (infamous) Windows Variante ist allgemein als DLL-Hölle bekannt. Dieses Problem kann nicht auftreten, wenn jede Version jeder Bibliothek eindeutig identifiziert wird und jedes Programm nur durch seine vollständigen eindeutigen Kennungen auf Bibliotheken verweist. Die "DLL hell" Probleme mit früheren Windows-Versionen entstanden aus der Verwendung nur die Namen von Bibliotheken, die nicht garantiert einzigartig zu sein, um dynamische Links in Programmen zu lösen. (Um "DLL hell", spätere Versionen von Windows verlassen sich weitgehend auf Optionen für Programme, um private DLLs zu installieren - im Wesentlichen ein teilweiser Rückzug von der Verwendung von freigegebenen Bibliotheken - zusammen mit Mechanismen, um den Austausch von geteilten System DLLs mit früheren Versionen von ihnen zu verhindern.) Microsoft Windows Windows prüft das Register, um den richtigen Ort zu laden DLLs, die COM-Objekte implementieren, aber für andere DLLs wird es die Verzeichnisse in einer definierten Reihenfolge überprüfen. Zuerst, Windows überprüft das Verzeichnis, in dem es das Programm geladen (private DLL;) alle Verzeichnisse, die durch den Aufruf der SetDllDirectory() Funktion gesetzt werden; das System32, System und Windows-Verzeichnisse; dann das aktuelle Arbeitsverzeichnis; und schließlich die Verzeichnisse, die von der PATH-Umgebungsvariable spezifiziert. Anwendungen geschrieben für das .NET Framework (seit 2002,) überprüfen auch die Global Assembly Cache als primärer Speicher von geteilten dll Dateien, um das Problem der DLL Hölle zu entfernen. OpenStep OpenStep nutzte ein flexibleres System und sammelte eine Liste von Bibliotheken aus einer Reihe von bekannten Standorten (ähnlich dem PATH-Konzept), wenn das System erst beginnt. Um Bibliotheken herum zu bewegen, gibt es überhaupt keine Probleme, obwohl Benutzer beim ersten Starten des Systems einen Zeitaufwand verursachen. Unixartige Systeme Die meisten Unix-ähnlichen Systeme haben einen "Suchpfad", der Datei-System-Verzeichnisse angibt, in denen dynamische Bibliotheken gesucht werden sollen. Einige Systeme geben den Standardpfad in einer Konfigurationsdatei an, andere codieren ihn fest in den dynamischen Loader. Einige ausführbare Dateiformate können zusätzliche Verzeichnisse angeben, in denen Sie nach Bibliotheken für ein bestimmtes Programm suchen. Dies kann in der Regel mit einer Umgebungsvariable überschrieben werden, obwohl es für setuid- und setgid-Programme deaktiviert ist, so dass ein Benutzer ein solches Programm nicht zwingen kann, beliebigen Code mit root-Berechtigungen auszuführen. Entwickler von Bibliotheken werden ermutigt, ihre dynamischen Bibliotheken an Orten in den Standard-Suchpfad zu platzieren. Auf der Unterseite kann dies die Installation von neuen Bibliotheken problematisch machen, und diese bekannten Standorte werden schnell zu einer wachsenden Anzahl von Bibliotheksdateien zu Hause, so dass das Management komplexer. Dynamische Beladung Dynamische Beladung, eine Teilmenge dynamischer Verknüpfung, beinhaltet auf Anfrage eine dynamisch verknüpfte Bibliothek Be- und Entladezeit. Eine solche Anforderung kann implizit oder explizit erfolgen. Implizite Anfragen werden gestellt, wenn ein Compiler oder statischer Linker Bibliotheksreferenzen hinzufügt, die Dateipfade oder einfach Dateinamen enthalten. Explizite Anfragen werden gestellt, wenn Anwendungen direkte Anrufe in die API eines Betriebssystems machen. Die meisten Betriebssysteme, die dynamisch verknüpfte Bibliotheken unterstützen, unterstützen auch das dynamische Laden solcher Bibliotheken über eine Laufzeit-Linker-API. Microsoft Windows verwendet beispielsweise die API-Funktionen LoadLibrary, LoadLibraryEx, FreeLibrary und GetProcAddress mit Microsoft Dynamic Link Libraries; POSIX-basierte Systeme, einschließlich der meisten UNIX und UNIX-ähnlichen Systeme, verwenden dlopen, dlclose und dlsym. Einige Entwicklungssysteme automatisieren diesen Prozess. Objekt- und Klassenbibliotheken Obwohl ursprünglich in den 1960er Jahren Pionierarbeit geleistet wurde, erreichte die dynamische Verknüpfung bis Ende der 1980er Jahre keine von den Verbrauchern genutzten Betriebssysteme. Sie war in den meisten Betriebssystemen bis Anfang der 1990er Jahre in gewisser Weise verfügbar. Während dieser gleichen Zeit wurde die objektorientierte Programmierung (OOP) zu einem wesentlichen Teil der Programmierlandschaft. OOP mit Laufzeitbindung erfordert zusätzliche Informationen, die traditionelle Bibliotheken nicht liefern. Neben den Namen und Eingabepunkten des innerhalb befindlichen Codes benötigen sie auch eine Liste der von ihnen abhängigen Objekte. Dies ist ein Nebeneffekt eines der Hauptvorteile von OOP, Vererbung, was bedeutet, dass Teile der vollständigen Definition jedes Verfahrens an verschiedenen Stellen sein können. Dies ist mehr als nur eine Auflistung, dass eine Bibliothek die Dienste einer anderen erfordert: in einem echten OOP-System, die Bibliotheken selbst nicht bekannt zu kompilieren Zeit, und variieren von System zu System. Gleichzeitig arbeiteten viele Entwickler an der Idee von mehrstufigen Programmen, bei denen ein auf einem Desktopcomputer laufendes Display die Dienste eines Mainframes oder Minicomputers zur Datenspeicherung oder -verarbeitung nutzen würde. Zum Beispiel würde ein Programm auf einem GUI-basierten Computer Nachrichten an einen Minicomputer senden, um kleine Proben eines riesigen Datensatzes für die Anzeige zurückzugeben.Remote Prozedur Anrufe (RPC) haben diese Aufgaben bereits erledigt, aber es gab kein Standard-RPC-System. Die Mehrheit des Minicomputers und der Mainframe-Anbieter hat die beiden Projekte angestiftet, um ein OOP-Bibliotheksformat herzustellen, das überall verwendet werden könnte. Solche Systeme wurden als Objektbibliotheken oder verteilte Objekte bezeichnet, wenn sie den Fernzugriff unterstützten (nicht alle). Microsofts COM ist ein Beispiel für ein solches System für den lokalen Gebrauch. DCOM, eine modifizierte Version von COM, unterstützt den Fernzugriff. Objektbibliotheken hielten für einige Zeit den Status der "nächsten großen Sache" in der Programmierwelt. Es gab eine Reihe von Bemühungen, Systeme zu schaffen, die über Plattformen laufen würden, und Unternehmen konkurrieren, um zu versuchen, Entwickler in ihr eigenes System gesperrt zu bekommen. Beispiele sind IBMs System Object Model (SOM/DSOM,) Sun Microsystems' Distributed Objects Everywhere (DOE,) NeXT's Portable Distributed Objects (g.U.) Digitals ObjectBroker, Microsofts Component Object Model (COM/DCOM) und jede Anzahl von CORBA-basierten Systemen. Nach dem Abkühlen des Marketing-Hypes wurden in beiden objektorientierten Programmier- und verteilten Informationssystemen weiterhin Objektbibliotheken eingesetzt. Klassenbibliotheken sind das grobe OOP-Äquivalent älterer Codebibliotheken. Sie enthalten Klassen, die Merkmale beschreiben und Aktionen (Methoden) definieren, die Objekte beinhalten. Klassenbibliotheken werden verwendet, um Instanzen oder Objekte mit ihren auf bestimmte Werte eingestellten Eigenschaften zu erstellen. In einigen OOP-Sprachen, wie Java, ist die Unterscheidung klar, mit den Klassen oft in Bibliotheksdateien enthalten (wie Javas JAR-Dateiformat) und die Instantiated-Objekte nur im Speicher (obwohl möglicherweise in separaten Dateien persistent gemacht werden können). In anderen, wie Smalltalk, sind die Klassenbibliotheken nur der Ausgangspunkt für ein Systembild, das den gesamten Zustand der Umgebung, Klassen und alle instantiierten Objekte umfasst. Fernbibliotheken Eine weitere Lösung für das Bibliotheksproblem besteht darin, völlig separate Ausführbare (oft in einer leichten Form) zu verwenden und diese mittels eines Remote-Prozedurrufs (RPC) über ein Netzwerk auf einen anderen Computer zu rufen. Dieser Ansatz maximiert die Wiederverwendung des Betriebssystems: Der Code, der zur Unterstützung der Bibliothek benötigt wird, ist der gleiche Code, der verwendet wird, um Anwendung Unterstützung und Sicherheit für jedes andere Programm bereitzustellen. Darüber hinaus erfordern solche Systeme nicht, dass die Bibliothek auf derselben Maschine existiert, sondern können die Anfragen über das Netzwerk weiterleiten. Ein solcher Ansatz bedeutet jedoch, dass jeder Bibliotheksruf eine beträchtliche Menge an Overhead erfordert. RPC-Anrufe sind viel teurer als eine gemeinsame Bibliothek, die bereits auf derselben Maschine geladen wurde. Dieser Ansatz wird häufig in einer verteilten Architektur verwendet, die schwere Nutzung solcher Remote-Anrufe, insbesondere Client-Server-Systeme und Anwendungsserver wie Enterprise JavaBeans, macht. Bibliotheken der Codegenerierung Code-Generierung Bibliotheken sind hochrangige APIs, die Byte-Code für Java generieren oder transformieren können. Sie werden von einer aspektorientierten Programmierung, einigen Data Access Frameworks und zum Testen dynamischer Proxyobjekte verwendet. Sie werden auch verwendet, um Feldzugriff abzufangen. Die meisten modernen Unix-ähnlichen Systeme Das System speichert libfoo.a und libfoo. so Dateien in Verzeichnissen wie /lib, usr/lib oder usr/local/lib. Die Dateinamen beginnen immer mit lib, und enden mit einem Suffix von .a(Archiv, statische Bibliothek) oder von .so (shared object, dynamisch verknüpfte Bibliothek). Einige Systeme können mehrere Namen für eine dynamisch verknüpfte Bibliothek haben. Diese Namen teilen typischerweise das gleiche Präfix und haben verschiedene Suffixes, die die Versionsnummer angeben. Die meisten Namen sind Namen für symbolische Links zu der neuesten Version. Beispielsweise wäre auf einigen Systemen libfoo.so.2 der Dateiname für die zweite Hauptschnittstellenrevision der dynamisch verknüpften Bibliothek libfoo. Die in den Bibliotheksverzeichnissen manchmal gefundenen .la-Dateien sind libtool-Archive, die vom System nicht als solche verwendbar sind. macOS Das System erbt statische Bibliothekskonventionen von BSD, mit der in einer .a-Datei gespeicherten Bibliothek und kann .so-style dynamisch verknüpfte Bibliotheken (mit dem .dylib-Suffix statt). Die meisten Bibliotheken in macOS bestehen jedoch aus Frameworks, die in speziellen Verzeichnissen als Pakete platziert werden, die die benötigten Dateien und Metadaten der Bibliothek einpacken. Zum Beispiel würde ein Rahmen mit dem Namen MyFramework in einem Bündel namens MyFramework.framework implementiert werden, mit MyFramework.framework/MyFramework ist entweder die dynamisch verknüpfte Bibliotheksdatei oder ein Symlink zur dynamisch verknüpften Bibliotheksdatei in MyFramework.framework/Versions/Current/MyFrameworkMicrosoft Windows Dynamic-link-Bibliotheken haben in der Regel die suffix *.DLL, obwohl andere Dateinamen Erweiterungen können spezifische zweck dynamisch verknüpfte Bibliotheken identifizieren, z.B. *.OCX für OLE-Bibliotheken. Die Schnittstellenrevisionen werden entweder in den Dateinamen codiert oder mittels COM-Objekt-Schnittstellen abstrahiert. Je nachdem, wie sie kompiliert werden, können *.LIB-Dateien entweder statische Bibliotheken oder Darstellungen dynamisch verlinkbarer Bibliotheken sein, die nur während der Zusammenstellung benötigt werden, die als "Importbibliotheken" bezeichnet werden. Anders als in der UNIX-Welt, die verschiedene Dateierweiterungen verwendet, wenn Sie gegen . LIB-Datei in Windows muss man zuerst wissen, ob es sich um eine regelmäßige statische Bibliothek oder eine Importbibliothek handelt. Im letzteren Fall muss eine .DLL-Datei zur Laufzeit vorhanden sein. Linker (computing) – Computerprogramm, das mehrere Objektdateien in eine einzelne Datei kombiniert Loader (computing) Dynamic-link-Bibliothek Objekt-Datei – Datei mit verlagerbarem Format-Maschinencode Plug-in – Software-Komponente, die eine Besonderheit einer bestehenden Software-Anwendung hinzufügen Prelink, auch bekannt als Prebinden Static library Runtime library Visual Component Library – Visual Library (VCL) Component Library for Cross Platform (CLX) C Standardbibliothek – Standardbibliothek für die C Programmiersprache Java Class Library Framework Class Library – Standardbibliothek von Microsofts . NETFramework Generelle Programmierung – Art der Gestaltung und Erstellung von Programmen, in denen Algorithmen in Bezug auf parametrische Typen geschrieben werden, die eine einfache Wiederverwendung ermöglichen (von der C+ Standard Library) soname – Feld der Daten in einer gemeinsamen Objektdatei Method stub Notes Referenzen Weiter lesen Levine, John R. (2000) [Oktober 1999]. "Kapitel 9: Geteilte Bibliotheken & Kapitel 10: Dynamische Verknüpfung und Belastung".Linker und Loader. Die Morgan Kaufmann Serie in Software Engineering und Programmierung (1 ed.). San Francisco, USA: Morgan Kaufmann.ISBN 1-55860-496-0.OCLC 42413382.ISBN 978-1-55860-496-4.Archiviert vom Original am 2012-12-05.Retrieved 2020-01-12.Code: 1][2 Errata: [3] Artikel Leitfaden für Anfänger von David Drysdale Artikel Schneller C+-Programm-Startups durch die Verbesserung der Laufzeit-Verknüpfungseffizienz von Léon Bottou und John Ryland So erstellen Sie Programmbibliotheken von Baris Simsek BFD - die Binary File DescriptorLibrary 1stLibrary-Centric Software Design Workshop LCSD'05 bei OOPSLA'05 2nd Library-Centric Software Design Workshop LCSD'06 bei OOPSLA'06 Wie erstellt man eine gemeinsame Bibliothek von Ulrich Drepper (mit viel Hintergrundinfo) Anatomie der Linux dynamischen Bibliotheken bei IBM.com