Ein Betriebssystem (OS) ist Systemsoftware, die Computerhardware, Softwareressourcen verwaltet und gemeinsame Dienste für Computerprogramme bietet. Zeitsparende Betriebssysteme Zeitplan Aufgaben für eine effiziente Nutzung des Systems und kann auch Buchhaltung Software für die Kostenzuweisung der Prozessorzeit, Massenspeicherung, Druck und andere Ressourcen umfassen. Für Hardwarefunktionen wie Eingabe- und Ausgabe- und Speicherzuordnung wirkt das Betriebssystem als Zwischenspeicher zwischen Programmen und der Computerhardware, obwohl der Anwendungscode üblicherweise direkt von der Hardware ausgeführt wird und häufig Systemanrufe zu einer OS-Funktion macht oder von dieser unterbrochen wird. Betriebssysteme finden sich auf vielen Geräten, die einen Computer enthalten – von Handys und Videospielkonsolen über Webserver und Supercomputer. Das dominante allgemeine Desktop-Betriebssystem ist Microsoft Windows mit einem Marktanteil von rund 76.45%.macOS von Apple Inc. ist an zweiter Stelle (17.72%,) und die Sorten von Linux sind kollektiv an dritter Stelle (1.73%). Im mobilen Bereich (einschließlich Smartphones und Tablets) Androids Anteil beträgt bis zu 72% im Jahr 2020. Laut Daten des dritten Quartals 2016 ist der Anteil von Android auf Smartphones mit 87,5 Prozent mit einer Wachstumsrate von 10,3 Prozent pro Jahr, gefolgt von Apples iOS mit 12,1 Prozent mit pro Jahr Rückgang des Marktanteils von 5,2 Prozent, während andere Betriebssysteme nur 0,3 Prozent betragen. Linux-Distributionen sind in den Server- und Supercomputing-Sektoren dominant. Für viele Anwendungen gibt es weitere spezialisierte Klassen von Betriebssystemen (Sonder-Betriebssysteme), wie Embedded- und Echtzeit-Systeme. Es existieren auch sicherheitsgerichtete Betriebssysteme. Einige Betriebssysteme haben geringe Systemanforderungen (z.B. leichte Linux-Distribution). Andere können höhere Systemanforderungen haben. Einige Betriebssysteme benötigen Installation oder können mit gekauften Computern (OEM-Installation) vorinstalliert werden, während andere direkt aus Medien (z.B. Live-CD) oder Flash-Speicher (d.h. USB-Stick) laufen können. Arten von Betriebssystemen Single-tasking und Multi-tasking Ein Single-tasking-System kann nur ein Programm zu einer Zeit laufen, während ein Multi-tasking-Betriebssystem erlaubt, mehr als ein Programm in Konkurrenz laufen. Dies wird durch eine zeitliche Aufteilung erreicht, wobei die verfügbare Prozessorzeit zwischen mehreren Prozessen aufgeteilt wird. Diese Prozesse werden jeweils wiederholt in Zeitscheiben durch ein aufgabenabfragendes Teilsystem des Betriebssystems unterbrochen. Multitasking kann in präemptive und kooperative Typen charakterisiert werden. In präemptivem Multitasking schneidet das Betriebssystem die CPU-Zeit und widmet jedem der Programme einen Slot. Unix-ähnliche Betriebssysteme, wie Solaris und Linux – sowie nicht-Unix-ähnliche, wie AmigaOS – unterstützen präemptive Multitasking. Die kooperative Multitasking wird erreicht, indem man auf jedes Verfahren setzt, um den anderen Prozessen in definierter Weise Zeit zu geben. 16-Bit-Versionen von Microsoft Windows verwendet kooperative Multi-tasking; 32-Bit-Versionen von Windows NT und Win9x verwendet preemptive Multi-tasking. Single-und Multi-User Single-User-Betriebssysteme haben keine Möglichkeiten, Benutzer zu unterscheiden, aber können mehrere Programme in Tandem laufen lassen. Ein Multi-User-Betriebssystem erweitert das Grundkonzept der Multitasking mit Einrichtungen, die Prozesse und Ressourcen identifizieren, wie z.B. Speicherplatz, zu mehreren Benutzern gehören, und das System ermöglicht es mehreren Benutzern gleichzeitig mit dem System zu interagieren. Zeit teilende Betriebssysteme Zeitplan Aufgaben für eine effiziente Nutzung des Systems und kann auch Buchhaltung Software für die Kostenverteilung der Prozessorzeit, Massenspeicherung, Druck und andere Ressourcen für mehrere Benutzer umfassen. Verteilt Ein verteiltes Betriebssystem verwaltet eine Gruppe von verschiedenen, vernetzten Computern und macht sie zu einem einzigen Computer, da alle Berechnungen verteilt werden (geteilt unter den konstituierenden Computern). Vorlage Im verteilten und Cloud-Computing-Kontext eines Betriebssystems bezieht sich das Templating auf die Erstellung eines einzigen virtuellen Maschinenbildes als Gastbetriebssystem, das es dann als Werkzeug für mehrere laufende virtuelle Maschinen speichert. Die Technik wird sowohl im Virtualisierungs- als auch im Cloud Computing Management eingesetzt und ist in großen Serverlagern üblich. Embedded Embedded-Betriebssysteme sollen in Embedded-Computersystemen eingesetzt werden. Sie sind auf kleinen Maschinen mit weniger Autonomie (z.B. PDAs) ausgelegt. Sie sind sehr kompakt und extrem leistungsfähig und können mit einer begrenzten Menge an Ressourcen arbeiten. Windows CE und Minix 3 sind einige Beispiele für eingebettete Betriebssysteme. Echtzeit Ein Echtzeit-Betriebssystem ist ein Betriebssystem, das die Verarbeitung von Ereignissen oder Daten durch einen bestimmten Zeitpunkt garantiert. Ein Echtzeit-Betriebssystem kann ein- oder mehr-tasking sein, aber bei Multitasking verwendet es spezialisierte Planungsalgorithmen, so dass eine deterministische Verhaltensweise erreicht wird. Ein solches ereignisgesteuertes System schaltet zwischen Aufgaben auf Basis ihrer Prioritäten oder externer Ereignisse, während zeitgebende Betriebssysteme auf Basis von Taktunterbrechungen Aufgaben schalten. Bibliothek Ein Bibliotheks-Betriebssystem ist eine, in der die Dienste, die ein typisches Betriebssystem bietet, wie z.B. Vernetzung, in Form von Bibliotheken bereitgestellt und mit dem Applikations- und Konfigurationscode zur Erstellung eines Unikernels komponiert werden: ein spezialisierter, einzelner Adressraum, ein Maschinenbild, das in Cloud- oder Embedded-Umgebungen eingesetzt werden kann. Geschichte Frühe Computer wurden gebaut, um eine Reihe von Einzelaufgaben, wie ein Rechner durchzuführen. In den 1950er-Jahren wurden grundlegende Betriebssystemmerkmale entwickelt, wie z.B. gebietsansässige Monitorfunktionen, die nacheinander automatisch verschiedene Programme ausführen können, um die Verarbeitung zu beschleunigen. Bis Anfang der 1960er Jahre gab es in ihren modernen und komplexeren Formen keine Betriebssysteme. Hardware-Funktionen wurden hinzugefügt, die die Nutzung von Laufzeitbibliotheken, Unterbrechungen und parallele Verarbeitung ermöglichten. Als Personal Computer in den 1980er Jahren populär wurden, wurden Betriebssysteme für sie ähnlich in der Konzeption gemacht wie diejenigen, die auf größeren Computern verwendet. In den 1940er Jahren hatten die frühesten elektronischen digitalen Systeme keine Betriebssysteme. Elektronische Systeme dieser Zeit wurden in Reihen von mechanischen Schaltern oder durch Jumperdrähte an Plugboards programmiert. Dies waren spezielle Systeme, die beispielsweise Ballistiktabellen für das Militär generierten oder den Druck von Payroll-Checks aus Daten auf gestanzte Papierkarten kontrollierten. Nachdem programmierbare Universalrechner erfunden wurden, wurden Maschinensprachen (bestehend aus Strings der Binärziffern 0 und 1 auf gestanztem Papierband) eingeführt, die den Programmiervorgang aufspießen (Stern, 1981). In den frühen 1950er Jahren konnte ein Computer nur ein Programm zu einer Zeit ausführen. Jeder Benutzer hatte alleinige Verwendung des Computers für eine begrenzte Zeit und würde zu einer geplanten Zeit mit ihrem Programm und Daten auf gestanzte Papierkarten oder gestanztes Band ankommen. Das Programm würde in die Maschine geladen werden, und die Maschine würde auf die Arbeit gesetzt werden, bis das Programm abgeschlossen oder abgestürzt. Programme könnten in der Regel über eine Frontblende mit Winkelschaltern und Blendenleuchten debuggiert werden. Es wird gesagt, dass Alan Turing ein Meister davon auf der frühen Manchester Mark 1 Maschine war, und er leitete bereits die primitive Konzeption eines Betriebssystems aus den Prinzipien der Universal Turing Maschine. Spätere Maschinen kamen mit Bibliotheken von Programmen, die mit dem Programm eines Benutzers verbunden werden, um in Operationen wie Eingabe und Ausgabe und Kompilieren (Erzeugen von Maschinencode aus human lesbarem Symbolcode) zu helfen. Dies war die Genesis des modernen Betriebssystems. Allerdings liefen Maschinen immer noch einen einzigen Job zu einer Zeit. An der Cambridge University in England war die Job-Warteschlange zu einem Zeitpunkt eine Waschlinie (Clothesline), aus der Bänder mit verschiedenen farbigen Kleidungsbändern aufgehängt wurden, um Stellenpriorität anzuzeigen. Eine Verbesserung war der Atlas Supervisor. Mit dem Manchester Atlas 1962 eingeführt, wird es von vielen als das erste erkennbare moderne Betriebssystem angesehen. Brinch Hansen beschrieb es als "der bedeutendste Durchbruch in der Geschichte der Betriebssysteme". Hauptrahmen In den 1950er-Jahren wurden viele wichtige Funktionen im Bereich der Betriebssysteme auf Mainframe-Computern, einschließlich der Batch-Verarbeitung, Input/Output-Interrupting, Pufferung, Multitasking, Spooling, Laufzeitbibliotheken, Link-Ladung und Programme zur Sortierung von Datensätzen in Dateien Pioniere. Diese Funktionen wurden in der Anwendungssoftware nicht in einem separaten Betriebssystem, das von allen Anwendungen verwendet wird, enthalten oder nicht. 1959 wurde das SHARE-Betriebssystem als integriertes Dienstprogramm für den IBM 704 und später in den 709 und 7090 Mainframes veröffentlicht, obwohl es am 709, 7090 und 7094 schnell von IBSYS/IBJOB gesupplant wurde. In den 1960er Jahren stellte IBMs OS/360 das Konzept eines einzigen Betriebssystems vor, das eine gesamte Produktlinie umfasst, was für den Erfolg der System/360-Maschinen von entscheidender Bedeutung war. Die aktuellen Mainframe-Betriebssysteme von IBM sind entfernte Nachkommen dieses Originalsystems und moderne Maschinen sind rückwärtskompatibel mit Anwendungen, die für OS/360.OS/360 geschrieben wurden. Auch der Gedanke, dass das Betriebssystem alle verwendeten Systemressourcen verfolgt, einschließlich Programm- und Datenraumzuweisung im Hauptspeicher und Dateiraum im Sekundärspeicher und Dateiverriegelung bei Updates. Wenn ein Prozess aus irgendeinem Grund beendet wird, werden alle diese Ressourcen vom Betriebssystem wieder beansprucht. Das alternative CP-67-System für die S/360-67 startete eine ganze Reihe von IBM-Betriebssystemen, die sich auf das Konzept virtueller Maschinen konzentrierten. Andere Betriebssysteme, die auf den Hauptrahmen der IBM S/360 Serie verwendet werden, sind Systeme, die von IBM entwickelt wurden: DOS/360 (Disk Operating System,) TSS/360 (Time Sharing System,) TOS/360 (Tape Operating System,) BOS/360 (Basic Operating System,) und ACP (Airline Control Program), sowie einige Nicht-IBM-Systeme: MTS (Michigan Terminal System,) MUSIC (Multi-User System for Interactive Computing) und ORVYL (Stanford Timesharing System). Die Control Data Corporation hat das SCOPE Betriebssystem in den 1960er Jahren für die Batch-Verarbeitung entwickelt. In Zusammenarbeit mit der University of Minnesota wurden die Kronos und später die NOS-Betriebssysteme in den 1970er Jahren entwickelt, die den gleichzeitigen Batch- und Timesharing-Einsatz unterstützten. Wie viele kommerzielle Timesharing-Systeme, seine Schnittstelle war eine Erweiterung der Dartmouth BASIC Betriebssysteme, eine der Pioniere in Zeitenharing und Programmiersprachen. In den späten 1970er Jahren entwickelten Control Data und die University of Illinois das Betriebssystem PLATO, das Plasma-Panel-Displays und Fernzeit-Sharing-Netzwerke verwendet. Plato war bemerkenswert innovativ für seine Zeit, mit Echtzeit-Chat, und Multi-User-Grafik-Spiele. Im Jahr 1961 führte Burroughs Corporation das B5000 mit dem MCP (Master Control Program) Betriebssystem ein. Das B5000 war eine Stapelmaschine, die ausschließlich hochrangige Sprachen ohne Montage unterstützte; in der Tat war das MCP das erste OS, das ausschließlich in einer hochrangigen Sprache geschrieben wurde (ESPOL, ein Dialekt von ALGOL). MCP führte auch viele andere bahnbrechende Innovationen ein, wie die erste kommerzielle Implementierung von virtuellem Speicher. Bei der Entwicklung des AS/400 machte IBM einen Ansatz für Burroughs, um MCP auf der AS/400 Hardware zu lizenzieren. Dieser Vorschlag wurde durch Burroughs-Management zum Schutz seiner bestehenden Hardwareproduktion abgelehnt. MCP ist heute noch in der MCP/ClearPath-Reihe der Unisys-Firmen im Einsatz. UNIVAC, der erste kommerzielle Computerhersteller, produzierte eine Reihe von EXEC-Betriebssystemen. Wie alle frühen Main-Frame-Systeme verwaltete dieses Batch-orientierte System magnetische Trommeln, Festplatten, Kartenleser und Zeilendrucker. In den 1970er-Jahren produzierte UNIVAC das Real-Time Basic (RTB)-System, um den großen Zeitanteil zu unterstützen, auch nach dem Dartmouth BC-System strukturiert. General Electric und MIT entwickelten General Electric Comprehensive Operating Supervisor (GECOS), der das Konzept der Ringed Security Privileg Levels einführte. Nach Erwerb durch Honeywell wurde es General Comprehensive Operating System (GCOS) umbenannt. Digital Equipment Corporation entwickelte viele Betriebssysteme für seine verschiedenen Computerlinien, darunter TOPS-10 und TOPS-20 Zeitaustauschsysteme für die 36-Bit PDP-10 Klassensysteme. Vor der weit verbreiteten Nutzung von UNIX war TOPS-10 ein besonders beliebtes System in Universitäten und in der frühen ARPANET-Gemeinschaft. RT-11 war ein Single-User Echtzeit-Betriebssystem für den Minicomputer der PDP-11-Klasse, und RSX-11 war das entsprechende Multi-User-Betriebssystem. Von den späten 1960er-Jahren bis Ende der 1970er-Jahre entwickelten sich mehrere Hardware-Fähigkeiten, die eine ähnliche oder portierte Software auf mehr als einem System laufen ließen. Frühe Systeme hatten die Mikroprogrammierung genutzt, um Funktionen auf ihren Systemen zu implementieren, um verschiedene zugrunde liegende Computerarchitekturen zu ermöglichen, wie andere in einer Serie zu sein. Tatsächlich waren die meisten 360s nach der 360/40 (mit Ausnahme der 360/44, 360/75, 360/91, 360/95 und 360/195) mikroprogrammierte Implementierungen. Die enorme Investition in Software für diese Systeme seit den 1960er Jahren verursachte die meisten der ursprünglichen Computerhersteller weiterhin kompatible Betriebssysteme zusammen mit der Hardware zu entwickeln. Notable unterstützte Mainframe-Betriebssysteme umfassen: Burroughs MCP – B5000, 1961 an Unisys Clearpath/MCP, präsentieren IBM OS/360 – IBM System/360, 1966 an IBM z/OS, präsentieren IBM CP-67 – IBM System/360, 1967 an IBM z/VM UNIVAC EXEC 8 – UNIVAC 1108, 1967, an OS 2200 Unisys Clearpath Dorado, präsentieren Mikrocomputer Die ersten Mikrocomputer hatten keine Kapazität oder Notwendigkeit für die aufwändigen Betriebssysteme, die für Mainframes und Minis entwickelt wurden; minimalistische Betriebssysteme wurden entwickelt, oft von ROM geladen und als Monitore bekannt. Ein bemerkenswertes Early-Disk-Betriebssystem war CP/M, das auf vielen frühen Mikrocomputern unterstützt wurde und eng mit Microsofts MS-DOS imitiert wurde, die als Betriebssystem für den IBM-PC (IBM-Version davon wurde IBM DOS oder PC DOS genannt). In den 1980er Jahren verließ Apple Computer Inc. (jetzt Apple Inc.) seine beliebte Apple II-Serie von Mikrocomputern, um den Apple Macintosh Computer mit einer innovativen grafischen Benutzeroberfläche (GUI) auf das Mac OS einzuführen. Die Einführung des Intel 80386 CPU-Chips im Oktober 1985, mit 32-Bit-Architektur und Paging-Funktionen, bot Personal Computern die Möglichkeit, Multitasking-Betriebssysteme wie die von früheren Minicomputern und Mainframes auszuführen. Microsoft reagierte auf diesen Fortschritt durch die Einstellung Dave Cutler, der das VMS-Betriebssystem für Digital Equipment Corporation entwickelt hatte. Er würde die Entwicklung des Windows NT-Betriebssystems führen, das weiterhin als Grundlage für Microsofts Betriebssystemlinie dient. Steve Jobs, Mitbegründer von Apple Inc,. startete NeXT Computer Inc., die das NEXTSTEP Betriebssystem entwickelte. NEXTSTEP würde später von der Apple Inc. erworben und zusammen mit dem Code von FreeBSD als Kern von Mac OS X (macOS nach der letzten Namensänderung) verwendet werden. Das GNU-Projekt wurde von Aktivist und Programmierer Richard Stallman mit dem Ziel gestartet, einen kompletten kostenlosen Softwareersatz zum proprietären UNIX-Betriebssystem zu schaffen. Während das Projekt bei der Duplizierung der Funktionalität verschiedener Teile von UNIX sehr erfolgreich war, erwies sich die Entwicklung des GNU Hurd-Kernels als unproduktiv. 1991 veröffentlichte der finnische Informatikstudent Linus Torvalds mit Kooperation von Freiwilligen, die über das Internet zusammenarbeiten, die erste Version des Linux-Kernels. Es wurde bald mit den GNU-Benutzerraumkomponenten und Systemsoftware zu einem kompletten Betriebssystem zusammengeführt. Seitdem wurde die Kombination der beiden Hauptkomponenten in der Regel als einfach Linux von der Software-Branche bezeichnet, eine Namenskonvention, die Stallman und die Freie Software-Stiftung bleiben entgegen, bevorzugt den Namen GNU/Linux. Die Berkeley Software Distribution, bekannt als BSD, ist das UNIX-Derivat, das von der University of California, Berkeley, ab den 1970er Jahren verteilt wird. Frei verteilt und auf viele Minicomputer portiert, gewann es schließlich auch eine Folge für den Einsatz auf PCs, vor allem als FreeBSD, NetBSD und OpenBSD. Beispiele Unix und Unix-ähnliche Betriebssysteme Unix wurde ursprünglich in Montagesprache geschrieben. Ken Thompson schrieb B, hauptsächlich auf BCPL, basierend auf seiner Erfahrung im MULTICS-Projekt. B wurde durch C ersetzt und Unix, in C neu geschrieben, entwickelt zu einer großen, komplexen Familie von miteinander verbundenen Betriebssystemen, die in jedem modernen Betriebssystem einflussreich sind (siehe Geschichte). Die Unix-ähnliche Familie ist eine vielfältige Gruppe von Betriebssystemen, mit mehreren großen Unterkategorien wie System V, BSD und Linux. Der Name UNIX ist eine Marke von The Open Group, die es für die Verwendung mit jedem Betriebssystem lizenziert, das gezeigt wurde, um ihren Definitionen entsprechen. " UNIX-like wird häufig verwendet, um auf die große Reihe von Betriebssystemen zu verweisen, die der ursprünglichen UNIX ähneln. Unix-ähnliche Systeme laufen auf einer Vielzahl von Computerarchitekturen. Sie werden stark für Server in der Wirtschaft sowie Arbeitsplätze in akademischen und technischen Umgebungen verwendet. Kostenlose UNIX-Varianten, wie Linux und BSD, sind in diesen Bereichen beliebt. Vier Betriebssysteme werden von der Open Group (Anbieter der Unix-Marke) als Unix zertifiziert. HPs HP-UX und IBMs AIX sind beide Nachkommen des Original-Systems V Unix und sind nur auf der Hardware des jeweiligen Anbieters ausgelegt. Im Gegensatz dazu kann Sun Microsystems's Solaris auf mehreren Arten von Hardware, einschließlich x86 und Sparc Servern, und PCs laufen. Apples macOS, ein Ersatz für Apples früheres (nicht-Unix) Mac OS, ist eine hybride kernelbasierte BSD-Variante, die von NeXTSTEP, Mach und FreeBSD abgeleitet wird. Die Unix-Interoperabilität wurde durch die Festlegung des POSIX-Standards angestrebt. Der POSIX-Standard kann auf jedes Betriebssystem angewendet werden, obwohl er ursprünglich für verschiedene Unix-Varianten erstellt wurde. BSD und seine Nachkommen Eine Untergruppe der Unix Familie ist die Berkeley Software Distribution Familie, die FreeBSD, NetBSD und OpenBSD umfasst. Diese Betriebssysteme werden am häufigsten auf Webservern gefunden, obwohl sie auch als PC-Betriebssystem funktionieren können. Das Internet verdankt viel von seiner Existenz an BSD, da viele der Protokolle, die heute von Computern verwendet werden, um Daten über ein Netzwerk zu verbinden, zu senden und zu empfangen, in BSD weit verbreitet und verfeinert wurden. Das World Wide Web wurde auch erstmals auf einer Reihe von Computern gezeigt, die ein Betriebssystem auf Basis von BSD namens NeXTSTEP betreiben. 1974, University of California, Berkeley installierte sein erstes Unix-System. Im Laufe der Zeit begannen Studenten und Mitarbeiter in der Informatik-Abteilung, neue Programme hinzuzufügen, um die Dinge einfacher zu machen, wie Text-Editoren. Als Berkeley 1978 mit Unix neue VAX-Computer erhielt, modifizierten die Absolventen der Schule Unix noch mehr, um die Hardwaremöglichkeiten des Computers zu nutzen. Die Defense Advanced Research Projects Agency des US-Verteidigungsministeriums nahm Interesse und beschloss, das Projekt zu finanzieren. Viele Schulen, Unternehmen und Regierungsorganisationen nahmen Kenntnis und begannen, Berkeleys Version von Unix anstelle der offiziellen, von AT&T vertrieben zu verwenden. Steve Jobs, nachdem Apple Inc. 1985 verlassen hatte, gründete NeXT Inc. ein Unternehmen, das High-End-Computer auf einer Variation von BSD namens NeXTSTEP produzierte. Einer dieser Computer wurde von Tim Berners-Lee als erster Webserver verwendet, um das World Wide Web zu erstellen. Entwickler wie Keith Bostic ermutigten das Projekt, jeden nicht-freien Code zu ersetzen, der mit Bell Labs entstand. Sobald dies getan wurde, verklagte AT&T jedoch. Nach zwei Jahren Rechtsstreitigkeiten hat das BSD-Projekt eine Reihe von kostenlosen Derivaten wie NetBSD und FreeBSD (beide 1993) und OpenBSD (von NetBSD im Jahr 1995.) macOS macOS (früher "Mac OS X" und später "OS X") eine Reihe von offenen Kern-Grafik-Betriebssystemen entwickelt, vermarktet und verkauft von Apple Inc. das neueste davon wird auf allen derzeit verschiffen Macintosh Computern vorgeladen.macOS ist der Nachfolger des originalen klassischen Mac OS, das seit 1984 das primäre Betriebssystem von Apple war. Im Gegensatz zu seinem Vorgänger ist macOS ein UNIX-Betriebssystem, das auf Technologie aufgebaut wurde, die in NeXT durch die zweite Hälfte der 1980er Jahre entwickelt wurde und bis Apple das Unternehmen Anfang 1997 gekauft hatte. Das Betriebssystem wurde erstmals 1999 als Mac OS X Server 1.0 veröffentlicht, gefolgt im März 2001 von einer Clientversion (Mac OS X v10.0 Cheetah"). Seitdem wurden sechs deutlichere Client- und Server-Editionen von macOS veröffentlicht, bis die beiden in OS X 10.7 Lion zusammengefasst wurden". Vor seiner Verschmelzung mit macOS war die Server-Edition – macOS Server – architektonisch identisch mit seinem Desktop-Gegenstand und lief in der Regel auf Apples Linie von Macintosh Server Hardware.macOS Server umfasste Arbeitsgruppenverwaltungs- und Verwaltungssoftware-Tools, die einen vereinfachten Zugriff auf Schlüsselnetzwerkdienste bieten, einschließlich eines Mail-Transfer-Agenten, eines Samba-Servers, eines LDAP-Servers, eines Domain-Name-Servers und anderer. Mit Mac OS X v10.7 Lion wurden alle Server-Aspekte von Mac OS X Server in die Client-Version integriert und das Produkt als "OS X" wiedermarkiert (Dropper Mac aus dem Namen). Die Server-Tools werden nun als Anwendung angeboten. Linux Der Linux-Kernel entstand 1991 als Projekt von Linus Torvalds, während ein Universitätsstudent in Finnland. Er veröffentlichte Informationen über sein Projekt in einer Nachrichtengruppe für Computerstudenten und Programmierer, und erhielt Unterstützung und Unterstützung von Freiwilligen, die es geschafft, einen kompletten und funktionalen Kernel zu schaffen. Linux ist Unix-like, wurde aber ohne Unix-Code entwickelt, im Gegensatz zu BSD und seinen Varianten. Aufgrund seines offenen Lizenzmodells ist der Linux-Kernel-Code für die Studie und Modifikation verfügbar, was zu seiner Verwendung auf einer breiten Palette von Computern von Supercomputern zu Smart-watches führte. Obwohl Schätzungen nahelegen, dass Linux auf nur 1,82% aller Desktop- (oder Laptop)-PCs verwendet wird, wurde es für den Einsatz in Servern und eingebetteten Systemen wie Handys weit verbreitet. Linux hat Unix auf vielen Plattformen übertroffen und wird auf den meisten Supercomputern einschließlich der Top 385 verwendet. Viele der gleichen Computer sind auch auf Green500 (aber in unterschiedlicher Reihenfolge) und Linux läuft auf der Oberseite 10. Linux wird auch häufig auf anderen kleinen energieeffizienten Computern wie Smartphones und Smartwatches verwendet. Der Linux-Kernel wird in einigen beliebten Distributionen verwendet, wie Red Hat, Debian, Ubuntu, Linux Mint und Googles Android, Chrome OS und Chromium OS. Microsoft Windows Windows ist eine Familie von proprietären Betriebssystemen, die von Microsoft Corporation entwickelt und vor allem auf Intel Architektur basierte Computer, mit einem geschätzten 88,9 Prozent Gesamtnutzungsanteil auf Web angeschlossenen Computern. Die neueste Version ist Windows 10.In 2011, Windows 7 überholt Windows XP als die häufigste Version im Einsatz. Microsoft Windows wurde erstmals im Jahr 1985 veröffentlicht, als Betriebssystem auf MS-DOS läuft, das war das Standard-Betriebssystem, das auf den meisten Intel Architektur-Personalcomputern zur Zeit ausgeliefert wurde. 1995 wurde Windows 95 veröffentlicht, das nur MS-DOS als Bootstrap verwendet. Für die Rückwärtskompatibilität konnte Win9x Real-Mode MS-DOS und 16-Bit Windows 3.x Treiber ausführen. Windows ME, veröffentlicht im Jahr 2000, war die letzte Version in der Win9x Familie. Spätere Versionen wurden alle auf dem Windows NT-Kernel basiert. Aktuelle Clientversionen von Windows laufen auf IA-32, x86-64 und 32-Bit ARM Mikroprozessoren. Darüber hinaus wird Itanium noch in der älteren Serverversion Windows Server 2008 R2 unterstützt. In der Vergangenheit unterstützte Windows NT zusätzliche Architekturen. Server-Editionen von Windows sind weit verbreitet. In den letzten Jahren hat Microsoft erhebliches Kapital in der Bemühung, die Nutzung von Windows als Server-Betriebssystem zu fördern. Die Windows-Nutzung auf Servern ist jedoch nicht so weit verbreitet wie auf Personal Computern, da Windows gegen Linux und BSD für Server-Marktanteil konkurrieren. ReactOS ist ein Windows-alternatives Betriebssystem, das auf den Prinzipien von Windows entwickelt wird – ohne Microsofts Code zu verwenden. Sonstige Es gab viele Betriebssysteme, die an ihrem Tag signifikant waren, aber nicht mehr so sind, wie AmigaOS; OS/2 von IBM und Microsoft; klassische Mac OS, die nicht-Unix-Vorstufe zu Apples macOS; BeOS; XTS-300; RISC OS; MorphOS; Haiku; BareMetal und FreeMint. Einige werden noch in Nischenmärkten eingesetzt und werden weiterhin als Minderheitsplattformen für Enthusiasten und Fachanwendungen entwickelt. OpenVMS, früher aus der DEC, ist noch in der aktiven Entwicklung von VMS Software Inc. Dennoch werden andere Betriebssysteme fast ausschließlich in der Wissenschaft, in der betrieblichen Systemausbildung oder in der Forschung über Betriebssystemkonzepte eingesetzt. Ein typisches Beispiel für ein System, das beide Rollen erfüllt, ist MINIX, während zum Beispiel Singularität rein für die Forschung verwendet wird. Ein weiteres Beispiel ist das Oberon System, das an der ETH Zürich von Niklaus Wirth, Jürg Gutknecht und einer Gruppe von Studenten am ehemaligen Computer Systems Institute in den 1980er Jahren entwickelt wurde. Es wurde hauptsächlich für Forschung, Lehre und tägliche Arbeit in Wirths Gruppe verwendet. Andere Betriebssysteme haben keinen signifikanten Marktanteil gewonnen, haben aber Innovationen eingeführt, die Mainstream-Betriebssysteme beeinflusst haben, nicht zuletzt den Plan von Bell Labs 9. Komponenten Die Komponenten eines Betriebssystems existieren alle, um die verschiedenen Teile eines Computers zusammenzuarbeiten. Alle Benutzersoftware muss durch das Betriebssystem gehen, um eine der Hardware zu verwenden, sei es so einfach wie eine Maus oder Tastatur oder als komplexe Internet-Komponente. Kern Mit Hilfe der Firmware- und Gerätetreiber bietet der Kernel die grundlegendste Kontrolle über alle Hardware-Geräte des Computers. Es verwaltet Speicherzugriff für Programme im RAM, es bestimmt, welche Programme Zugriff auf welche Hardware-Ressourcen erhalten, es richtet oder setzt die CPU-Betriebszustände für einen optimalen Betrieb zu jeder Zeit ein, und es organisiert die Daten für einen langfristigen nichtflüchtigen Speicher mit Dateisystemen auf wie Festplatten, Bändern, Flash-Speicher, etc. Programmausführung Das Betriebssystem bietet eine Schnittstelle zwischen einem Anwendungsprogramm und der Computerhardware, so dass ein Anwendungsprogramm mit der Hardware nur durch Einhaltung von in das Betriebssystem programmierten Regeln und Verfahren interagieren kann. Das Betriebssystem ist auch eine Reihe von Dienstleistungen, die die Entwicklung und Durchführung von Anwendungsprogrammen vereinfachen. Die Ausführung eines Anwendungsprogramms beinhaltet die Erstellung eines Prozesses durch den Betriebssystemkernel, der Speicherraum und andere Ressourcen zuordnet, eine Priorität für den Prozess in Multitasking-Systemen festlegt, Programm binäre Code in den Speicher lädt und die Ausführung des Anwendungsprogramms initiiert, das dann mit dem Benutzer und mit Hardware-Geräten interagiert. Interrupts Interrupts sind zentral für Betriebssysteme, da sie eine effiziente Möglichkeit für das Betriebssystem bieten, mit seiner Umgebung zu interagieren und zu reagieren. Die Alternative – mit dem Betriebssystem die verschiedenen Eingabequellen für Ereignisse (Polling), die Aktion erfordern – ist in älteren Systemen mit sehr kleinen Stacks (50 oder 60 Bytes) zu finden, ist aber in modernen Systemen mit großen Stacks ungewöhnlich. Interrupt-basierte Programmierung wird direkt von den meisten modernen CPUs unterstützt. Interrupts bieten einen Computer mit einer Möglichkeit, lokale Registerkontexte automatisch zu speichern und bestimmte Code in Reaktion auf Ereignisse auszuführen. Selbst sehr grundlegende Computer unterstützen Hardwareunterbrechungen und ermöglichen es dem Programmierer, Code anzugeben, der ausgeführt werden kann, wenn dieses Ereignis stattfindet. Wenn ein Interrupt empfangen wird, schaltet die Hardware des Computers automatisch das laufende Programm aus, speichert seinen Status und führt den Computercode aus, der zuvor mit dem Interrupt verbunden ist; dies ist analog, ein Lesezeichen in einem Buch in Reaktion auf einen Telefonanruf zu platzieren. In modernen Betriebssystemen werden Interrupts vom Kernel des Betriebssystems bearbeitet. Unterbrechungen können entweder von der Hardware des Computers oder dem laufenden Programm kommen. Wenn ein Hardware-Gerät einen Interrupt auslöst, entscheidet der Kernel des Betriebssystems, wie man mit diesem Ereignis umgeht, in der Regel durch Ausführen eines Verarbeitungscodes. Die Anzahl der auszuführenden Codes hängt von der Priorität des Interrupts ab (z.B.: eine Person reagiert in der Regel auf einen Rauchmelderalarm, bevor sie das Telefon beantwortet). Die Verarbeitung von Hardware-Interrupts ist eine Aufgabe, die in der Regel an Software delegiert wird, genannt ein Gerätetreiber, der Teil des Kernels des Betriebssystems sein kann, Teil eines anderen Programms oder beides. Gerätetreiber können dann auf verschiedene Weise Informationen an ein laufendes Programm weiterleiten. Ein Programm kann auch eine Unterbrechung des Betriebssystems auslösen. Wenn ein Programm beispielsweise auf Hardware zugreifen will, kann es den Kernel des Betriebssystems unterbrechen, wodurch die Steuerung wieder an den Kernel übergeben wird. Der Kernel verarbeitet dann die Anfrage. Wenn ein Programm zusätzliche Ressourcen (oder Ressourcen vergossen) wie Speicher wünscht, löst es einen Interrupt aus, um die Aufmerksamkeit des Kernels zu erhalten. Moden Moderne Computer unterstützen mehrere Betriebsarten. CPUs mit dieser Fähigkeit bieten mindestens zwei Modi: Benutzermodus und Supervisor-Modus. Im Allgemeinen erlaubt der Supervisor-Modus-Betrieb uneingeschränkten Zugriff auf alle Maschinenressourcen, einschließlich aller MPU-Anweisungen. Der Benutzermodus-Betrieb setzt Grenzen bei der Gebrauchsanweisung und deaktiviert typischerweise den direkten Zugriff auf Maschinenressourcen. CPUs können auch andere Modi haben, die dem Benutzermodus ähnlich sind, wie z.B. die virtuellen Modi, um ältere Prozessortypen, wie 16-Bit-Prozessoren auf einem 32-Bit-Ein- oder 32-Bit-Prozessor auf einem 64-Bit-Eins zu emulieren. Beim Einschalten oder Zurücksetzen beginnt das System im Supervisor-Modus. Nachdem ein Betriebssystemkernel geladen und gestartet wurde, kann die Grenze zwischen Benutzermodus und Supervisor-Modus (auch als Kernel-Modus bekannt) festgelegt werden. Der Supervisor-Modus wird von dem Kernel für Low-Level-Aufgaben verwendet, die einen uneingeschränkten Zugriff auf Hardware benötigen, wie zum Beispiel die Steuerung des Zugriffs auf Speicher und die Kommunikation mit Geräten wie Festplattenlaufwerken und Videodisplay-Geräten. Der Benutzermodus dagegen wird für fast alles andere verwendet. Applikationsprogramme, wie Wortprozessoren und Datenbankmanager, arbeiten innerhalb des Benutzermodus und können nur auf Maschinenressourcen zugreifen, indem Sie die Steuerung auf den Kernel umschalten, ein Prozess, der einen Schalter in den Supervisor-Modus verursacht. Typischerweise wird die Übertragung der Steuerung auf den Kernel durch Ausführen einer Software-Interrupt-Anweisung, wie der Motorola 68000 TRAP-Anweisung, erreicht. Der Software-Interrupt bewirkt, dass der Prozessor vom Benutzermodus in den Supervisor-Modus umschaltet und mit der Ausführung des Codes beginnt, der es dem Kernel erlaubt, die Steuerung zu übernehmen. Im Benutzermodus haben Programme in der Regel Zugriff auf einen eingeschränkten Satz von Prozessoranweisungen und können in der Regel keine Anweisungen ausführen, die zu Störungen im Betrieb des Systems führen könnten. Im Supervisor-Modus werden typischerweise Befehlsausführungsbeschränkungen entfernt, wodurch der Kernel uneingeschränkten Zugriff auf alle Maschinenressourcen ermöglicht. Der Begriff "Benutzermodus-Ressource" bezieht sich in der Regel auf ein oder mehrere CPU-Register, die Informationen enthalten, dass das laufende Programm nicht geändert werden darf. Versuche, diese Ressourcen zu ändern, verursachen in der Regel einen Schalter in den Supervisor-Modus, wo das Betriebssystem mit der illegalen Operation umgehen kann, versuchte das Programm z.B. durch zwangsweise beenden (killing) das Programm. Unter anderem muss ein Multiprogrammierungs-Betriebssystem-Kernel für die Verwaltung aller Systemspeicher verantwortlich sein, die derzeit durch Programme genutzt werden. Dadurch wird sichergestellt, dass ein Programm den Speicher nicht bereits durch ein anderes Programm beeinträchtigt. Da die Programme Zeit teilen, muss jedes Programm einen unabhängigen Zugriff auf den Speicher haben. Die kooperative Speicherverwaltung, die von vielen frühen Betriebssystemen verwendet wird, geht davon aus, dass alle Programme den Speichermanager des Kernels freiwillig nutzen und ihren zugewiesenen Speicher nicht überschreiten. Dieses System der Speicherverwaltung wird fast nie mehr gesehen, da Programme oft Bugs enthalten, die dazu führen können, dass sie ihren zugewiesenen Speicher überschreiten. Wenn ein Programm ausfällt, kann es dazu führen, dass Speicher von einem oder mehreren anderen Programmen betroffen oder überschrieben werden. Malicious Programme oder Viren können gezielt den Speicher eines anderen Programms ändern, oder kann den Betrieb des Betriebssystems selbst beeinflussen. Mit kooperativem Speichermanagement braucht es nur ein falsches Programm, um das System abzustürzen. Speicherschutz ermöglicht es dem Kernel, den Zugriff eines Prozesses auf den Speicher des Computers zu begrenzen. Es gibt verschiedene Verfahren zum Speicherschutz, einschließlich Speichersegmentierung und Paging. Alle Methoden erfordern eine gewisse Hardware-Unterstützung (wie die 80286 MMU), die in allen Computern nicht existiert. In beiden Segmentierung und Paging geben bestimmte geschützte Modus-Register an die CPU an, welche Speicheradresse es einem laufenden Programm zuzugreifen erlaubt. Versuche, auf andere Adressen zuzugreifen, lösen einen Interrupt aus, der die CPU dazu veranlasst, den Supervisor-Modus erneut einzuschalten und den Kernel in die Verantwortung zu stellen. Dies wird kurz als Segmentierungsverletzung oder Seg-V bezeichnet, und da es sowohl schwierig ist, einem solchen Vorgang ein aussagekräftiges Ergebnis zuzuordnen, und weil es in der Regel ein Zeichen eines Fehlverhaltensprogramms ist, greift der Kernel in der Regel auf, das Abbrechensprogramm zu beenden und den Fehler zu melden. Windows-Versionen 3.1 durch ME hatte ein gewisses Maß an Speicherschutz, aber Programme könnten leicht die Notwendigkeit zu umgehen, es zu verwenden. Es wäre ein allgemeiner Schutzfehler entstanden, der eine Segmentierungsverletzung anzeigte; das System würde jedoch ohnehin oft abstürzen. Virtueller Speicher Die Verwendung von virtuellen Speicheradressen (z.B. Paging oder Segmentierung) bedeutet, dass der Kernel auswählen kann, welche Speicher jedes Programm jederzeit verwenden kann, sodass das Betriebssystem die gleichen Speicherorte für mehrere Aufgaben verwenden kann. Wenn ein Programm versucht, auf den Speicher zuzugreifen, der nicht in seinem aktuellen Bereich des zugänglichen Speichers liegt, aber dennoch ihm zugeordnet wurde, wird der Kernel in der gleichen Weise unterbrochen, wie es wäre, wenn das Programm seinen zugeordneten Speicher überschreiten würde. (siehe Abschnitt zur Speicherverwaltung.) Unter UNIX wird diese Art von Interrupt als Seitenfehler bezeichnet. Wenn der Kernel einen Seitenfehler erkennt, stellt er in der Regel den virtuellen Speicherbereich des Programms ein, der es auslöst, so dass er Zugriff auf den gewünschten Speicher erhält. Dies gibt dem Kernel die Ermessenskraft, über die das Speichern einer bestimmten Anwendung gespeichert ist, oder auch, ob es noch tatsächlich zugewiesen wurde. In modernen Betriebssystemen kann ein weniger häufig aufgerufener Speicher auf Festplatte oder anderen Medien zwischengespeichert werden, um diesen Raum für die Nutzung durch andere Programme zur Verfügung zu stellen. Das nennt man Swapping, da ein Speicherbereich von mehreren Programmen verwendet werden kann, und was dieser Speicherbereich auf Anfrage vertauscht oder ausgetauscht werden kann."Virtual Memory" bietet dem Programmierer oder dem Benutzer die Wahrnehmung, dass es eine viel größere Menge an RAM im Computer gibt als es wirklich. Multitasking Multitasking bezieht sich auf den Betrieb von mehreren unabhängigen Computerprogrammen auf demselben Computer; geben Sie das Aussehen, dass es die Aufgaben gleichzeitig erfüllt. Da die meisten Computer zu einem Zeitpunkt höchstens ein oder zwei Dinge ausführen können, erfolgt dies im Allgemeinen über die Zeitverteilung, was bedeutet, dass jedes Programm einen Teil der Zeit des Computers zur Ausführung verwendet. Ein Betriebssystem-Kernel enthält ein Schieduling-Programm, das bestimmt, wie viel Zeit jeder Prozess ausgibt, und in welchem Reihenfolge Ausführungskontrolle an Programme übergeben werden sollte. Die Steuerung wird durch den Kernel an einen Prozess übergeben, der den Programmzugriff auf die CPU und den Speicher ermöglicht. Später wird die Steuerung über einen Mechanismus in den Kernel zurückgegeben, so dass ein anderes Programm die CPU verwenden darf. Diese sogenannte Weitergabe der Steuerung zwischen Kernel und Applikationen wird als Kontextschalter bezeichnet. Ein frühes Modell, das die Zuordnung von Zeit zu Programmen regelte, wurde als kooperatives Multitasking bezeichnet. In diesem Modell, wenn die Steuerung an ein Programm durch den Kernel übergeben wird, kann sie solange ausführen, wie es will, bevor sie explizit die Kontrolle an den Kernel zurückgibt. Dies bedeutet, dass ein schädliches oder fehlerhaftes Programm nicht nur verhindern kann, dass andere Programme die CPU verwenden, sondern es kann das gesamte System hängen, wenn es eine unendliche Schleife eingibt. Moderne Betriebssysteme erweitern die Anwendungsvorgaben auf Gerätetreiber und Kernelcode, so dass das Betriebssystem auch über interne Laufzeiten eine präemptive Kontrolle hat. Die Philosophie für präemptive Multitasking ist, dass alle Programme regelmäßig auf der CPU gegeben werden. Dies bedeutet, dass alle Programme in der Zeit begrenzt werden müssen, die sie auf der CPU verbringen dürfen, ohne unterbrochen zu werden. Um dies zu erreichen, nutzen moderne Betriebssystemkerne einen zeitgesteuerten Interrupt. Ein geschützter Mode-Timer wird vom Kernel gesetzt, der nach Ablauf der angegebenen Zeit eine Rückkehr in den Supervisor-Modus auslöst. (Siehe oben Abschnitte über Unterbrechungen und Dual-Mode-Betrieb.) Auf vielen einzelnen Benutzer-Betriebssystemen ist kooperative Multitasking perfekt ausreichend, da Heimcomputer in der Regel eine kleine Anzahl von gut getesteten Programmen laufen. Der AmigaOS ist eine Ausnahme, mit präemptivem Multitasking aus seiner ersten Version. Windows NT war die erste Version von Microsoft Windows, die preemptive Multitasking durchgesetzt, aber es erreichte nicht den Home-User-Markt bis Windows XP (da Windows NT auf Profis ausgerichtet wurde). Festplattenzugriff und Dateisysteme Der Zugriff auf auf auf Festplatten gespeicherte Daten ist ein zentrales Merkmal aller Betriebssysteme. Computer speichern Daten auf Festplatten mit Dateien, die auf bestimmte Weise strukturiert sind, um schnelleren Zugriff, höhere Zuverlässigkeit zu ermöglichen und den verfügbaren Speicherplatz des Laufwerks besser zu nutzen. Die spezifische Art und Weise, wie Dateien auf einer Festplatte gespeichert werden, wird als Dateisystem bezeichnet und ermöglicht Dateien Namen und Attribute zu haben. Sie können auch in einer Hierarchie von Verzeichnissen oder Ordnern, die in einem Verzeichnisbaum angeordnet sind, gespeichert werden. Frühe Betriebssysteme unterstützten in der Regel eine einzelne Art von Laufwerk und nur eine Art von Dateisystem. Frühe Dateisysteme waren in ihrer Kapazität, Geschwindigkeit und in den Arten von Dateinamen und Verzeichnisstrukturen beschränkt, die sie verwenden konnten. Diese Einschränkungen reflektierten oft Einschränkungen in den von ihnen entwickelten Betriebssystemen, wodurch es für ein Betriebssystem sehr schwierig ist, mehr als ein Dateisystem zu unterstützen. Während viele einfachere Betriebssysteme eine begrenzte Auswahl an Optionen für den Zugriff auf Speichersysteme unterstützen, unterstützen Betriebssysteme wie UNIX und Linux eine als virtuelles Dateisystem oder VFS bekannte Technologie. Ein Betriebssystem wie UNIX unterstützt eine Vielzahl von Speichergeräten, unabhängig von deren Design- oder Dateisystemen, sodass sie über eine gemeinsame Anwendungs-Programmierschnittstelle (API) aufgerufen werden können. Dies macht es unnötig, dass Programme irgendwelche Kenntnisse über das Gerät haben, auf das sie zugreifen. Ein VFS ermöglicht es dem Betriebssystem, über die Verwendung bestimmter Gerätetreiber und Dateisystemtreiber Programme mit Zugriff auf eine unbegrenzte Anzahl von Geräten mit einer unendlichen Vielfalt an auf ihnen installierten Dateisystemen zu erhalten. Ein angeschlossenes Speichergerät, wie eine Festplatte, wird über einen Gerätetreiber zugegriffen. Der Gerätetreiber versteht die spezifische Sprache des Laufwerks und kann diese Sprache in eine vom Betriebssystem verwendete Standardsprache übersetzen, um auf alle Laufwerke zuzugreifen. Auf UNIX ist dies die Sprache der Blockgeräte. Wenn der Kernel einen entsprechenden Gerätetreiber hat, kann er dann auf den Inhalt des Laufwerks im Rohformat zugreifen, der ein oder mehrere Dateisysteme enthalten kann. Ein Dateisystemtreiber wird verwendet, um die Befehle zu übersetzen, die für den Zugriff auf jedes bestimmte Dateisystem verwendet werden, in einen Standardsatz von Befehlen, die das Betriebssystem verwenden kann, um mit allen Dateisystemen zu sprechen. Programme können sich dann auf der Grundlage von Dateinamen und Verzeichnissen/Ordner, die innerhalb einer hierarchischen Struktur enthalten sind, mit diesen Dateisystemen auseinandersetzen. Sie können Dateien erstellen, löschen, öffnen und schließen sowie verschiedene Informationen über sie sammeln, einschließlich Zugriffsberechtigungen, Größe, Freiraum und Erstellung und Änderungsdaten. Verschiedene Unterschiede zwischen Dateisystemen machen die Unterstützung aller Dateisysteme schwierig.Erlaubte Zeichen in Dateinamen, Fallempfindlichkeit und das Vorhandensein von verschiedenen Arten von Dateiattributen macht die Implementierung einer einzigen Schnittstelle für jedes Dateisystem eine daunting Aufgabe. Betriebssysteme neigen dazu, speziell für sie konzipierte Dateisysteme (und damit auch native) zu verwenden; zum Beispiel NTFS in Windows und ext3 und ReiserFS in Linux. In der Praxis sind Drittanbieter-Treiber in der Regel verfügbar, um Unterstützung für die am weitesten verbreiteten Dateisysteme in den meisten allgemeinen Betriebssystemen zu geben (z.B. NTFS ist in Linux über NTFS-3g verfügbar, und ext2/3 und ReiserFS sind in Windows über Drittanbieter-Software verfügbar). Die Unterstützung von Dateisystemen ist bei modernen Betriebssystemen sehr unterschiedlich, obwohl es mehrere gängige Dateisysteme gibt, für die fast alle Betriebssysteme Support und Treiber umfassen. Betriebssysteme variieren auf dem Dateisystem-Support und auf den Festplattenformaten können sie installiert werden. Unter Windows ist jedes Dateisystem in der Regel in der Anwendung auf bestimmte Medien beschränkt; zum Beispiel müssen CDs ISO 9660 oder UDF verwenden, und als Windows Vista ist NTFS das einzige Dateisystem, auf dem das Betriebssystem installiert werden kann. Es ist möglich, Linux auf viele Arten von Dateisystemen zu installieren. Im Gegensatz zu anderen Betriebssystemen können Linux und UNIX jedes Dateisystem unabhängig von den darin gespeicherten Medien verwendet werden, ob es sich um eine Festplatte, eine Disc (CD, DVD,) handelt. ein USB-Flash-Laufwerk, oder sogar in einer Datei auf einem anderen Dateisystem enthalten. Gerätetreiber Ein Gerätetreiber ist eine bestimmte Art von Computer-Software entwickelt, um Interaktion mit Hardware-Geräten zu ermöglichen. Typischerweise stellt dies eine Schnittstelle zur Kommunikation mit dem Gerät dar, über das spezifische Computerbus- oder Kommunikationsteilsystem, mit dem die Hardware verbunden ist, Befehle zum Bereitstellen und/oder Empfangen von Daten vom Gerät und andererseits die erforderlichen Schnittstellen zu Betriebssystem- und Softwareanwendungen. Es handelt sich um ein spezialisiertes hardwareabhängiges Computerprogramm, das auch betriebssystemspezifisch ist, das es ermöglicht, ein anderes Programm, typischerweise ein Betriebssystem oder Anwendungen Softwarepaket oder Computerprogramm, das unter dem Betriebssystemkernel läuft, transparent mit einem Hardwaregerät zu interagieren und in der Regel die erforderliche Unterbrechungshandling für alle notwendigen asynchronen zeitabhängigen Hardware-Interfacecing-Anforderungen bereitzustellen. Das entscheidende Designziel der Gerätetreiber ist die Abstraktion. Jedes Modell der Hardware (auch innerhalb derselben Geräteklasse) ist anders. Neue Modelle werden auch von Herstellern veröffentlicht, die eine zuverlässigere oder bessere Leistung bieten und diese neueren Modelle werden oft anders gesteuert. Computer und ihre Betriebssysteme können nicht erwartet werden, wie man jedes Gerät steuern kann, sowohl jetzt als auch in Zukunft. Um dieses Problem zu lösen, diktieren Betriebssysteme im Wesentlichen, wie jede Art von Gerät gesteuert werden soll. Die Funktion des Gerätetreibers besteht dann darin, dieses Betriebssystem beauftragte Funktionsaufrufe in gerätespezifische Anrufe zu übersetzen. In der Theorie sollte ein neues Gerät, das auf neue Weise gesteuert wird, richtig funktionieren, wenn ein geeigneter Treiber zur Verfügung steht. Dieser neue Treiber sorgt dafür, dass das Gerät wie üblich aus der Sicht des Betriebssystems funktioniert. Unter Windows-Versionen vor Vista und Linux-Versionen vor 2.6 war die gesamte Treiber-Ausführung kooperative, was bedeutet, dass, wenn ein Treiber eine unendliche Schleife eingegeben würde, das System gefrieren würde. Neuere Revisionen dieser Betriebssysteme enthalten Kernelvorgabe, wo der Kernel den Treiber unterbricht, um ihm Aufgaben zu geben, und trennt sich dann vom Prozess, bis er eine Antwort vom Gerätetreiber erhält, oder gibt ihm mehr Aufgaben zu erledigen. Networking Derzeit unterstützen die meisten Betriebssysteme eine Vielzahl von Netzwerkprotokollen, Hardware und Anwendungen für die Verwendung. Dies bedeutet, dass Computer, die unähnliche Betriebssysteme betreiben, an einem gemeinsamen Netzwerk teilnehmen können, um Ressourcen wie Computern, Dateien, Drucker und Scanner mit drahtgebundenen oder drahtlosen Verbindungen zu teilen. Netzwerke können im Wesentlichen zulassen, dass ein Computer-Betriebssystem auf die Ressourcen eines Remotecomputers zugreifen kann, um die gleichen Funktionen zu unterstützen, wie es könnte, wenn diese Ressourcen direkt mit dem lokalen Computer verbunden wurden. Dies beinhaltet alles von einfacher Kommunikation, über die Nutzung von vernetzten Dateisystemen oder sogar das Teilen von Grafiken oder Soundhardware eines anderen Computers. Einige Netzwerk-Dienste ermöglichen es, die Ressourcen eines Computers transparent zuzugreifen, z.B. SSH, die Netzwerk-Benutzern den direkten Zugriff auf die Befehlszeilenschnittstelle eines Computers ermöglicht. Client/Server-Netzwerking ermöglicht ein Programm auf einem Computer, genannt Client, über ein Netzwerk mit einem anderen Computer, genannt einem Server zu verbinden. Server bieten (oder Host) verschiedene Dienste an andere Netzwerk-Computer und Benutzer. Diese Dienste werden in der Regel über Ports oder nummerierte Access Points außerhalb der IP-Adresse des Servers bereitgestellt. Jede Portnummer ist in der Regel mit einem Maximum eines laufenden Programms verbunden, das für die Bearbeitung von Anfragen an diesen Port verantwortlich ist. Ein Daemon, ein Benutzerprogramm, kann wiederum auf die lokalen Hardwareressourcen dieses Computers zugreifen, indem Anfragen an den Betriebssystemkernel übermittelt werden. Viele Betriebssysteme unterstützen ein oder mehrere herstellerspezifische oder offene Netzwerkprotokolle sowie beispielsweise SNA auf IBM-Systemen, DECnet auf Systemen der Digital Equipment Corporation und Microsoft-spezifische Protokolle (SMB) unter Windows. Spezifische Protokolle für bestimmte Aufgaben können auch unterstützt werden, z.B. NFS für den Dateizugriff. Protokolle wie ESound oder esd können leicht über das Netzwerk erweitert werden, um Sound von lokalen Anwendungen, auf der Sound-Hardware eines Remote-Systems bereitzustellen. Sicherheit Ein Computer, der sicher ist, hängt von einer Reihe von Technologien ab, die richtig funktionieren. Ein modernes Betriebssystem bietet Zugang zu einer Reihe von Ressourcen, die der Software auf dem System zur Verfügung stehen, und zu externen Geräten wie Netzwerken über den Kernel. Das Betriebssystem muss in der Lage sein, zwischen Anträgen zu unterscheiden, die verarbeitet werden dürfen, und anderen, die nicht bearbeitet werden sollten. Während einige Systeme einfach zwischen privilegierten und nicht privilegierten unterscheiden können, haben Systeme häufig eine Form der Anforderungsidentität, wie ein Benutzername. Zur Identifizierung kann es einen Prozess der Authentifizierung geben. Oft muss ein Benutzername zitiert werden, und jeder Benutzername kann ein Passwort haben. Andere Methoden der Authentifizierung, wie Magnetkarten oder biometrische Daten, können stattdessen verwendet werden. In einigen Fällen, insbesondere Verbindungen aus dem Netzwerk, können Ressourcen überhaupt ohne Authentifizierung aufgerufen werden (wie zum Beispiel das Lesen von Dateien über einen Netzwerkanteil). Auch unter dem Begriff der Anforderungsidentität versteht man die Berechtigung; die von dem einmal in ein System eingeloggten Requester zugänglichen Dienste und Ressourcen sind entweder an das Benutzerkonto des Requesters oder an die unterschiedlich konfigurierten Nutzergruppen gebunden, zu denen der Requester gehört. Neben dem zulässigen oder abnehmenden Sicherheitsmodell bietet ein System mit hohem Sicherheitsniveau auch Auditing-Optionen. Diese würden das Tracking von Anträgen auf Zugriff auf Ressourcen ermöglichen (wie z.B. "wer hat diese Datei gelesen?"). Eine interne Sicherheit oder Sicherheit eines bereits laufenden Programms ist nur möglich, wenn alle möglicherweise schädlichen Anfragen durch Unterbrechungen des Betriebssystemkernels durchgeführt werden müssen. Wenn Programme direkt auf Hardware und Ressourcen zugreifen können, können sie nicht gesichert werden. Externe Sicherheit beinhaltet eine Anfrage von außerhalb des Computers, wie ein Login an einer angeschlossenen Konsole oder irgendeiner Art von Netzwerkverbindung. Externe Anfragen werden oft über Gerätetreiber an den Kernel des Betriebssystems weitergeleitet, wo sie an Anwendungen weitergegeben werden können oder direkt durchgeführt werden. Die Sicherheit der Betriebssysteme ist seit langem ein Anliegen, da hochsensible Daten auf Computern sowohl kommerzieller als auch militärischer Natur gespeichert werden. Die United States Government Department of Defense (DoD) erstellte die Trusted Computer System Evaluation Criteria (TCSEC), ein Standard, der grundlegende Anforderungen für die Bewertung der Wirksamkeit der Sicherheit festlegt. Dies wurde für den Betrieb von Systemherstellern von entscheidender Bedeutung, da die TCSEC verwendet wurde, um vertrauenswürdige Betriebssysteme zu bewerten, zu klassifizieren und auszuwählen, die für die Verarbeitung, Speicherung und Abruf sensibler oder klassifizierter Informationen in Betracht kommen. Netzwerkdienste umfassen Angebote wie Dateifreigabe, Druckdienste, E-Mail, Webseiten und Dateiübertragungsprotokolle (FTP), von denen die meisten die Sicherheit beeinträchtigen können. Bei der vorderen Sicherheitslinie handelt es sich um Hardware-Geräte, die als Firewalls oder Intrusions-Detektions-/Präventionssysteme bekannt sind. Auf der Ebene des Betriebssystems stehen eine Reihe von Software-Firewalls zur Verfügung, sowie Intrusions-Detektions-/Präventionssysteme. Die meisten modernen Betriebssysteme umfassen eine Software Firewall, die standardmäßig aktiviert ist. Eine Software-Firewall kann konfiguriert werden, um den Netzwerkverkehr zu oder von einem Dienst oder einer auf dem Betriebssystem laufenden Anwendung zu ermöglichen oder zu verweigern. Daher kann man einen unsicheren Service, wie Telnet oder FTP installieren und betreiben, und muss nicht durch eine Sicherheitsverletzung bedroht werden, weil die Firewall würde alle Traffic versuchen, mit dem Dienst auf diesem Port zu verbinden. Eine alternative Strategie und die einzige Sandbox-Strategie, die in Systemen zur Verfügung steht, die nicht den Anforderungen der Popek und Goldberg Virtualisierung entsprechen, ist, wo das Betriebssystem keine Benutzerprogramme als nativer Code betreibt, sondern entweder einen Prozessor emuliert oder einen Host für ein p-Code-basiertes System wie Java bietet. Die interne Sicherheit ist besonders relevant für Multi-User-Systeme; es ermöglicht jedem Benutzer des Systems, private Dateien zu haben, die die anderen Benutzer nicht mit oder lesen können. Die interne Sicherheit ist auch wichtig, wenn die Prüfung von jeder Verwendung sein soll, da ein Programm das Betriebssystem möglicherweise umgehen kann, einschließlich der Bypassing-Prüfung. Benutzeroberfläche Jeder Computer, der von einer Person betrieben werden soll, benötigt eine Benutzeroberfläche. Die Benutzeroberfläche wird in der Regel als Shell bezeichnet und ist wesentlich, wenn menschliche Interaktion unterstützt werden soll. Die Benutzeroberfläche sieht die Verzeichnisstruktur an und fordert Dienste von dem Betriebssystem, die Daten von Eingabehardware-Geräten, wie Tastatur, Maus oder Kreditkartenleser, erwerben, und fordert Betriebssystemdienste, um Eingabeaufforderungen, Statusnachrichten und dergleichen auf Ausgabehardware-Geräten, wie einen Videomonitor oder Drucker anzuzeigen. Die beiden häufigsten Formen einer Benutzeroberfläche waren historisch die Kommandozeilen-Schnittstelle, in der Computerbefehle zeilenweise ausgeschrieben werden, und die grafische Benutzeroberfläche, in der eine visuelle Umgebung (meist ein WIMP) vorhanden ist. Grafische Benutzeroberflächen Die meisten modernen Computersysteme unterstützen grafische Benutzeroberflächen (GUI) und beinhalten diese oft. In einigen Computersystemen, wie der ursprünglichen Implementierung des klassischen Mac OS, ist die GUI in den Kernel integriert. Während technisch keine grafische Benutzeroberfläche ein Betriebssystemservice ist, der die Unterstützung für einen in den Betriebssystemkernel einschließt, kann die GUI durch die Reduzierung der Anzahl der für die GUI erforderlichen Kontextschalter zur Ausführung ihrer Ausgangsfunktionen besser reagieren. Andere Betriebssysteme sind modular aufgebaut und trennen das Grafikteilsystem vom Kernel und dem Betriebssystem. In den 1980er Jahren hatten UNIX, VMS und viele andere Betriebssysteme, die so gebaut wurden. Linux und Mac So werden auch Betriebssysteme gebaut. Moderne Versionen von Microsoft Windows wie Windows Vista implementieren ein Grafik-Subsystem, das meist im Benutzer-Raum ist; aber die Grafikzeichnung Routinen von Versionen zwischen Windows NT 4.0 und Windows Server 2003 existieren meist im Kernel-Raum. Windows 9x hatte sehr wenig Unterscheidung zwischen der Schnittstelle und dem Kernel. Viele Computer-Betriebssysteme ermöglichen es dem Benutzer, jede Benutzeroberfläche zu installieren oder zu erstellen, die sie wünschen. Das X Window System in Verbindung mit GNOME oder KDE Plasma 5 ist ein häufig gefundenes Setup auf den meisten Unix- und Unix-ähnlichen (BSD, Linux, Solaris) Systemen. Für Microsoft Windows wurde eine Reihe von Windows Shell-Ersatzungen freigegeben, die Alternativen zur enthaltenen Windows-Halte bieten, aber die Shell selbst kann nicht von Windows getrennt werden. Zahlreiche Unix-basierte GUIs existierten im Laufe der Zeit, die meisten von X11 abgeleitet. Der Wettbewerb unter den verschiedenen Anbietern von Unix (HP, IBM, Sun) führte zu viel Fragmentierung, obwohl ein Versuch, in den 1990er Jahren zu COSE und CDE zu standardisieren, aus verschiedenen Gründen gescheitert war und schließlich durch die weit verbreitete Annahme von GNOME und K Desktop Environment verfinstert wurde. Vor freien softwarebasierten Toolkits und Desktop-Umgebungen war Motif die vorherrschende Toolkit/Desktop-Kombination (und war die Basis, auf der CDE entwickelt wurde). Graphische Benutzeroberflächen entwickeln sich im Laufe der Zeit. Zum Beispiel hat Windows seine Benutzeroberfläche fast jedes Mal geändert, wenn eine neue große Version von Windows veröffentlicht wird, und die Mac OS GUI dramatisch mit der Einführung von Mac OS X im Jahr 1999 geändert. Echtzeit-Betriebssysteme Ein Echtzeit-Betriebssystem (RTOS) ist ein Betriebssystem, das für Anwendungen mit festen Fristen (Realtime Computing) bestimmt ist. Solche Anwendungen umfassen einige kleine Embedded-Systeme, Automobil-Motor-Controller, Industrieroboter, Raumfahrzeuge, industrielle Steuerung und einige großformatige Computersysteme. Ein frühes Beispiel für ein großes Echtzeit-Betriebssystem war die von American Airlines und IBM entwickelte Transaction Processing Facility für das Sabre Airline Reservations System. Embedded Systeme, die feste Termine haben, nutzen ein Echtzeit-Betriebssystem wie VxWorks, PikeOS, eCos, QNX, MontaVista Linux und RTLinux. Windows CE ist ein Echtzeit-Betriebssystem, das ähnliche APIs auf Desktop-Windows teilt, aber keine Desktop-Windows-Codebase. Symbian OS hat auch einen RTOS-Kernel (EKA2) ab Version 8.0b. Einige eingebettete Systeme verwenden Betriebssysteme wie Palm OS, BSD und Linux, obwohl solche Betriebssysteme nicht Echtzeit-Computing unterstützen. Betriebssystementwicklung als Hobby Ein Hobby-Betriebssystem kann als eins eingestuft werden, dessen Code nicht direkt von einem bestehenden Betriebssystem abgeleitet wurde und wenige Benutzer und aktive Entwickler hat. In manchen Fällen unterstützt die Hobby-Entwicklung eine homebrew-Computing-Einrichtung, beispielsweise einen einfachen Einboard-Computer, der von einem 6502 Mikroprozessor betrieben wird. Oder, Entwicklung kann für eine Architektur bereits im weit verbreiteten Gebrauch sein. Die Betriebssystementwicklung kann aus ganz neuen Konzepten stammen oder durch Modellierung eines bestehenden Betriebssystems beginnen. In beiden Fällen ist der Hobbyist sein/ihr eigener Entwickler oder kann mit einer kleinen und manchmal unstrukturierten Gruppe von Personen interagieren, die ähnliche Interessen haben. Beispiele für ein Hobby-Betriebssystem sind Syllable und TempleOS. Vielfalt der Betriebssysteme und Portabilität Die Anwendungssoftware wird im Allgemeinen für den Einsatz auf einem bestimmten Betriebssystem und manchmal sogar für bestimmte Hardware geschrieben. Beim Portieren der Anwendung auf einem anderen Betriebssystem kann die von dieser Anwendung benötigte Funktionalität durch dieses OS (die Namen der Funktionen, die Bedeutung der Argumente usw.) unterschiedlich umgesetzt werden, wodurch die Anwendung angepasst, geändert oder anderweitig aufrechterhalten werden muss. Unix war das erste Betriebssystem, das nicht in der Montagesprache geschrieben wurde, so dass es sehr tragbar für Systeme, die von seinem nativen PDP-11. Diese Kosten bei der Unterstützung von Betriebssystemen Diversität können vermieden werden, indem stattdessen Anwendungen gegen Software-Plattformen wie Java oder Qt geschrieben werden.Diese Abstraktionen haben bereits die Kosten für die Anpassung an bestimmte Betriebssysteme und deren Systembibliotheken getragen. Ein weiterer Ansatz besteht darin, dass Systemhersteller Standards annehmen. Beispielsweise bieten POSIX- und OS-Abstraktionsschichten Gemeinsamkeiten, die die Portierungskosten senken. Marktanteil Siehe auch Hinweise Referenzen Weiter lesen Externe Links Betriebssysteme bei Curlie Multics Geschichte und die Geschichte der Betriebssysteme