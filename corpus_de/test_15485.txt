Software-Entwicklung ist der Prozess der Konzeption, Spezifikation, Design, Programmierung, Dokumentierung, Testen und Bugfixierung in der Erstellung und Pflege von Anwendungen, Frameworks oder anderen Softwarekomponenten. Software-Entwicklung ist ein Prozess des Schreibens und der Aufrechterhaltung des Quellcodes, aber im weiteren Sinne umfasst es alles, was zwischen der Konzeption der gewünschten Software bis zur endgültigen Manifestation der Software, manchmal in einem geplanten und strukturierten Prozess, beteiligt ist. Software-Entwicklung kann daher Forschung, neue Entwicklung, Prototyping, Modifikation, Wiederverwendung, Neu-Engineering, Wartung oder andere Aktivitäten, die zu Software-Produkten führen. Die Software kann für eine Vielzahl von Zwecken entwickelt werden, die drei häufigsten Wesen, um spezifische Bedürfnisse eines bestimmten Client / Unternehmens (der Fall mit benutzerdefinierter Software,) zu erfüllen, um eine wahrgenommene Notwendigkeit von einigen möglichen Benutzern (der Fall mit kommerzieller und Open Source Software,) oder für den persönlichen Gebrauch (z.B. ein Wissenschaftler kann Software schreiben, um eine mundane Aufgabe zu automatisieren). Die Embedded-Software-Entwicklung, d.h. die Entwicklung eingebetteter Software, wie sie beispielsweise zur Steuerung von Verbraucherprodukten verwendet wird, erfordert die Integration des Entwicklungsprozesses in die Entwicklung des kontrollierten physikalischen Produkts. Systemsoftware basiert auf Anwendungen und dem Programmierprozess selbst und wird oft separat entwickelt. Die Notwendigkeit einer besseren Qualitätskontrolle des Software-Entwicklungsprozesses hat die Disziplin der Software-Engineering zur Folge, die darauf abzielt, den im Engineering-Paradigma beispielhaften systematischen Ansatz auf den Prozess der Softwareentwicklung anzuwenden. Es gibt viele Ansätze für Software-Projektmanagement, bekannt als Software-Entwicklung Lebenszyklus-Modelle, Methoden, Prozesse oder Modelle. Das Wasserfall-Modell ist eine traditionelle Version, die mit der neueren Innovation der agilen Software-Entwicklung kontrastiert. Methoden Ein Software-Entwicklungsprozess (auch bekannt als Software-Entwicklungsmethodik, Modell oder Lebenszyklus) ist ein Rahmen, der verwendet wird, um den Prozess der Entwicklung von Informationssystemen zu strukturieren, zu planen und zu steuern. Im Laufe der Jahre hat sich eine Vielzahl solcher Rahmen entwickelt, die jeweils mit eigenen anerkannten Stärken und Schwächen gekennzeichnet sind. Es gibt verschiedene Ansätze für die Softwareentwicklung: Einige nehmen einen strukturierteren, Engineering-basierten Ansatz zur Entwicklung von Software, während andere einen inkrementelleren Ansatz verfolgen können, wo Software sich entwickelt, wie es Stück für Stück entwickelt wird. Eine Systementwicklungsmethodik ist nicht unbedingt für alle Projekte geeignet. Jede der verfügbaren Methoden eignet sich am besten für bestimmte Arten von Projekten, basierend auf verschiedenen technischen, organisatorischen, Projekt- und Teambetrachtungen. Die meisten Methoden teilen einige Kombination der folgenden Phasen der Softwareentwicklung: Analyse des Problems Marktforschung Anforderungen an die vorgeschlagene Software Entwickeln eines Plans oder Designs für die Software Implementierung (Coding) der Software Testen und Debuggen der Software Bereitstellung Wartung und BugfixingDie Stadien werden oft als Softwareentwicklungs-Lebenszyklus oder SDLC bezeichnet. Verschiedene Ansätze zur Softwareentwicklung können diese Stufen in unterschiedlichen Aufträgen ausführen oder mehr oder weniger Zeit auf unterschiedliche Stufen widmen. Das Detail der in jedem Stadium der Softwareentwicklung erstellten Dokumentation kann auch variieren. Diese Stufen können wiederum durchgeführt werden (ein "Wasserfall"-basierter Ansatz), oder sie können über verschiedene Zyklen oder Iterationen wiederholt werden (ein extremer Ansatz). Der extremere Ansatz beinhaltet in der Regel weniger Zeit für die Planung und Dokumentation und mehr Zeit für die Kodierung und Entwicklung automatisierter Tests. Mehr „extreme“ Ansätze fördern auch kontinuierliche Tests im gesamten Entwicklungslebenszyklus, sowie ein funktionierendes (oder fehlerfreies) Produkt zu jeder Zeit. Mehr strukturierte oder „Wasserfall“-basierte Ansätze versuchen, die Mehrheit der Risiken zu bewerten und einen detaillierten Plan für die Software zu entwickeln, bevor die Implementierung (Coding) beginnt, und vermeiden signifikante Designänderungen und Re-Coding in späteren Phasen der Software-Entwicklungs-Lebenszyklusplanung. Es gibt erhebliche Vorteile und Nachteile für die verschiedenen Methoden, und der beste Ansatz, ein Problem mit Software zu lösen, hängt oft von der Art der Problem. Wenn das Problem gut verstanden wird und die Arbeit vor der Zeit effektiv geplant werden kann, kann der Wasserfall-basierte Ansatz am besten funktionieren.Ist dagegen das Problem einzigartig (zumindest dem Entwicklungsteam) und die Struktur der Software kann nicht leicht vorgesehen werden, so kann ein extremer inkrementeller Ansatz am besten funktionieren. Softwareentwicklungsaktivitäten Identifizierung der Notwendigkeit Die Ideenquellen für Softwareprodukte sind reichlich. Diese Ideen können aus der Marktforschung kommen, einschließlich der Demografie potenzieller neuer Kunden, bestehender Kunden, Vertriebsaussichten, die das Produkt, andere interne Software-Entwicklungsmitarbeiter oder einen kreativen Dritten abgelehnt haben. Ideen für Softwareprodukte werden in der Regel zuerst von Marketing-Personal für wirtschaftliche Machbarkeit, für die Anpassung an bestehende Kanäle Verteilung, für mögliche Auswirkungen auf bestehende Produktlinien, erforderliche Funktionen und für die Anpassung an die Marketingziele des Unternehmens ausgewertet. In einer Marketing-Evaluationsphase werden die Kosten- und Zeitannahmen ausgewertet. In der ersten Phase wird eine Entscheidung getroffen, ob aufgrund der detaillierteren Informationen des Marketing- und Entwicklungspersonals das Projekt weiter verfolgt werden soll. Im Buch "Große Software-Verhandlungen", sagt Alan M. Davis im Kapitel Anforderungen, Unterkapitel "The Missing Piece of Software Development" Studenten der Ingenieurwissenschaften lernen Engineering und sind selten Finanzen oder Marketing ausgesetzt. Studierende des Marketings lernen Marketing und sind selten Finanzen oder Ingenieuren ausgesetzt. Die meisten von uns werden Spezialisten in nur einem Bereich. Um die Dinge zu komplizieren, treffen sich einige von uns interdisziplinäre Menschen in der Belegschaft, so dass es nur wenige Rollen zu imitieren. Dennoch ist die Software-Produktplanung für den Entwicklungserfolg entscheidend und erfordert absolut Kenntnisse mehrerer Disziplinen. Da Software-Entwicklung möglicherweise Kompromisse einschließen oder über das hinausgehen kann, was der Kunde benötigt, kann ein Software-Entwicklungsprojekt in weniger technische Anliegen wie Personal, Risikomanagement, geistiges Eigentum, Budgetierung, Krisenmanagement usw. übergehen. Diese Prozesse können auch dazu führen, dass sich die Geschäftsentwicklung mit der Softwareentwicklung überlappt. Planungsprozess Die Planung ist ein Ziel jeder Aktivität, in der wir Dinge entdecken wollen, die zum Projekt gehören. Eine wichtige Aufgabe bei der Erstellung eines Softwareprogramms besteht darin, die Anforderungen oder Anforderungen zu analysieren. Kunden haben in der Regel eine abstrakte Idee, was sie als Endergebnis wollen, aber wissen nicht, was Software tun sollte. Skilled und erfahrene Software-Ingenieure erkennen an dieser Stelle unvollständige, mehrdeutige oder sogar widersprüchliche Anforderungen. Häufig zeigen Live-Code kann dazu beitragen, das Risiko zu reduzieren, dass die Anforderungen falsch sind. "Obwohl viel Aufwand in die Anforderungsphase gestellt wird, um sicherzustellen, dass die Anforderungen vollständig und konsistent sind, selten das ist der Fall; die Software-Designphase als einflussreichste zu lassen, wenn es darum geht, die Auswirkungen neuer oder sich ändernder Anforderungen zu minimieren. Anforderungen Volatilität ist anspruchsvoll, weil sie zukünftige oder bereits laufende Entwicklungsbemühungen beeinflussen. " Sobald die allgemeinen Anforderungen vom Kunden erhoben werden, sollte eine Analyse des Entwicklungsumfangs bestimmt und klar angegeben werden. Dies wird oft als Scope-Dokument bezeichnet. Gestaltung Sobald die Anforderungen festgelegt sind, kann das Design der Software in einem Software-Design-Dokument erstellt werden. Hierbei handelt es sich um eine vorläufige oder hochrangige Gestaltung der Hauptmodule mit einem Gesamtbild (wie Blockdiagramm) wie die Teile zusammenpassen. Sprache, Betriebssystem und Hardwarekomponenten sollten alle zu diesem Zeitpunkt bekannt sein. Dann wird ein detailliertes oder Low-Level-Design erstellt, vielleicht mit Prototyping als Nachweis-of-concept oder um Anforderungen zu festigen. Implementierung, Prüfung und Dokumentation Implementierung ist Teil des Prozesses, in dem Software-Ingenieure den Code für das Projekt tatsächlich programmieren. Softwaretests sind eine integrale und wichtige Phase des Softwareentwicklungsprozesses. Dieser Teil des Verfahrens sorgt dafür, dass Mängel so schnell wie möglich erkannt werden. Bei einigen Verfahren, die allgemein als testgesteuerte Entwicklung bekannt sind, können Tests kurz vor der Implementierung entwickelt werden und dienen als Leitfaden für die Richtigkeit der Implementierung. Die Dokumentation des internen Designs der Software zum Zweck der zukünftigen Wartung und Erweiterung erfolgt während der Entwicklung. Dies kann auch das Schreiben einer API enthalten, sei es extern oder intern. Der vom Entwicklungsteam gewählte Software-Engineering-Prozess bestimmt, wie viel interne Dokumentation (falls vorhanden) notwendig ist.Plangetriebene Modelle (z.B. Wasserfall) produzieren in der Regel mehr Dokumentation als Agile Modelle. Bereitstellung und Wartung Die Bereitstellung beginnt direkt nach der Prüfung des Codes, genehmigt für die Freigabe, verkauft oder anderweitig in eine Produktionsumgebung verteilt. Dabei kann es sich um Installation, Anpassung (z.B. durch Einstellung von Parametern auf die Werte des Kunden) und möglicherweise um eine erweiterte Auswertungsdauer handeln. Software-Training und Support ist wichtig, da Software nur dann wirksam ist, wenn sie korrekt verwendet wird. Die Aufrechterhaltung und Verbesserung der Software, um mit neu entdeckten Fehlern oder Anforderungen zu bewältigen, kann erhebliche Zeit und Mühe, da verpasste Anforderungen können die Neugestaltung der Software zwingen.. In den meisten Fällen ist die Wartung regelmäßig erforderlich, um gemeldete Probleme zu beheben und die Software laufen zu lassen. Subtopie Modell anzeigen Ein Ansichtsmodell ist ein Rahmen, der die Standpunkte auf dem System und seiner Umgebung zur Anwendung im Softwareentwicklungsprozess bereitstellt. Es ist eine grafische Darstellung der zugrunde liegenden Semantik einer Ansicht. Der Zweck von Gesichtspunkten und Ansichten ist es, den Ingenieuren zu ermöglichen, sehr komplexe Systeme zu verstehen und die Elemente des Problems rund um Fachbereiche zu organisieren. Im Engineering von physikalisch intensiven Systemen entsprechen die Standpunkte oft den Fähigkeiten und Verantwortlichkeiten innerhalb der Engineering-Organisation. Die komplexesten Systemspezifikationen sind so umfangreich, dass niemand einzelne alle Aspekte der Spezifikationen vollständig erfassen kann. Darüber hinaus haben wir alle unterschiedliche Interessen an einem gegebenen System und verschiedene Gründe für die Prüfung der Spezifikationen des Systems. Ein Geschäftsführender wird verschiedene Fragen eines System Make-up stellen, als würde ein System implementieren. Das Konzept des Sichtrahmens ist es daher, separate Ansichten in die Spezifikation eines bestimmten komplexen Systems zu geben. Diese Standpunkte erfüllen jeweils ein Publikum mit Interesse an einigen Aspekten des Systems. Mit jedem Blickpunkt verbunden ist eine Viewpoint-Sprache, die das Vokabular und die Präsentation für das Publikum dieses Blickpunktes optimiert. Der Geschäftsprozess und die Datenmodellierung Die grafische Darstellung des aktuellen Informationszustands bietet eine sehr effektive Möglichkeit, sowohl Benutzern als auch Systementwicklern Informationen zur Verfügung zu stellen. Ein Geschäftsmodell veranschaulicht die Funktionen, die mit dem Modellierungsprozess und den Organisationen verbunden sind, die diese Funktionen ausführen. Durch die Darstellung von Aktivitäten und Informationsflüssen wird eine Stiftung geschaffen, um die Natur eines Prozesses zu visualisieren, zu definieren, zu verstehen und zu validieren. Ein Datenmodell liefert die Einzelheiten der zu speichernden Informationen und ist primär verwendet, wenn das Endprodukt die Generierung von Computersoftwarecode für eine Anwendung oder die Erstellung einer Funktionsspezifikation zur Hilfe einer Computersoftware-Schee-oder-Buy-Entscheidung ist. Siehe die Figur rechts zum Beispiel die Interaktion zwischen Geschäftsprozess und Datenmodellen. In der Regel wird ein Modell nach Durchführung eines Interviews erstellt, das als Geschäftsanalyse bezeichnet wird. Das Interview besteht aus einem Moderator, der eine Reihe von Fragen stellt, um die erforderlichen Informationen, die einen Prozess beschreibt, zu extrahieren. Der Interviewer wird als Moderator bezeichnet, um zu betonen, dass es die Teilnehmer sind, die die Informationen liefern. Der Moderator sollte einige Kenntnisse über den Prozess des Interesses haben, aber dies ist nicht so wichtig wie eine strukturierte Methodik, nach der die Fragen des Prozessexperten gestellt werden. Die Methodik ist wichtig, weil in der Regel ein Team von Moderatoren Informationen über die Anlage sammelt und die Ergebnisse der Informationen von allen Interviewern müssen einmal abgeschlossen zusammen passen. Die Modelle werden entwickelt, um entweder den aktuellen Zustand des Prozesses zu definieren, wobei das Endprodukt als "as-is Snapshot"-Modell bezeichnet wird, oder eine Sammlung von Ideen, was der Prozess enthalten sollte, was zu einem "What-can-be"-Modell führt. Die Erzeugung von Prozess- und Datenmodellen kann verwendet werden, um festzustellen, ob die vorhandenen Prozesse und Informationssysteme klingen und nur geringfügige Änderungen oder Erweiterungen benötigen, oder ob eine Neuausrichtung als Korrekturmaßnahme erforderlich ist. Die Erstellung von Geschäftsmodellen ist mehr als eine Möglichkeit, Ihren Informationsprozess anzuschauen oder zu automatisieren. Die Analyse kann genutzt werden, um die Art und Weise, wie Ihr Unternehmen oder Ihre Organisation seine Operationen durchführt, grundlegend umzugestalten. Computergestütztes Software-Engineering Computergestütztes Software-Engineering (CASE), im Bereich Software-Engineering, ist die wissenschaftliche Anwendung einer Reihe von Software-Tools und Methoden zur Entwicklung von Software, die zu qualitativ hochwertigen, fehlerfreien und pflegefähigen Softwareprodukten führt.Es bezieht sich auch auf Methoden zur Entwicklung von Informationssystemen zusammen mit automatisierten Werkzeugen, die im Softwareentwicklungsprozess eingesetzt werden können. Der Begriff "computergestützte Softwaretechnik" (CASE) kann sich auf die Software beziehen, die für die automatisierte Entwicklung von Systemsoftware, d.h. Computercode, verwendet wird. Die CASE-Funktionen umfassen Analyse, Design und Programmierung. CASE-Werkzeuge automatisieren Methoden zur Gestaltung, Dokumentation und Erstellung von strukturierten Computercodes in der gewünschten Programmiersprache. Zwei Schlüsselideen von Computer-aided Software System Engineering (CASE) sind: Foster Computer-Hilfe in Software-Entwicklung und Software-Wartungsprozesse und ein Engineering-Ansatz für Software-Entwicklung und Wartung. Typische CASE-Tools existieren für Konfigurationsmanagement, Datenmodellierung, Modelltransformation, Refactoring, Quellcode-Generation. Integrierte Entwicklungsumgebung Eine integrierte Entwicklungsumgebung (IDE), die auch als integrierte Designumgebung oder integrierte Debugging-Umgebung bekannt ist, ist eine Software-Anwendung, die umfassende Einrichtungen für Computerprogrammierer zur Softwareentwicklung bietet. Eine IDE besteht in der Regel aus einem: Source-Code-Editor, Compiler oder Interpreter, Build Automation Tools und Debugger (in der Regel). Die IDEs sind so konzipiert, dass sie die Produktivität der Programmierer maximieren, indem sie festgestrickte Komponenten mit ähnlichen Benutzeroberflächen bereitstellen. Typischerweise ist eine IDE einer bestimmten Programmiersprache gewidmet, um ein Feature-Set zu bieten, das am besten den Programmierparadigmen der Sprache entspricht. Modellsprache Eine Modellierungssprache ist jede künstliche Sprache, die verwendet werden kann, um Informationen oder Kenntnisse oder Systeme in einer Struktur, die durch eine einheitliche Regel definiert ist auszudrücken. Die Regeln werden zur Interpretation der Bedeutung von Komponenten in der Struktur verwendet. Eine Modellierungssprache kann graphisch oder textuell sein. Graphische Modellierungssprachen verwenden ein Diagrammtechniken mit benannten Symbolen, die Konzepte und Linien darstellen, die die Symbole verbinden und Beziehungen und verschiedene andere grafische Anmerkungen darstellen, um Zwänge darzustellen. Textuelle Modellierungssprachen verwenden typischerweise standardisierte Schlüsselwörter, die von Parametern begleitet werden, um computerinterpretierbare Ausdrücke zu machen. Beispiele für grafische Modellierungssprachen im Bereich Software-Engineering sind: Business Process Modeling Notation (BPMN und das XML-Formular BPML) ist ein Beispiel für eine Prozessmodellierungssprache. EXPRESS und EXPRESS-G (ISO 10303-11) ist eine internationale Standard-Datenmodellierungssprache. Extended Enterprise Modeling Language (EEML) wird häufig für die Modellierung von Geschäftsprozessen über Schichten verwendet. Flowchart ist eine schematische Darstellung eines Algorithmus oder eines schrittweisen Prozesses, Fundamental Modeling Concepts (FMC) Modellierungssprache für softwareintensive Systeme. IDEF ist eine Familie von Modellierungssprachen, deren bemerkenswerteste sind IDEF0 für die funktionale Modellierung, IDEF1X für die Informationsmodellierung und IDEF5 für die Modellierung von Onlogien. LePUS3 ist eine objektorientierte visuelle Design Description Sprache und eine formale Spezifikationssprache, die vor allem für die Modellierung großer objektorientierter (Java, C,+ C#) Programme und Designmuster geeignet ist. Spezifikation und Beschreibung Sprache (SDL) ist eine Spezifikationssprache, die auf die eindeutige Spezifikation und Beschreibung des Verhaltens von reaktiven und verteilten Systemen ausgerichtet ist. Unified Modeling Language (UML) ist eine allgemeine Modellierungssprache, die ein Industriestandard für die Angabe von softwareintensiven Systemen ist. UML 2.0, die aktuelle Version, unterstützt dreizehn verschiedene Diagrammtechniken und verfügt über weit verbreitete Werkzeugunterstützung. Nicht alle Modellsprachen sind ausführbar, und für diejenigen, die sie benutzen, bedeutet nicht unbedingt, dass Programmierer nicht mehr benötigt werden. Im Gegenteil, ausführbare Modellierungssprachen sollen die Produktivität von qualifizierten Programmierern verstärken, so dass sie schwierigere Probleme wie Parallelrechner und verteilte Systeme ansprechen können. Programming paradigm Ein Programmierparadigma ist ein grundlegender Stil der Computerprogrammierung, der im Allgemeinen nicht von der Projektmanagement-Methodik (wie Wasserfall oder Agil) diktiert wird. Paradigmen unterscheiden sich in den Konzepten und Abstraktionen, die verwendet werden, um die Elemente eines Programms (wie Objekte, Funktionen, Variablen, Zwänge) und die Schritte, die eine Berechnung umfassen (wie Zuordnungen, Auswertungen, Fortsetzungen, Datenflüsse.) Manchmal werden die vom Paradigma behaupteten Konzepte kooperativ in der hochrangigen Systemarchitektur-Konstruktion genutzt; in anderen Fällen beschränkt sich der Umfang der Programmierung auf die interne Struktur eines bestimmten Programms oder Moduls.Eine Programmiersprache kann mehrere Paradigmen unterstützen. Beispielsweise können in C+ oder Object Pascal geschriebene Programme rein verfahrenstechnisch oder rein objektorientiert sein oder Elemente beider Paradigmen enthalten. Software-Designer und Programmierer entscheiden, wie man diese Paradigmenelemente verwendet. Bei der objektorientierten Programmierung können Programmierer an ein Programm als Sammlung von interagierenden Objekten denken, während bei der funktionellen Programmierung ein Programm als Folge von staatlichen Funktionsauswertungen gedacht werden kann. Bei der Programmierung von Computern oder Systemen mit vielen Prozessoren ermöglicht die prozessorientierte Programmierung Programmierern, sich über Anwendungen als Sets von gleichzeitig auf logisch geteilte Datenstrukturen wirkenden Prozessen zu informieren. Ebenso wie unterschiedliche Gruppen im Software-Engineering unterschiedliche Methoden befürworten, befürworten unterschiedliche Programmiersprachen unterschiedliche Programmierparadigmen. Einige Sprachen sollen ein Paradigma unterstützen (Smalltalk unterstützt objektorientierte Programmierung, Haskell unterstützt funktionelle Programmierung), während andere Programmiersprachen mehrere Paradigmen unterstützen (wie Object Pascal, C,+ C,# Visual Basic, Common Lisp, Scheme, Python, Ruby und Oz). Viele Programmierparadigmen sind ebenso bekannt für welche Methoden sie verbieten, was sie ermöglichen. So verbietet z.B. reine Funktionsprogrammierung die Verwendung von Nebenwirkungen; strukturierte Programmierung verbietet die Verwendung von goto-Anweisungen. Teilweise aus diesem Grund werden neue Paradigmen oft als Doktrinär oder übermäßig starr von denen angesehen, die an frühere Stile gewöhnt sind. Vermeiden bestimmter Methoden kann es einfacher machen, Theorien über die Richtigkeit eines Programms zu beweisen, oder einfach sein Verhalten zu verstehen. Beispiele für hochrangige Paradigmen sind: Aspect-orientierte Software-Entwicklung Domänenspezifische Modellierung Modell-getriebenes Engineering Objektorientierte Programmiermethoden Grady Boochs objektorientiertes Design (OOD,) auch als objektorientierte Analyse und Design (OOAD) bekannt. Das Booch-Modell umfasst sechs Diagramme: Klasse, Objekt, Zustandsübergang, Interaktion, Modul und Prozess. Search-based software engineering Service-orientierte Modellierung Strukturierte Programmierung Top-down- und Bottom-up-Design Top-down-Programmierung: entwickelt in den 1970er Jahren von IBM-Forscher Harlan Mills (und Niklaus Wirth) in der entwickelten strukturierten Programmierung. Software wiederverwenden Eine Definition der Software wiederverwenden ist der Prozess der Erstellung von Software aus vordefinierten Softwarekomponenten. Ein Software-Reuse-Ansatz zielt darauf ab, die Nutzung bestehender Software Artefakte im Software-Entwicklungslebenszyklus zu erhöhen oder zu maximieren. Folgende sind einige häufige Software-Reuse-Methoden: Ein Software-Framework ist ein wiederverwendbares Design oder Implementierung für ein Software-System oder Subsystem. Komponentenbasierte Software-Engineering beinhaltet die Integration bestehender Komponenten zur Erstellung einer Anwendung. Serviceorientierte Architekturen oder serviceorientierte Programmierung baut auf dem Konzept von Komponenten auf, um vernetzte Dienste, wie z.B. Webdienste, bereitzustellen. Software-Produktlinien wollen Software auf Basis eines gemeinsamen Kernvermögens und Prozesses entwickeln, um eine Reihe von Produkten (oder Anwendungen) für einen bestimmten Markt herzustellen. API (Anwendungs-Programmierschnittstelle, erstellen Sie eine Reihe von "Subroutine-Definitionen, Protokolle und Tools für die Erstellung von Anwendungssoftware", die in zukünftigen Builds verwendet werden können. Open Source Dokumentationen, über Bibliotheken wie GitHub, bieten kostenlosen Code für Software-Entwickler, um wieder zu verwenden und in neue Anwendungen oder Designs implementieren. Siehe auch Kontinuierliche Integration Custom software DevOps Funktionelle Spezifikation Programmierung Produktivität Software blueprint Software-Entwicklung Aufwand Schätzverfahren Software-Entwicklung Prozess Software-Projektmanagement Spezifikation und Beschreibung Sprache Benutzererfahrung Software-Industrie Rollen und Industrie Bachelor of Science in Informationstechnologie Computer Programmierer Consulting Software-Ingenieur Offshore Software-Entwicklung Software-Entwickler Software-Ingenieur Spezielle Anwendungen Videospiel-Entwicklung Web-Anwendungsentwicklung Web-Entwicklung Mobile-Anwendungs-Entwicklung Referenzen Weiterentwicklung Referenzen Weiter lesen Kit, Edward (1992). Softwaretest in der Real World.Addison-Wesley Professional.ISBN 0201877562.McCarthy, Jim (1995). Dynamik der Softwareentwicklung. Microsoft Press.ISBN 1556158238. Conde, Dan (2002). Software Produkt Management: Verwaltung von Software-Entwicklung von Ideen über Produkt bis Marketing bis Vertrieb. Aspatore Books.ISBN 1587622025. Davis, A. M. (2005). Einfach genug Anforderungsmanagement: Wo Softwareentwicklung auf Marketing trifft.Dorset House Publishing Company, Incorporated.ISBN 0932633641.Hasted, Edward (2005). Software, die verkauft: Ein praktischer Leitfaden zur Entwicklung und Vermarktung Ihres Software-Projekts. Wiley Publishing.ISBN 0764597833.Hohmann, Luke (2003). Jenseits der Software-Architektur: Winning Solutions erstellen und erhalten.Addison-Wesley Professional.ISBN 0201775948.John W. Horch (2005). " Zwei Orientierungen zur Arbeit mit Objekten." In: IEEE Software.vol.12, Nr. 2, S.117–118, Mar., 1995. Rittinghouse, John (2003). Software verwalten Lieferbar: Eine Software Development Management Methodology. Digital Press.ISBN 155558313X. Wiegers, Karl E. (2005). Mehr über Softwarevoraussetzungen: Thorny Issues und praktische Beratung. Microsoft Press.ISBN 0735622671.Wysocki, Robert K. (2006). Effektive Software Projektmanagement.Wiley.ISBN 0764596365.