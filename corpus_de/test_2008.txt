=History = Der Fly Algorithm ist eine Art kooperative Koevolution basierend auf dem Pariser Ansatz. Das Fly Algorithm wurde erstmals 1999 im Rahmen der Anwendung von Evolutionsalgorithmen auf Computer-Stereo-Vision entwickelt. Im Gegensatz zum klassischen bildbasierten Ansatz zur Stereovision, der die Bildprimitiven extrahiert, passt sie dann zu ihnen, um 3-D-Informationen zu erhalten, basiert das Fly Agorithm auf der direkten Erkundung des 3-D-Raums der Szene. Eine Fliege wird als 3-D-Punkt definiert, der durch ihre Koordinaten (x, y, z) beschrieben ist. Nachdem in einem Suchraum, der dem Blickfeld der Kameras entspricht, eine zufällige Population von Fliegen geschaffen wurde, nutzte seine Evolution (basierend auf dem Paradigma Evolutionary Strategy) eine Fitnessfunktion, die auswertet, wie wahrscheinlich die Fliege auf der sichtbaren Oberfläche eines Objekts liegt, basierend auf der Konsistenz seiner Bildprojektionen. Zu diesem Zweck nutzt die Fitnessfunktion die Graustufen, Farben und/oder Texturen der Projektionen der berechneten Fliege. Das erste Anwendungsfeld des Fly Algorithm war Stereovision. Während die klassischen `Bildpriorität'-Ansätze übereinstimmende Merkmale aus den Stereobildern verwenden, um ein 3-D-Modell zu erstellen, erforscht das Fly Algorithm direkt den 3-D-Raum und verwendet Bilddaten, um die Gültigkeit von 3-D-Hypothesen zu bewerten. Eine Variante namens "Dynamic Flies" definiert die Fliege als 6-uple (x, y, z, x’, y’, z’) mit der Geschwindigkeit der Fliege. Die Geschwindigkeitskomponenten werden bei der Fitnessberechnung nicht explizit berücksichtigt, sondern werden in den Aktualisierungspositionen der Fliegen verwendet und unterliegen ähnlichen genetischen Operatoren (Mutation, Crossover). Die Anwendung von Fliess zur Vermeidung von Hindernissen in Fahrzeugen nutzt die Tatsache, dass die Population von Fliegen eine zeitkonforme, quasi-kontinuierliche Darstellung der Szene ist, um direkt Fahrzeugkontrollsignale von den Fliegen zu erzeugen. Die Verwendung des Fly Algorithms ist nicht streng auf Stereobilder beschränkt, da andere Sensoren (z.B. akustische Näherungssensoren etc.) als zusätzliche Begriffe zur Optimierung der Fitnessfunktion hinzugefügt werden können. Odometrieinformationen können auch verwendet werden, um die Aktualisierung von Flugpositionen zu beschleunigen, und umgekehrt können die Flugpositionen verwendet werden, um Lokalisierungs- und Kartierungsinformationen bereitzustellen. Ein weiteres Anwendungsgebiet des Fly Algorithm ist der Wiederaufbau für die Emission Tomographie in der Nuklearmedizin. Das Fly Algorithm wurde erfolgreich in der Einzelphotonen-Emissions-Computertomographie und Positronen-Emissionstomographie eingesetzt. Dabei gilt jede Fliege als Photonenemitter und ihre Fitness basiert auf der Konformität der simulierten Beleuchtung der Sensoren mit dem auf den Sensoren beobachteten Istmuster. In dieser Anwendung wurde die Fitnessfunktion neu definiert, um das neue Konzept der "marginalen Bewertung" zu verwenden. Dabei wird die Fitness einer Person als (positiver oder negativer) Beitrag zur Qualität der globalen Bevölkerung berechnet. Es basiert auf dem ausscheidenden Cross-validierungsprinzip. Eine globale Fitness-Funktion wertet die Qualität der Gesamtbevölkerung aus; nur dann wird die Fitness eines Individuums (eine Fliege) als Differenz zwischen den globalen Fitnesswerten der Bevölkerung mit und ohne die jeweilige Fliege berechnet, deren individuelle Fitness-Funktion ausgewertet werden muss. In der Fitness jeder Fliege wird als "Niveau des Vertrauens" betrachtet. Es wird während des Voxelisierungsprozesses verwendet, um den individuellen Fußabdruck der Fliege mit impliziter Modellierung (wie Metabälle) zu tweaken. Es produziert glatte Ergebnisse, die genauer sind. Vor kurzem wurde es in der digitalen Kunst verwendet, um Mosaik-ähnliche Bilder oder Spray-Farbe zu erzeugen. Beispiele für Bilder finden Sie auf YouTube Pariser Evolution Hier gilt die Bevölkerung von Individuen als Gesellschaft, in der die Individuen zu einem gemeinsamen Ziel zusammenarbeiten. Dies wird mit einem evolutionären Algorithmus durchgeführt, der alle gemeinsamen genetischen Operatoren (z.B. Mutation, Cross-over, Selektion) umfasst. Der Hauptunterschied liegt in der Fitness-Funktion. Hier werden zwei Niveaus der Fitness-Funktion verwendet: Eine lokale Fitnessfunktion zur Beurteilung der Leistung eines bestimmten Individuums (in der Regel während des Auswahlprozesses verwendet). Eine globale Fitness-Funktion, um die Leistung der gesamten Bevölkerung zu bewerten. Diese globale Fitness ist das Ziel der Bevölkerung. Darüber hinaus ist ein Diversity-Mechanismus erforderlich, um Personen zu vermeiden, die sich in nur wenigen Bereichen des Suchraums sammeln. Ein weiterer Unterschied liegt in der Extraktion der Problemlösung, sobald die Evolutionsschleife beendet ist.In klassischen evolutionären Ansätzen entspricht das beste Individuum der Lösung und der Rest der Bevölkerung wird verworfen. Hier werden alle Individuen (oder Individuen einer Untergruppe der Bevölkerung) zusammengeführt, um die Problemlösung aufzubauen. Die Art und Weise, wie die Fitness-Funktionen aufgebaut sind und die Art und Weise, wie die Lösungsextraktion gemacht wird, sind selbstverständlich problematisch. Beispiele für Pariser Evolution-Anwendungen sind: Der Fly-Algorithmus. Text-Mining. Handgestenerkennung. Modellierung komplexer Interaktionen im industriellen landwirtschaftlichen Prozess. Positron Emission Tomographie Rekonstruktion. Disambiguation Pariser Ansatz vs kooperative coevolution Cooperative coevolution ist eine breite Klasse von evolutionären Algorithmen, bei denen ein komplexes Problem gelöst wird, indem es in Teilkomponenten zersetzt wird, die unabhängig voneinander gelöst werden. Der Pariser Ansatz teilt viele Ähnlichkeiten mit dem kooperativen Koevolutionären Algorithmus. Der Pariser Ansatz nutzt eine Einzelpopulation, während Multispezies in kooperativen Koevolutionären Algorithmus verwendet werden können. Ähnliche interne evolutionäre Motoren werden im klassischen evolutionären Algorithmus, kooperativen koevolutionären Algorithmus und Pariser Evolution betrachtet. Der Unterschied zwischen kooperativem Koevolutionäralgorithmus und Pariser Evolution liegt in der Semantik der Bevölkerung. Kooperative koevolutionäre Algorithmus teilt ein großes Problem in Sub-Probleme (Gruppen von Einzelpersonen) und löst sie getrennt auf das große Problem. Es gibt keine Interaktion/Züchtung zwischen Individuen der verschiedenen Subpopulationen, nur mit Individuen derselben Subpopulation. Allerdings lösen Pariser evolutionäre Algorithmen ein ganzes Problem als große Komponente. Alle Personen der Bevölkerung kooperieren zusammen, um die ganze Bevölkerung in attraktive Bereiche des Suchraums zu treiben. Fly Algorithm gegen Partikelschwarm-Optimierung Kooperative Koevolution und Partikelschwarm-Optimierung (PSO) teilen viele Ähnlichkeiten. PSO ist von dem sozialen Verhalten der Vogelflockung oder Fischschulung inspiriert. Es wurde zunächst als Werkzeug für realistische Animation in Computergrafiken eingeführt. Es verwendet komplexe Individuen, die miteinander interagieren, um visuell realistische kollektive Verhaltensweisen durch Anpassung der Verhaltensregeln der Individuen (die zufällige Generatoren verwenden können) aufzubauen. Bei der mathematischen Optimierung folgt jedes Teilchen des Schwarms irgendwie seinem eigenen zufälligen Weg, der dem besten Teilchen des Schwarms entgegengewirkt wird. Im Fly Algorithm zielen die Fliegen darauf ab, räumliche Darstellungen einer Szene aus tatsächlichen Sensordaten zu erstellen; Fliegen kommunizieren nicht oder explizit zusammen und verwenden kein Verhaltensmodell. Beide Algorithmen sind Suchmethoden, die mit einer Reihe von zufälligen Lösungen beginnen, die iterativ auf ein globales Optimum korrigiert werden. Die Lösung des Optimierungsproblems im Fly Algorithm ist jedoch die Bevölkerung (oder eine Untergruppe der Bevölkerung): Die Fliegen arbeiten implizit zusammen, um die Lösung zu bauen. In PSO ist die Lösung ein einziges Teilchen, das mit der besten Fitness. Ein weiterer wesentlicher Unterschied zwischen Fly Algorithm und PSO ist, dass das Fly Algorithm nicht auf einem Verhaltensmodell basiert, sondern nur eine geometrische Darstellung baut. Anwendungen der Fly algorithnm Computer-Stereo-Vision Hindernisse Vermeidung Gleichzeitige Lokalisierung und Kartierung (SLAM)Single-photonen-Emission berechnete Tomographie (SPECT) Rekonstruktion Positron-Emissionstomographie (PET) Rekonstruktion Digitale Kunst Beispiel: Tomographie Rekonstruktion Tomographie Rekonstruktion ist ein inverses Problem, das aufgrund fehlender Daten und/oder Geräusche oft krank ist. Die Antwort auf das inverse Problem ist nicht einmalig, und im Falle eines extremen Geräuschpegels kann es nicht einmal existieren. Die Eingabedaten eines Rekonstruktionsalgorithmus können als Radon-Transformation oder Sinusogramm (Y ) {\displaystyle Left(Y\right}) der Daten zur Rekonstruktion (f ) {\displaystyle Left(f\right}) angegeben werden. Y ist bekannt. Die Datenerfassung in der Tomographie kann wie: Y = P [f ] + ε {\displaystyle Y=P[f]+\epsilon } wobei P {\displaystyle P} die Systemmatrix oder Projektionsoperator ist und ε {\displaystyle \epsilon } einigen Poisson Rauschen entspricht.In diesem Fall entspricht die Rekonstruktion der Inversion der Radon-Transformation: f = P - 1 [ Y ] {\displaystyle f=P^{-1}[Y] Beachten Sie, dass P - 1 {\displaystyle P^{-1} für Rauschen, Akquisitionsgeometrie usw. ausfallen kann. Das Fly Algorithm ist ein Beispiel der iterativen Rekonstruktion. Iterative Methoden der tomographischen Rekonstruktion sind relativ einfach zu modellieren: f ^ = a r g m i n  in | Y − Y : | | 2 2 {\displaystyle {\hat {f}}\operatorname (arg\,min) |Y-{\hat Y}}||_{2}{2 wobei f ^ {\displaystyle {\hat {f} eine Schätzung von f {\displaystyle f} ist, die eine Fehlermetrie minimiert (hier l2-Norm, aber andere Fehlermetriken könnten verwendet werden) zwischen Y\displaystyle Y} und Y ^\display {style\hat {Y} Iterative Methoden können wie folgt implementiert werden: (i)Die Rekonstruktion beginnt mit einer anfänglichen Schätzung des Bildes (in der Regel ein konstantes Bild), (ii) Projektionsdaten werden aus diesem Bild berechnet, (iii) Die geschätzten Projektionen werden mit den gemessenen Projektionen verglichen, (iv) Korrekturen vorgenommen, um das geschätzte Bild zu korrigieren, und (v) Der Algorithmus iteriert bis zur Konvergenz der geschätzten und gemessenen Projektionssätze. Der nachfolgende Pseudocode ist eine schrittweise Beschreibung des Fly Algorithms zur tomographischen Rekonstruktion. Der Algorithmus folgt dem stationären Paradigma. Für illustrative Zwecke werden fortgeschrittene genetische Operatoren wie Mitose, Doppelmutation usw. ignoriert.A JavaScript-Implementierung finden Sie auf Fly4PET. algorithm fly-algorithm ist eingeben: Anzahl der Fliegen (N,) Eingabe Projektionsdaten (Präferenz) Ausgabe: die Fliegepopulation (F,) die Projektionen geschätzt von F (pestimiert) das 3-D-Volume entsprechend der Voxelisierung von F (VF) Postbedingung: die Differenz zwischen pestimiert und Präferenz ist minimal. 1. /Initialisierung 2. / Setzen Sie die Position der N Fliegen, d.h. erstellen Sie erste Rate 3. für jede Fliege i in Fliegepopulation F do 4. F(i)x ← random(0, 1) 5. F(i)y ← random(0, 1) 6. F(i)z ← random(0, 1) 7. F(i)'s Projektion in pestimiert 8. 9. /Berechnen Sie die Leistung der Bevölkerung (d.h. die globale Fitness) 10. Gfitness(F)← Fehler (Präferenz, pestimiert) 11. 12. fkill ← Wählen Sie eine zufällige Fliege von F 13. 14. Entferne den Beitrag von fkill von pestimated 15. 16. /Berechnen Sie die Leistung der Bevölkerung ohne Fkill 17. Gfitness(F-{fkill}) ← Fehlermetrie(Präferenz, pestimiert) 18. 19. /Vergleichen Sie die Leistungen, d.h. berechnen Sie die lokale Fitness der Fliege 20. - Gfitness(F) 21. 22. Wenn die lokale Fitness größer als 0 ist, // Thresholded-Auswahl einer schlechten Fliege, die getötet werden kann 23. dann gehen Sie zum Schritt 26. /fkill ist eine gute Fliege (die Leistung der Bevölkerung ist besser, wenn Fkill enthalten ist:) wir sollten sie nicht töten 24. sonst gehen Sie zu Schritt 28. /fkill ist eine schlechte Fliege (die Leistung der Bevölkerung ist schlechter, wenn Fkill enthalten ist:) wir können es loswerden 25. 26. Restore den Beitrag der Fliege, dann gehen Sie zu Schritt 12.27 28. Wählen Sie einen genetischen Operator 29. 30. Ist der Genoperator Mutation, 31. dann gehen Sie zu Schritt 34.32 weiter zu Schritt 50.33 34. freproduce ← Wählen Sie eine zufällige Fliege von F 35. 14.Entferne den Beitrag von freproduce von pestimated 37. 38. /Berechnen Sie die Leistung der Bevölkerung ohne freproduce 39. Gfitness(F-{freproduce}) ← Errormetrics(preference, pestimated) 40. 41. /Vergleichen Sie die Leistungen, d.h. berechnen Sie die lokale Fitness der Fliege 42. Lfitness(freproduce) ← Gfitness(F-{freproduce}) - Gfitness(F) 43. 44. Restore der Fliege Beitrag 45. 46. Ist die lokale Fitness kleiner oder gleich 0, // Thresholded-Auswahl einer guten Fliege, die 47 reproduzieren kann. weiter in Schritt 34. /fkill ist eine schlechte Fliege: wir sollten es nicht zulassen, 48 zu reproduzieren. dann gehen Sie zu Schritt 53. /fkill ist eine gute Fliege: wir können es erlauben, 49 zu reproduzieren. 50. /Neues Blut / Einwanderung 51. Ersetzen Sie Fkill durch eine neue Fliege mit einer zufälligen Position, gehen Sie zu Schritt 57.52 53. /Mutation 54. Kopieren Sie freproduce in fkill 55. Leicht und zufällig ändern die Position 56 des Fkills. 57. Fügen Sie den Beitrag der neuen Fliege zur Bevölkerung 58 hinzu. 59. Wenn die Rekonstruktion stoppen, 60. dann gehen Sie zu Schritt 63.61 sonst gehen zu Schritt 10.62 63. /Extraktlösung 64. VF ← Voxelisation von F 65. 66. VF END Beispiel: Digitale Künste In diesem Beispiel soll ein Eingabebild durch eine Reihe von Fliesen (z.B. wie in einem alten Mosaik) angenähert werden. Eine Kachel hat eine Orientierung (Winkel θ,) eine drei Farbkomponenten (R, G, B), eine Größe (w, h) und eine Position (x, y, z). Wenn es N Fliesen gibt, gibt es 9N unbekannte schwimmende Punktzahlen zu erraten. Mit anderen Worten für 5.000 Fliesen gibt es 45.000 Zahlen zu finden. Mit einem klassischen evolutionären Algorithmus, in dem die Antwort des Optimierungsproblems das beste Individuum ist, würde das Genom eines Individuums aus 45.000 Genen bestehen. Dieser Ansatz wäre im Hinblick auf Komplexität und Rechenzeit äußerst aufwendig. Gleiches gilt für jeden klassischen Optimierungsalgorithmus. Mit dem Fly Algorithm mimiert jeder einzelne eine Fliese und kann individuell mit seiner lokalen Fitness bewertet werden, um seinen Beitrag zur Leistungsfähigkeit der Bevölkerung (die globale Fitness) zu bewerten. Hier hat ein Individuum 9 Gene statt 9N, und es gibt N Individuen. Es kann als Rekonstruktionsproblem wie folgt gelöst werden: n = n = n = n = n = n = n = n = n = n = n = n = 0 x < W = 0 j < H | i n p u t ( x, y ) - P [F ] ( x , y under | \ n \ n \ n \ n \ n H} sind die Bildbreite und Höhe in der Anzahl der Pixel, F {\displaystyle F} ist die Fliegepopulation, und P {\displaystyle P} ist ein Projektionsoperator, der ein Bild von Fliegen erzeugt. Dieser Projektionsoperator P {\displaystyle P} kann viele Formen annehmen. In ihrer Arbeit verwendet Z. Ali Aboodd OpenGL, um verschiedene Effekte zu erzeugen (z.B. Mosaiken oder Spraylack). Zur Beschleunigung der Bewertung der Fitnessfunktionen wird auch OpenCL verwendet. Der Algorithmus beginnt mit einer Population F {\displaystyle F}, die zufällig erzeugt wird (siehe Zeile 3 im obigen Algorithmus).F {\displaystyle F} wird dann mit der globalen Fitness bewertet, um G f i t n e s s (F ) = Σ y = 0 x < W Σ j = 0 j < H | i n p u t ( x , y ) - P [F ]\, y )\displaystyle G_{fitness}(F)={overset x}W} G f i t n e s s {\displaystyle G_{fitness} ist eine Fehlermetrik, sie muss minimiert werden. Siehe auch Mathematische Optimierung Metaheuristischer Suchalgorithmus Stochastic Optimierung Evolutionäre Berechnung Evolutionary algorithm Genetic algorithm Mutation (genetic algorithm)Crossover (genetic algorithm)Selection (genetic algorithm) =References ==