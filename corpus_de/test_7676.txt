In der Computerarchitektur ist Multithreading die Fähigkeit einer zentralen Verarbeitungseinheit (CPU) (oder eines einzigen Kerns in einem Multi-Core-Prozessor), mehrere Ausführungsfäden gleichzeitig, unterstützt durch das Betriebssystem, bereitzustellen. Dieser Ansatz unterscheidet sich von der Mehrverarbeitung. In einer mehrgängigen Anwendung teilen die Threads die Ressourcen eines einzelnen oder mehrerer Kerne, darunter die Recheneinheiten, die CPU-Caches und der Translation Lookaside-Puffer (TLB). Wenn mehrverarbeitende Systeme mehrere komplette Verarbeitungseinheiten in einem oder mehreren Kernen umfassen, zielt Multithreading darauf ab, die Ausnutzung eines einzelnen Kerns durch die Verwendung von Fadenniveau-Parallelismus sowie Instruktionsebene-Parallelismus zu erhöhen. Da die beiden Techniken komplementär sind, werden sie in fast allen modernen Systemarchitekturen mit mehreren Multithreading CPUs und mit CPUs mit mehreren Multithreading Cores kombiniert. Überblick Das multithreading Paradigma ist immer beliebter geworden, da seit Ende der 1990er Jahre Anstrengungen zur weiteren Ausbeutung von Instruktionsebenenparallelismus gestoppt sind. Damit konnte das Konzept der Durchsatz-Computing aus dem spezialisierteren Bereich der Transaktionsverarbeitung neu genutzt werden. Obwohl es sehr schwierig ist, ein einziges Gewinde oder ein einziges Programm weiter zu beschleunigen, sind die meisten Computersysteme tatsächlich Multitasking unter mehreren Threads oder Programmen. So führen Techniken, die den Durchsatz aller Aufgaben verbessern, zu Gesamtleistungsgewinnen. Zwei Haupttechniken für den Durchsatz Computing sind Multithreading und Multi Processing. Vorteile Wenn ein Faden eine Menge Cache-Verfehlungen erhält, können die anderen Threads die ungenutzten Rechenressourcen weiter nutzen, was zu einer schnelleren Gesamtausführung führen kann, da diese Ressourcen im Leerlauf wären, wenn nur ein einziger Thread ausgeführt würde. Auch wenn ein Thread nicht alle Rechenressourcen der CPU verwenden kann (weil Anweisungen von dem Ergebnis des anderen abhängig sind), kann ein Laufen eines anderen Fadens verhindern, dass diese Ressourcen in Ruhe kommen. Nachteile Mehrere Threads können sich gegenseitig stören, wenn Hardwareressourcen wie Caches oder Translation Lookaside Puffer (TLBs) geteilt werden. Dadurch werden die Ausführungszeiten eines einzelnen Fadens nicht verbessert und können auch bei Ausführung nur eines Fadens durch geringere Frequenzen oder zusätzliche Rohrleitungsstufen, die zur Aufnahme von gewindeschaltender Hardware erforderlich sind, abgebaut werden. Gesamteffizienz variiert; Intel behauptet bis zu 30% Verbesserung mit seiner Hyper-Threading-Technologie, während ein synthetisches Programm nur eine Schleife von nicht optimierten abhängigen Floating-Point-Operationen tatsächlich eine 100%-ige Geschwindigkeitsverbesserung erreicht, wenn parallel laufen. Auf der anderen Seite, handgestimmte Montage Sprachprogramme mit MMX oder AltiVec Erweiterungen und die Durchführung von Daten prefetches (als ein guter Video-Encoder könnte) leiden nicht unter Cache Misses oder idle Computing Ressourcen. Solche Programme profitieren daher nicht von Hardware-Multithreading und können in der Tat aufgrund von Contention für gemeinsame Ressourcen abgebaute Leistung sehen. Aus der Softwaresicht ist die Hardware-Unterstützung für das Multithreading für die Software sichtbarer und erfordert mehr Änderungen an Anwendungsprogrammen und Betriebssystemen als die Multiverarbeitung. Hardware-Techniken verwendet, um Multithreading oft parallel zu den Software-Techniken für Computer Multitasking zu unterstützen. Thread scheduling ist auch ein großes Problem in der Multithreading. Arten von Multithreading Interleaved/Temporal Multithreading Coarse-grained Multithreading Die einfachste Art der Multithreading tritt auf, wenn ein Faden läuft, bis es durch ein Ereignis blockiert wird, das normalerweise einen Langlatzstand verursachen würde. Ein solcher Stall könnte ein Cache-Verfehl sein, der auf den Off-Chip-Speicher zugreifen muss, der Hunderte von CPU-Zyklen für die Daten zur Rückkehr nehmen könnte. Anstatt auf den Stall zu warten, um zu lösen, würde ein Gewindeprozessor die Ausführung auf ein anderes Gewinde schalten, das bereit war zu laufen. Erst wenn die Daten für den vorherigen Faden angekommen waren, würde der vorherige Faden wieder auf die Liste der lauffertigen Fäden gelegt werden. Zum Beispiel: Cycle i: Anweisung j aus Thread A wird ausgestellt. Cycle i + 1: Anweisung j + 1 aus Faden A wird ausgestellt. Zyklus i + 2: Anleitung j + 2 aus dem Faden Es wird eine Lastanweisung ausgegeben, die in allen Caches fehlt. Cycle i + 3: Thread Scheduler aufgerufen, schaltet zum Thread B. Cycle i + 4: Befehl k aus dem Faden B ausgegeben. Cycle i + 5: Befehl k + 1 aus Faden B ausgestellt. Konzeptionell ist es ähnlich wie kooperative Multitasking in Echtzeit-Betriebssystemen, in denen Aufgaben freiwillig Ausführungszeit aufgeben, wenn sie auf irgendeine Art der Veranstaltung warten müssen. Diese Art der Multithreading ist als Block-, Kooperative oder grobkörnige Multithreading bekannt. Ziel der Multithreading-Hardware-Unterstützung ist es, ein schnelles Schalten zwischen einem blockierten Faden und einem anderen laufbereiten Faden zu ermöglichen. Um dieses Ziel zu erreichen, ist die Hardware-Kosten, das Programm sichtbare Register zu replizieren, sowie einige Prozessorsteuerungsregister (wie den Programmzähler). Durch Umschalten von einem Gewinde auf ein anderes Gewinde wird die Hardware von einem Register auf ein anderes schaltet; um effizient zwischen aktiven Threads zu wechseln, muss jedes aktive Gewinde einen eigenen Registersatz aufweisen. Um z.B. schnell zwischen zwei Threads zu wechseln, muss die Register-Hardware zweimal instantiiert werden. Zusätzliche Hardware-Unterstützung für Multithreading ermöglicht eine Thread-Umschaltung in einem CPU-Zyklus, wodurch Leistungsverbesserungen. Auch zusätzliche Hardware ermöglicht es jedem Thread, sich zu verhalten, als ob er alleine ausgeführt und keine Hardwareressourcen mit anderen Threads teilen würde, wodurch die Menge an Software-Änderungen minimiert werden, die innerhalb der Anwendung und des Betriebssystems benötigt werden, um Multithreading zu unterstützen. Viele Familien von Mikrocontrollern und eingebetteten Prozessoren haben mehrere Registerbanken, um einen schnellen Kontextwechsel für Unterbrechungen zu ermöglichen. Solche Systeme können als eine Art Blockmultithreading unter dem Benutzerprogrammgewinde und den Interruptfäden betrachtet werden. Interleaved Multithreading Das interleaved Multithreading dient dazu, alle Datenabhängigkeitsställe aus der Ausführungspipeline zu entfernen. Da ein Gewinde relativ unabhängig von anderen Gewinden ist, besteht in einer Pipelinierungsstufe weniger Chancen auf eine Anweisung, die einen Ausgang von einer älteren Anweisung in der Pipeline benötigt. Konkret ist es ähnlich wie in Betriebssystemen eingesetzte präemptive Multitasking; eine Analogie wäre, dass die jedem aktiven Faden gegebene Zeitscheibe ein CPU-Zyklus ist. Zum Beispiel: Cycle i + 1: Es wird eine Anweisung aus dem Faden B ausgegeben. Cycle i + 2: Es wird eine Anweisung aus dem Faden C ausgegeben. Diese Art der Multithreading wurde zunächst als Laufbearbeitung bezeichnet, bei der die Staves eines Laufs die Rohrleitungsstufen und deren auslaufende Fäden darstellen. Interleaved, preemptive, feinkörnige oder zeitgeschliffene Multithreading sind modernere Terminologie. Neben den Hardwarekosten, die in der Blockart des Multithreading diskutiert werden, hat das interleaved Multithreading einen zusätzlichen Kostenaufwand für jede Pipeline-Stufe, die den Faden ID des Befehls, den er verarbeitet, verfolgt. Auch da in der Pipeline mehr Fäden gleichzeitig ausgeführt werden, müssen gemeinsame Ressourcen wie Caches und TLBs größer sein, um ein Ausweichen zwischen den verschiedenen Fäden zu vermeiden. Gleichzeitiges Multithreading Die fortschrittlichste Art der Multithreading gilt für superscalar Prozessoren. Während ein normaler Superscalar-Prozessor mehrere Anweisungen aus einem einzigen Thread jeden CPU-Zyklus ausgibt, kann bei gleichzeitiger Multithreading (SMT) ein Superscalar-Prozessor Anweisungen aus mehreren Threads jeden CPU-Zyklus ausgeben. Erkennt man, dass jeder einzelne Faden eine begrenzte Menge an Instruktion-Level-Parallelismus hat, versucht diese Art von Multithreading, Parallelismus über mehrere Fäden zu nutzen, um den Abfall, der mit ungenutzten Ausgabeschlitzen verbunden ist, zu verringern. Zum Beispiel: Zyklus i: Anweisungen j und j + 1 aus dem Faden A und Befehl k aus dem Faden B werden gleichzeitig ausgegeben. Zyklus i + 1: Befehl j + 2 aus dem Faden A, Befehl k + 1 aus dem Faden B und Befehl m aus dem Faden C werden alle gleichzeitig ausgegeben. Cycle i + 2: Anleitung j + 3 aus dem Faden A und Anweisungen m + 1 und m + 2 aus dem Faden C werden alle gleichzeitig ausgegeben. Um die anderen Arten von Multithreading von SMT zu unterscheiden, wird der Begriff "temporal multithreading" verwendet, um zu bezeichnen, wenn Anweisungen von nur einem Thread zu einem Zeitpunkt ausgestellt werden können. Zusätzlich zu den Hardwarekosten, die für das interleaved Multithreading diskutiert werden, hat SMT die zusätzlichen Kosten für jede Pipeline-Stufe, die den Faden ID jedes zu bearbeitenden Befehls verfolgt. Auch hier müssen gemeinsame Ressourcen wie Caches und TLBs für die Vielzahl von aktiven Threads, die verarbeitet werden, dimensioniert werden. Implementierungen umfassen DEC (später Compaq) EV8 (nicht abgeschlossen), Intel Hyper-Threading Technology, IBM POWER5/POWER6/POWER7/POWER8/POWER9, IBM z13/z14/z15, Sun Microsystems UltraSPARC T2, Cray XMT und AMD Bulldozer und Zen Mikroarchitekturen. Anwendungsspezifikationen Ein großer Forschungsbereich ist der Fadenplaner, der schnell aus der Liste der einsatzfertigen Threads wählen muss, um als nächstes auszuführen, sowie die einsatzbereiten und gestoppten Fadenlisten aufrechtzuerhalten. Ein wichtiges Unterthema sind die unterschiedlichen Fadenprioritätsschemata, die vom Scheduler verwendet werden können. Der Thread Scheduler kann vollständig in Software, vollständig in Hardware oder als Hardware/Software-Kombination implementiert werden. Ein weiterer Forschungsbereich ist, welche Art von Ereignissen einen Thread Switch verursachen sollten: Cache misses, inter-thread communication, DMA-Vervollständigung, etc. Wenn das Multithreading-System den gesamten softwaresichtbaren Zustand, einschließlich privilegierter Steuerregister und TLBs, repliziert, ermöglicht es, virtuelle Maschinen für jeden Thread zu erstellen. Dadurch kann jeder Thread sein eigenes Betriebssystem auf demselben Prozessor ausführen. Wird dagegen nur der Benutzer-Modus-Zustand gespeichert, wird weniger Hardware benötigt, was es ermöglichen würde, dass mehr Threads gleichzeitig für den gleichen Werkzeugbereich oder Kosten aktiv sind. Siehe auch Super-Threading Spekulative Multithreading ReferenzenExterne Links Eine Umfrage von Prozessoren mit Explicit Multithreading, ACM, März 2003, von Theo Ungerer, Borut Robi und JurijSilcOperating System | Unterschied zwischen Multitasking, Multithreading und Multiprocessing GeeksforGeeks, 6. Sept. 2018. Im Folgenden wird die soziale Struktur Rumäniens in drei verschiedene Kategorien unterteilt. Königreich Rumänien (vor 1947) Vor dem Zweiten Weltkrieg war Rumänien vor allem agrarianisch; in den späten 1940er Jahren beschäftigten sich etwa drei Viertel der Bevölkerung mit Subsistenzlandwirtschaft aus immer schrumpfenden Grundstücken (aufgrund einer wachsenden ländlichen Bevölkerung). Obwohl einige industrielle Aktivitäten durch staatliche Verträge und ausländische Investitionen gefördert wurden, war die industrielle Entwicklung langsam und konnte keine alternativen Beschäftigungsmöglichkeiten für die überbevölkerte und verarmte Landschaft schaffen. Auf der niedrigen sozialen Pyramide stand eine überproportional mächtige soziale Elite, ein Überrest der Adel, die einst besaß den größten Teil des Landes im Königreich Rumänien (1881–1947). Obwohl die Reformen zwischen 1917 und 1921 sie mit nur 15% des arretierbaren Landes verlassen hatten, hielt diese Aristokratie eine starke Stimme in politischen Angelegenheiten. kommunistische Ära (1947–1989) Nach dem Zweiten Weltkrieg wurde die soziale Struktur Rumäniens durch die Einführung eines politischen Systems, das eine klassenlose, egalitäre Gesellschaft vorstellt, drastisch verändert. Die marxistisch-leninistische Lehre hält fest, dass die Errichtung eines sozialistischen Staates (in dem die Arbeiterklasse die Mittel der Produktion und der Verteilung von Gütern und politischer Macht besitzt) die endgültige Entwicklung des Kommunismus sicherstellen wird. Unter dem Kommunismus gäbe es keinen Klassenkonflikt oder Ausbeutung des Menschen durch seinen Mitmenschen. Es gäbe eine Fülle von Reichtum, die von allen gleichermaßen geteilt wird. Der Weg zum Kommunismus erfordert den Vorrang der Arbeiterklasse und die Abschaffung der herrschenden Klasse und der Bourgeoisie. In Rumänien war letzteres leicht erreicht, aber die meisten der Bevölkerung waren Bauern und nicht Arbeiter. Die kommunistische Regierung (von der Sowjetunion im Jahre 1945) eliminierte die Opposition gegen ihre Machtkonsolidierung durch Appelle an die Arbeiterklasse. Durch den Zweiten Weltkrieg verursachte Disruption unterstützte die neue Regierung; ein Großteil der herrschenden Elite war entweder ausgewandert oder getötet worden, und viele Überlebende verließen mit den zurückziehenden deutschen Truppen, als die Rote Armee näherte. Die meisten Juden (die vor dem Krieg ein großes Segment der gemeinschaftlichen und finanziellen Elite bildeten) starben entweder in faschistischen Rumänien oder flohen in den nächsten Jahren. Maßnahmen, die in den frühen Tagen der kommunistischen Herrschaft ergriffen wurden, löschten das, was von der oberen Kruste blieb. Landreformen im Jahre 1945 eliminierten große Betriebe und beraubten die Aristokratie ihrer Macht und wirtschaftlichen Basis. Die Währungsreform von 1947 (die im Wesentlichen alle Gelder für den Staat beschlagnahmt) war ruinös für Mitglieder der kommerziellen und industriellen Bourgeoisie, die nicht mit ihrem Vermögen geflohen waren. Der Staat enteignete auch kommerzielle und industrielle Eigenschaften; bis 1950 90% aller industriellen Produktion war staatlich kontrolliert, und 1953 waren nur 14 % der Geschäfte privat. Obwohl die Opposition von den wirtschaftlicher und sozial fortschrittlicheren Gesellschaftsmitgliedern fast sofort beseitigt wurde, hatte gerade die Aufgabe, eine industrielle Arbeiterklasse zu schaffen (in deren Namen die Kommunisten Macht beanspruchten). 1950 lebten weniger als 25% der Bevölkerung in Städten oder arbeiteten in Fabriken. Die Bedingungen auf dem Land wurden jedoch für Veränderungen in der Richtung, die das Regime benötigt. Der Krieg und die sowjetische Besatzung ließen die Bauernschaft hungern, mit viel ihrer Vieh und Kapital zerstört. Ihre Probleme wurden von einer Dürre in 1945–1946, gefolgt von einer Hungersnot, in der Tausende starben. Wichtiger für das Regime, viele der Bauern wurden vom Land abgelöst und waren bereit, in Fabrikarbeiten zu arbeiten, die aus dem Industrialisierungsprogramm der Kommunistischen Partei resultieren. Postkommunismus (1990–präsent) Von den späten 1970er bis 1980er Jahren gab es eine wachsende Wirtschaftskrise, die zu einem starken Rückgang der Lebensstandards führte. Die Antwort von Nicolae Ceaușescu, die liberale Austerität nutzte, führte zu erhöhten gesellschaftlichen Spannungen und noch schlechteren Bedingungen für die Arbeit der Menschen. Im Dezember 1989 wurde die Regierung unter der Leitung von Nicolae Ceaușescu gewaltsam gestürzt, wobei sie in Bukarest riotiert. Die plötzliche Beseitigung einer staatlich kontrollierten Wirtschaft führte zu einer weiteren Erosion des Lebensstandards mit Arbeitslosigkeit und Arbeitsplatzunsicherheit. Der soziale Wandel in Rumänien war langsam, mit Fortschritten in Richtung einer weniger zentral kontrollierten Wirtschaft in der Natur. = Referenzen ==