Ein Computer-Endgerät ist ein elektronisches oder elektromechanisches Hardwaregerät, das zum Eingeben von Daten in einen Computer oder ein Computersystem verwendet werden kann. Der Teletyp war ein Beispiel eines frühen Tag-Hardoskopie-Terminals und predierte die Verwendung eines Computerbildschirms bis Jahrzehnte. Frühe Terminals waren kostengünstige Geräte, aber sehr langsam im Vergleich zu gestanzten Karten oder Papierband für die Eingabe, aber als die Technologie verbessert und Video-Displays eingeführt wurden, drängten Terminals diese älteren Formen der Interaktion von der Industrie. Eine verwandte Entwicklung war Timesharing-Systeme, die parallel entwickelt und für alle Ineffizienzen der Eingabefähigkeit des Benutzers mit der Fähigkeit, mehrere Benutzer auf der gleichen Maschine zu unterstützen, jeweils an ihrem eigenen Terminal / Terminals. Die Funktion eines Terminals ist typischerweise auf Transkription und Eingabe von Daten beschränkt; ein Gerät mit einer signifikanten lokalen programmierbaren Datenverarbeitungsfähigkeit kann als "Smart Terminal" oder Fat Client bezeichnet werden. Ein Terminal, das von dem Host-Computer für seine Verarbeitungsleistung abhängt, wird als "dumb terminal" oder als dünner Client bezeichnet. Ein persönlicher Computer kann Terminal-Emulator-Software ausführen, die Funktionen eines real-world-Terminals repliziert, manchmal erlaubt die gleichzeitige Nutzung lokaler Programme und Zugriff auf ein entferntes Terminal-Host-System. Geschichte Die Konsole von Konrad Zuse's Z3 hatte 1941 eine Tastatur, wie die Z4 1942-45. Aber diese Konsolen konnten nur verwendet werden, um numerische Eingaben zu erfassen und waren damit analog denen von Rechenmaschinen; Programme, Befehle und andere Daten wurden über Papierband eingegeben. Beide Maschinen hatten eine Reihe von Anzeigelampen für Ergebnisse. Im Jahr 1955 war der Whirlwind Mark I Computer der erste Computer mit einer Tastatur-Drucker-Kombination ausgestattet, mit der die direkte Eingabe von Daten und Befehlen und Ausgabe von Ergebnissen unterstützt werden. Das Gerät war ein Friden Flexowriter, der diesen Zweck auf vielen anderen frühen Computern gut in die 1960er Jahre bedienen würde. Festplattenterminals Frühe Benutzerterminals, die mit Computern verbunden waren, waren, wie der FlexoWriter, elektromechanische Teleprinter/Teletypewriter (TeleTYpewriter, TTY), wie das Teletype Model 33, das ursprünglich für die Telegrafie verwendet wurde; frühe Teletypen wurden typischerweise als Keyboard Send-Receive (KSR) oder Automatic Send-Receive (ASR) konfiguriert. Dies führte zur Nutzung der aktuellen Schleifenschnittstelle, die bereits in der Telegraphie verwendet wurde, sowie eines blühenden Marktes für Überschussmaschinen für den Computereinsatz. Individuelle Designs Tastatur/Drucker-Terminals, die später kamen, waren die IBM 2741 (1965) und der DECwriter (1970). Jeweilige Höchstgeschwindigkeiten von Teletypen, IBM 2741 und der LA30 (einer frühen DECwriter) waren 10, 15 und 30 Zeichen pro Sekunde. Obwohl damals "Papier war König" die Geschwindigkeit der Interaktion relativ begrenzt war. Der DECwriter war das letzte große Druckterminalprodukt. Sie verblasste nach 1980 unter Druck von Bildschirmen, wobei die letzte Revision (der DECwriter IV von 1982) die klassische Teletype-Schreiberform für eine weitere Ähnlichkeit mit einem Desktop-Drucker aufgibt. Bildschirme ein Video-Display Die Einheit (VDU) zeigt Informationen auf einem Bildschirm, anstatt Text auf Papier zu drucken und verwendet typischerweise eine Kathodenstrahlröhre (CRT). Aufgrund dieser Technologie wurden diese Geräte oft als CRT bezeichnet. Die Bildschirme in den 1950er Jahren wurden typischerweise für die Anzeige von grafischen Daten anstatt nur Text konzipiert. CRT-Anzeigen in diesem Zeitrahmen wurden in z.B. experimentellen Computern am MIT verwendet; Handelscomputer von z.B. DEC, ERA, IBM, UNIVAC; Militärcomputer für z.B. BMEWS, BUIC, SAGE. Zwei frühe Meilensteine in der Entwicklung des VDU waren das Univac Uniscope 300 und das IBM 2260, beide 1964. Beide waren Block-Mode-Terminals entworfen, um eine Seite zu einer Zeit zu versenden, anstatt Zeichen-Mode-Geräte. Das Hazeltine 2000 von 1970 war ein bemerkenswertes späteres Produkt der gleichen Art. Der Datapoint 3300 von der Computer Terminal Corporation, 1967 bekanntgegeben und 1969 versendet, war ein Zeichen-Modus-Gerät, das ein Modell 33 Teletype emulated. Dies spiegelt die Tatsache wider, dass frühe Zeichen-Mode-Terminals oft eingesetzt wurden, um Teletype-Maschinen zu ersetzen, um die Betriebskosten zu reduzieren. Die nächste Generation von Bildschirmen ging über Teletyp-Emulation mit einem adressierbaren Cursor, der ihnen die Möglichkeit gab, zweidimensionale Anzeigen auf dem Bildschirm zu malen. Trotzdem wurden frühe Geräte dieser Art oft "Glas TTYs" genannt. Die klassische Ära der DSG begann in den frühen 1970er Jahren und war eng mit dem Anstieg der Zeitaustausch-Computer verbunden. Wichtige Frühprodukte waren die ADM-3A, VT52 und VT100. Diese Geräte verwendet keine CPU, sondern auf einzelne Logik-Gatter oder sehr primitive LSI-Chips. Dies machte sie kostengünstig und sie wurden schnell extrem populär Input-Output-Geräte auf vielen verschiedenen Arten von Computersystem, oft ersetzen frühere und teurere Druckterminals. Nach 1970 wurden mehrere Lieferanten auf eine Reihe von gemeinsamen Standards graviert: ASCII-Zeichensatz (anstatt, sagen, EBCDIC oder etwas, das einem Unternehmen spezifisch ist), aber früh/ökonomie-Modelle unterstützten oft nur Großbuchstaben (wie original ADM-3, Data General model 6052 –, die auf eine 6053 mit einem Kleinbuchstaben-ROM aktualisiert werden konnten – und der Heathkit-Pin-Pinn 72 Spätere Modelle hatten manchmal zwei Zeichenbreiteneinstellungen. Einige Art von Cursor, die positioniert werden können (mit Pfeiltasten oder zu Hause und andere direkte Cursor Adresse Einstellung Codes). Durchführung von mindestens 3 Steuercodes: Carriage Return (Ctrl-M,) Line-Feed (Ctrl-J,) und Bell (Ctrl-G,) aber in der Regel viele mehr, wie Escape-Sequenzen, um Underlining, Dim oder Reverse-Video-Zeichen-Highlighting bieten, und vor allem, um das Display und die Position des Cursors zu löschen. Die experimentelle Ära serieller Bildschirme gipfelte 1978 mit dem VT100. Anfang der 80er Jahre gab es Dutzende von Terminalherstellern, darunter Lear-Siegler, ADDS, Data General, DEC, Hazeltine Corporation, Heath/Zenith, Hewlett Packard, IBM, Televideo, Volker-Craig und Wyse, von denen viele unvereinbare Befehlssequenzen hatten (obwohl viele den frühen ADM-3 als Ausgangspunkt benutzten). Die großen Variationen der Steuercodes zwischen Herstellern ergaben Software, die identifizierte und gruppierte Terminaltypen, so dass die Systemsoftware Eingabeformulare mit den entsprechenden Steuercodes korrekt anzeigen würde; In Unix-ähnlichen Systemen würden die Termcap- oder Terminfo-Dateien, das Stty-Dienstprogramm und die TERM-Umgebungsvariable verwendet werden; in der Data General Business BASIC-Software würde zum Beispiel zu Anmeldezeitpunkt eine Reihe von Codes an das Terminal gesendet werden, um zu versuchen, die Curs zu lesen Die große Mehrheit der Terminals waren monochrom, Hersteller bieten verschiedene grüne, weiße oder Bernstein und manchmal blaue Bildschirm Leuchtstoffe. (Amber wurde behauptet, die Augenspannung zu reduzieren). Terminals mit bescheidener Farbfähigkeit waren auch verfügbar, aber nicht weit verbreitet; zum Beispiel eine Farbversion des beliebten Wyse WY50, der WY350, bot 64 Schattierungen auf jeder Zeichenzelle. Die Bildschirme wurden schließlich von den meisten Anwendungen durch vernetzte Personalcomputer verschoben, zunächst langsam nach 1985 und mit zunehmender Geschwindigkeit in den 1990er Jahren. Sie hatten jedoch einen dauerhaften Einfluss auf PCs. Das Keyboard-Layout des VT220-Terminals beeinflusste das Modell M, das ab 1985 auf IBM-PCs ausgeliefert wurde, und durch das alle späteren Computertastaturen. Da die Kathodenstrahlröhren nach dem Jahr 2000 durch Flatscreen ersetzt wurden, war das Hardware-Computer-Endgerät veraltet. Intelligente Terminals Ein intelligentes Terminal hat seine eigene Verarbeitung, in der Regel bedeutet, dass ein Mikroprozessor eingebaut wird, aber nicht alle Terminals mit Mikroprozessoren taten eine reale Verarbeitung des Eingangs: der Hauptrechner, an dem es befestigt wurde, müsste schnell auf jeden Tastendruck reagieren. Der Begriff intelligent in diesem Zusammenhang stammt aus 1969. Bemerkenswerte Beispiele sind der IBM 2250, der Vorgänger der IBM 3250 und IBM 5080, und IBM 2260, Vorgänger des IBM 3270, der 1964 mit System/360 eingeführt wurde. Die meisten Terminals waren mit Minicomputern oder Mainframe-Computern verbunden und hatten oft einen grünen oder Bernstein Bildschirm. Typischerweise kommunizieren Endgeräte mit dem Computer über einen seriellen Port über ein Nullmodem-Kabel, häufig mit einem EIA RS-232 oder RS-422 oder RS-423 oder einer aktuellen Schleifen-Serienschnittstelle. IBM-Systeme, die typischerweise über einen Bus- und Tag-Kanal kommuniziert wurden, ein Koaxialkabel mit einem proprietären Protokoll, eine Kommunikationsverbindung mit Binary Synchronous Communications oder IBM SNA-Protokoll, aber für viele DEC, Data General und NCR (und so weiter) Computer gab es viele visuelle Display-Lieferanten, die gegen den Computerhersteller für Terminals zur Erweiterung der Systeme konkurrieren. Tatsächlich wurde das Instruktionsdesign für den Intel 8008 ursprünglich als Prozessor für den Datapoint 2200 bei der Computer Terminal Corporation konzipiert. Von der Einführung des IBM 3270 und der DEC VT100 (1978) konnten der Benutzer und Programmierer erhebliche Vorteile bei der Verbesserung der VDU-Technologie bemerken, aber nicht alle Programmierer nutzten die Merkmale der neuen Endgeräte (Backward-Kompatibilität in den VT100 und später Televideo-Terminals, zum Beispiel mit "dumb terminals" erlaubt Programmierern weiterhin ältere Software zu verwenden). Einige Dumm-Terminals waren in der Lage, auf einige Escape-Sequenzen zu reagieren, ohne Mikroprozessoren zu benötigen: Sie benutzten mehrere Leiterplatten mit vielen integrierten Schaltungen; der einzige Faktor, der ein Terminal als intelligent eingestuft war, war seine Fähigkeit, Benutzer-Eingabe innerhalb des Terminals zu verarbeiten - nicht den Hauptrechner an jedem Tastenfeld zu unterbrechen - und einen Datenblock zu einem Zeitpunkt zu senden (zum Beispiel: wenn der Benutzer ein ganzes Feld oder Form beendet hat). Die meisten Terminals in den frühen 1980er Jahren, wie ADM-3A, TVI912, Data General D2, DEC VT52, trotz der Einführung von ANSI-Terminals im Jahr 1978, waren im Wesentlichen dumm Terminals, obwohl einige von ihnen (wie die späteren ADM und TVI-Modelle) eine primitive Block-Send-Fähigkeit. Häufige frühe Verwendungen der lokalen Verarbeitungsleistung beinhaltete Funktionen, die wenig zu tun hatten mit Offload-Datenverarbeitung von dem Host-Computer, aber hinzugefügt nützliche Funktionen wie Drucken auf einen lokalen Drucker, gepufferte serielle Datenübertragung und serielle Handshaking (für höhere serielle Übertragungsgeschwindigkeiten), und anspruchsvollere Charakter-Attribute für das Display, sowie die Möglichkeit, Emulationsmodi zu mimic-Konkurrenten-Modellen, die zunehmend wichtige Verkaufsfunktionen in den 1980er zu mischen. Der Vorschub in Mikroprozessoren und geringere Speicherkosten ermöglichten es dem Endgerät, Bearbeitungsvorgänge wie das Einfügen von Zeichen in ein Feld zu handhaben, das zuvor eine vollständige Bildschirm-Füllung von Zeichen vom Computer, möglicherweise über eine langsame Modem-Linie, wiedergeben musste. Rund um die Mitte der 1980er-Jahre intelligentesten Terminals, die weniger als die meisten dummen Terminals hätte ein paar Jahre früher, könnte genug benutzerfreundliche lokale Bearbeitung von Daten und senden Sie das fertige Formular an den Hauptrechner. Mit noch mehr Verarbeitungsmöglichkeiten könnten Workstations wie das Televideo TS-800 CP/M-86 ausführen und die Unterscheidung zwischen Terminal und Personal Computer verschärfen. Eine weitere Motivation für die Entwicklung des Mikroprozessors war, die in einem Terminal benötigte Elektronik zu vereinfachen und zu reduzieren. Das machte es auch praktikabel, mehrere Persönlichkeiten in ein einziges Terminal zu laden, so dass ein Qume QVT-102 viele beliebte Terminals des Tages emulieren konnte, und so in Organisationen verkauft werden, die keine Software-Änderungen machen wollten. Häufig emulierte Terminaltypen enthalten: Lear Siegler ADM-3A und spätere Modelle Televideo 910 bis 950 (diese Modelle kopierten ADM3-Codes und fügten einige ihrer eigenen, schließlich von Qume kopiert und andere) Die Digital Equipment Corporation VT52 und VT100 Data General D1 bis D3 und insbesondere D200 und D210 Hazeltine Corporation H1500 Tektronix 4014Wyse W50, W60 und W99Die ANSI X3.64 Escape Code Standard produzierten Uniformität in gewissem Maße, aber erhebliche Unterschiede blieben. Zum Beispiel folgten die VT100, Heathkit H19 im ANSI-Modus, Televideo 970, Data General D460 und Qume QVT-108 Terminals alle dem ANSI-Standard, dennoch könnten Unterschiede in Codes aus Funktionstasten bestehen, welche Zeichen-Attribute zur Verfügung standen, die Felder innerhalb von Formularen, fremden Charaktereinrichtungen und die Handhabung von Druckern, die an der Rückseite des Bildschirms angeschlossen sind. 21. Jahrhundert Der Begriff Intelligent Terminal kann sich nun auf einen Speicher (Check-out) Computer beziehen. Zeitgenössisch Während frühen IBM-PCs einfarbige grüne Bildschirme hatten, waren diese Bildschirme nicht Terminals. Der Bildschirm eines PC enthielt keine Hardware zur Zeichenerzeugung; alle Videosignale und Videoformatierungen wurden von der Video-Display-Karte im PC oder (in den meisten Grafik-Modi) von der CPU und Software erzeugt. Ein IBM-PC-Monitor, sei es das grüne Monochrom-Display oder das 16-Farb-Display, war technisch wesentlich ähnlicher als ein analoges TV-Set (ohne Tuner) als ein Terminal. Bei geeigneter Software könnte jedoch ein PC ein Terminal emulieren, und in dieser Kapazität könnte es mit einem Mainframe oder Minicomputer verbunden werden. Der Datenschutzbeauftragte Man könnte von seinem ROM in den Terminal-Emulator-Modus booten. Letztendlich haben die mikroprozessorbasierten Personalcomputer den Marktbedarf für herkömmliche Endgeräte stark reduziert. In den 1990er Jahren haben vor allem "Däne Kunden" und X-Terminals wirtschaftliche lokale Verarbeitungsleistung mit zentralen, gemeinsamen Computereinrichtungen kombiniert, um einige der Vorteile von Terminals über Personalcomputer zu behalten: Heute bieten die meisten PC-Telnet-Clients eine Emulation des häufigsten Terminals, der DEC VT100, mit dem ANSI-Reitcode-Standard X3.64 oder könnte als X-Terminals mit Software wie Cygwin/X unter Microsoft Windows oder X.Org Server Software unter Linux laufen. Seit dem Aufkommen und anschließender Beliebtheit des Personalcomputers werden nur wenige echte Hardware-Endgeräte verwendet, um heute mit Computern zu kommunizieren. Mit dem Monitor und der Tastatur verfügen moderne Betriebssysteme wie Linux und die BSD-Derivate über virtuelle Konsolen, die meist unabhängig von der verwendeten Hardware sind. Bei der Verwendung einer grafischen Benutzeroberfläche (oder GUI) wie dem X Window System wird das Display typischerweise von einer Sammlung von Fenstern besetzt, die mit verschiedenen Anwendungen verbunden sind, anstatt von einem einzigen Textstrom, der einem einzigen Prozess zugeordnet ist. In diesem Fall kann innerhalb der Fensterumgebung eine Endgeräteemulatorapplikation verwendet werden. Diese Anordnung ermöglicht eine endständige Interaktion mit dem Computer (z.B. zum Führen eines Befehlszeilen-Interpreters), ohne dass ein physikalisches Endgerät benötigt wird; sie kann sogar mehrere Endgeräteemulatoren auf demselben Gerät ausführen. Fähigkeiten Charakterorientiertes Terminal Ein zeichenorientiertes Endgerät ist eine Art Computerterminal, das mit seinem Host ein Zeichen zu einer Zeit kommuniziert, im Gegensatz zu einem blockorientierten Endgerät, das in Datenblöcken kommuniziert. Es ist die häufigste Art von Datenterminal, weil es einfach zu implementieren und zu programmieren ist. Die Verbindung zum Mainframe-Computer oder Terminalserver erfolgt über RS-232 serielle Links, Ethernet oder andere proprietäre Protokolle. Textterminals Ein Textterminal oder oft nur Terminal (manchmal Textkonsole) ist eine serielle Computerschnittstelle für Texteingabe und -anzeige. Die Information wird als eine Reihe von vorgewählten Formzeichen dargestellt. Wenn solche Geräte eine Video-Anzeige wie eine Kathodenstrahlröhre verwenden, werden sie als "Video-Anzeigeeinheit" oder "visuelle Anzeigeeinheit" (VDU) oder "Video-Display-Anschluss" (VDT) bezeichnet. Die Systemkonsole ist oft ein Textterminal, mit dem ein Computer betrieben wird. Moderne Computer haben eine eingebaute Tastatur und Display für die Konsole. Einige Unix-ähnliche Betriebssysteme wie Linux und FreeBSD verfügen über virtuelle Konsolen, um mehrere Textterminals auf einem einzigen Computer bereitzustellen. Die grundsätzliche Art der Anwendung, die auf einem Textterminal läuft, ist ein Befehlszeilen-Interpreter oder eine Shell, die Befehle des Benutzers anfordert und jeden Befehl nach einer Presse von Return ausführt. Dazu gehören Unix Shells und einige interaktive Programmierumgebungen. In einer Shell sind die meisten Befehle kleine Anwendungen selbst. Ein weiterer wichtiger Anwendungstyp ist der Texteditor. Ein Texteditor nimmt typischerweise den gesamten Bereich des Displays ein, zeigt ein oder mehrere Textdokumente an und ermöglicht es dem Benutzer, die Dokumente zu bearbeiten. Der Texteditor wurde für viele Anwendungen durch den Textprozessor ersetzt, der in der Regel reiche Formatierungsfunktionen bietet, denen der Texteditor fehlt. Die ersten Word-Prozessoren nutzten Text, um die Struktur des Dokuments zu kommunizieren, aber später Word-Prozessoren arbeiten in einer grafischen Umgebung und bieten eine WYSIWYG-Simulation der formatierten Ausgabe. Jedoch werden Texteditoren noch für Dokumente verwendet, die Markup wie DocBook oder LaTeX enthalten. Programme wie Telix und Minicom steuern ein Modem und das lokale Terminal, um den Benutzer mit Remote-Servern interagieren zu lassen. Im Internet arbeiten Telnet und Ssh ähnlich. In der einfachsten Form ist ein Textterminal wie eine Datei. Das Schreiben in die Datei zeigt den Text und das Lesen aus der Datei produziert, was der Benutzer eingibt. In Unix-ähnlichen Betriebssystemen gibt es mehrere Charakter-Sonderdateien, die den verfügbaren Textterminals entsprechen. Für andere Operationen gibt es spezielle Escape-Sequenzen, Steuerzeichen und Termios-Funktionen, die ein Programm verwenden kann, am einfachsten über eine Bibliothek wie Ncurses. Für komplexere Operationen können die Programme terminspezifische ioctl-Systemanrufe verwenden. Für eine Anwendung ist der einfachste Weg, ein Terminal zu verwenden, einfach Textzeichenfolgen zu und von ihm sequentiell zu schreiben und zu lesen. Der Ausgabetext wird gerollt, so dass nur die letzten mehreren Zeilen (typisch 24) sichtbar sind. Unix-Systeme puffern typischerweise den Eingabetext, bis die Eingabetaste gedrückt wird, so dass die Anwendung eine fertige Zeichenfolge erhält. In diesem Modus muss die Anwendung nicht viel über das Terminal wissen. Für viele interaktive Anwendungen reicht dies nicht aus. Eine der häufigsten Verbesserungen ist die Befehlszeilenbearbeitung (unterstützt mit solchen Bibliotheken wie Readline;) es kann auch Zugriff auf die Befehlshistorie geben. Dies ist sehr hilfreich für verschiedene interaktive Befehlszeilen-Interpreter. Noch fortgeschrittenere Interaktivität ist mit Vollbildanwendungen ausgestattet. Diese Anwendungen steuern das Bildschirmlayout vollständig, sie reagieren auch sofort auf Tastendruck. Dieser Modus ist sehr nützlich für Texteditore, Dateimanager und Webbrowser. Darüber hinaus steuern solche Programme die Farbe und Helligkeit des Textes auf dem Bildschirm und dekorieren es mit unterstreichen, blinken und speziellen Zeichen (z.B. Box-Zeichnungszeichen). Um dies zu erreichen, muss die Anwendung nicht nur mit einfachen Textstrings, sondern auch mit Kontrollzeichen und Escape-Sequenzen umgehen, die es erlauben, den Cursor auf eine beliebige Position zu bewegen, Teile des Bildschirms zu löschen, Farben zu ändern und Sonderzeichen anzuzeigen, und auch auf Funktionstasten zu antworten. Das große Problem ist, dass es viele verschiedene Terminals und Terminal-Emulatoren gibt, die jeweils eine eigene Reihe von Fluchtsequenzen aufweisen. Um dies zu überwinden, wurden spezielle Bibliotheken (z.B. Curses) zusammen mit Terminalbeschreibungsdatenbanken wie Termcap und Terminfo erstellt. Dumb-Terminals Dumb-Terminals sind solche, die eine begrenzte Anzahl von Steuercodes (CR, LF, etc.) interpretieren können, haben aber nicht die Möglichkeit, spezielle Escape-Sequenzen zu verarbeiten, die Funktionen wie Clearing einer Zeile, Clearing des Bildschirms oder Controlling-Position ausführen. In diesem Zusammenhang werden manchmal Dumm-Terminals gegrabene Glas-Teletypen, denn sie haben im Wesentlichen die gleiche eingeschränkte Funktionalität wie ein mechanischer Teletyp.Diese Art von Dumm-Terminal wird immer noch auf modernen Unix-ähnlichen Systemen unterstützt, indem die Umgebungsvariable TERM zum Dummen gesetzt wird. Smarte oder intelligente Terminals sind solche, die auch die Möglichkeit haben, Escape-Sequenzen zu verarbeiten, insbesondere die VT52, VT100 oder ANSI Escape-Sequenzen. Grafische Endgeräte Ein grafisches Terminal kann sowohl Bilder als auch Text anzeigen. Grafische Terminals sind in Vektor-Mode-Endgeräte und Rastermodus unterteilt. Ein Vektor-Mode-Display zieht direkt Linien auf der Stirnseite einer Kathodenstrahlröhre unter Steuerung des Host-Computersystems. Die Leitungen werden kontinuierlich gebildet, aber da die Elektronikgeschwindigkeit begrenzt ist, ist die Anzahl der gleichzeitig darstellbaren Leitungen begrenzt. Vektor-Mode-Anzeigen waren historisch wichtig, werden aber nicht mehr verwendet. Praktisch alle modernen Grafik-Displays sind Rastermodus, von den für das Fernsehen verwendeten Bild-Scan-Techniken abgeleitet, in denen die visuellen Elemente eine rechteckige Reihe von Pixeln sind. Da das Rasterbild für eine sehr kurze Zeit nur für das menschliche Auge als Ganzes wahrnehmbar ist, muss der Raster viele Male pro Sekunde erfrischt werden, um das Aussehen einer persistenten Anzeige zu geben. Die elektronischen Anforderungen an den erfrischenden Anzeigespeicher bedeuteten, dass grafische Endgeräte viel später entwickelt wurden als Textterminals und zunächst viel mehr kosten. Die meisten Terminals sind heute grafisch, d.h. sie können Bilder auf dem Bildschirm anzeigen. Der moderne Begriff für grafisches Endgerät ist "dünner Client". Ein dünner Client verwendet typischerweise ein Protokoll wie X11 für Unix-Terminals oder RDP für Microsoft Windows. Die benötigte Bandbreite hängt vom verwendeten Protokoll, der Auflösung und der Farbtiefe ab. Moderne grafische Terminals ermöglichen die Darstellung von Bildern in Farbe und Text in unterschiedlichen Größen, Farben und Schriftarten (Typ Gesichter). Anfang der 1990er Jahre versuchte ein Industriekonsortium, einen Standard, AlphaWindows, zu definieren, der es einem einzigen CRT-Bildschirm ermöglichen würde, mehrere Fenster zu implementieren, von denen jeder als eindeutiges Terminal verhalten sollte. Unglücklicherweise wie I2O musste dies als geschlossener Standard ausgeführt werden: Nicht-Mitglieder konnten sogar minimale Informationen nicht erhalten und es gab keine realistische Art, wie ein kleines Unternehmen oder ein unabhängiger Entwickler dem Konsortium beitreten konnte. Möglicherweise verschwand der Standard ohne Spur. Emulation Ein Terminal-Emulator ist ein Stück Software, die ein Text-Endgerät emuliert. In der Vergangenheit, vor der weit verbreiteten Nutzung der lokalen Netzwerk-und Breitband-Internetzugang, würden viele Computer ein serielles Zugriffsprogramm verwenden, um mit anderen Computern über Telefonleitung oder serielle Gerät kommunizieren. Als der erste Macintosh veröffentlicht wurde, wurde ein Programm namens MacTerminal verwendet, um mit vielen Computern, einschließlich dem IBM PC zu kommunizieren. Dec Terminal war eines der ersten Terminal-Programme für den beliebten Altair. Die Win32-Konsole unter Windows emuliert nicht ein physisches Terminal, das Escape-Sequenzen unterstützt, so SSH und Telnet-Programme (für die Anmeldung in Text und Remote-Computern) für Windows, einschließlich des Telnet-Programms gebündelt mit einigen Versionen von Windows, oft einen eigenen Code, um Escape-Sequenzen zu verarbeiten. Die Terminal-Emulatoren auf den meisten Unix-ähnlichen Systemen - wie z.B. gnom-terminal, qterminal, xterm und Terminal. app-do emulieren physische Terminals einschließlich Unterstützung für Escape-Sequenzen; z.B. xterm kann die VT220 und Tektronix 4010 Hardware-Endgeräte emulieren. Modi Terminals können in verschiedenen Modi arbeiten, die sich darauf beziehen, wenn sie vom Benutzer auf der Tastatur eingegebene Eingabe an das Empfangssystem senden (was auch immer sein kann): Zeichenmodus (a.k.a.character-at-a-time mode): In diesem Modus wird die eingegebene Eingabe nicht gespeichert und sofort an das Empfangssystem gesendet. Zeilenmodus (a.k.a.line-at-a-time-Modus): In diesem Modus wird das Terminal gepuffert, bietet eine lokale Zeilenbearbeitungsfunktion, und sendet eine ganze Eingabezeile, nachdem es lokal bearbeitet wurde, wenn der Benutzer eine, z.B. ↓ Enter, EOB, Taste drückt. Ein sogenanntes "line mode terminal" arbeitet ausschließlich in diesem Modus. Blockmodus (a.k.a.screen-at-a-time Modus): In diesem Modus (auch blockorientiert genannt) wird das Terminal gepuffert und bietet eine lokale Vollbild-Datenfunktion. Der Benutzer kann Eingabe in mehrere Felder in einem Formular auf dem Bildschirm (definiert zum Terminal durch das empfangende System) bewegen den Cursor um den Bildschirm mit Schlüsseln wie Tab ↹ und die Pfeiltasten und die Ausführung von Bearbeitungsfunktionen lokal mit Insert, delete, ← Backspace und so weiter. Das Endgerät sendet nur das aus allen auf dem Bildschirm eingegebenen Daten bestehende, ausgefüllte Formular an das Empfangssystem, wenn der Benutzer eine ↓ Eingabetaste drückt. Es gibt eine Unterscheidung zwischen der Rückgabe und den Eingabetasten. In einigen Multimode-Terminals, die zwischen Modi wechseln können, drücken Sie die AUT Enter-Taste, wenn nicht im Blockmodus nicht das gleiche tut wie das Drücken der Rückgabetaste. Während die Rückgabetaste dazu führt, dass eine Eingabezeile im Zeilen-zu-ein-Zeit-Modus an den Host gesendet wird, die Eingabetaste wird vielmehr dazu führen, dass das Terminal den Inhalt der Zeichenzeile übermittelt, in der der Cursor aktuell auf die Host-, Host-Ausgabe-Prompte und alle positioniert ist. Einige Block-Mode-Terminals haben sowohl einen ⇒ Enter als auch einen lokalen Cursor bewegt Schlüssel wie Return und New Line. Unterschiedliche Computer-Betriebssysteme erfordern unterschiedliche Modenunterstützung, wenn Terminals als Computer-Endgeräte verwendet werden. Die POSIX-Endschnittstelle, wie sie von Unix und POSIX-konformen Betriebssystemen vorgesehen ist, nimmt überhaupt keine Block-Mode-Endgeräte auf und benötigt nur selten das Endgerät selbst im Line-A-Time-Modus, da das Betriebssystem zur Bereitstellung des canonischen Eingabemodus erforderlich ist, wo der Endgerätetreiber im Betriebssystem lokales Echo im Terminal emuliert und Leitungsbearbeitungsfunktionen am Host-Ende durchführt. Meistens, und vor allem, damit das Hostsystem nicht-kanonischen Eingabemodus unterstützen kann, sind Terminals für POSIX-konforme Systeme immer im Zeichen-A-Zeit-Modus. Im Gegensatz dazu sind IBM 3270 Terminals, die mit MVS-Systemen verbunden sind, immer im Blockmodus erforderlich. Blockorientiertes Terminal Ein blockorientiertes Endgerät ist eine Art Computerterminal, das mit seinem Host in Datenblöcken kommuniziert, im Gegensatz zu einem zeichenorientierten Endgerät, das mit seinem Host ein Zeichen zu einem Zeitpunkt kommuniziert. Ein blockorientiertes Endgerät kann kartenorientiert, bildorientiert, Tastatur-Display, Tastatur-Drucker, Drucker oder eine Kombination sein. Anzeige Die IBM 3270 ist vielleicht die bekannteste Implementierung eines blockorientierten Display-Terminals, aber die meisten Computerhersteller und mehrere andere Unternehmen produzierten sie. Die nachstehende Beschreibung bezieht sich auf die 3270, aber ähnliche Überlegungen gelten für andere Typen. Block-orientierte Terminals enthalten typischerweise einen Puffer, der einen Bildschirm oder mehrere Daten speichert, und speichert auch Datenattribute, nicht nur angezeigtes Aussehen (Farbe, Helligkeit, Blinken, etc.), sondern auch Markierungen der Daten, die vom Terminal-Operator vs. geschützt gegen Eintrag, als die Eingabe von nur numerischen Informationen vs. erlaubt, irgendwelche Zeichen, etc. In einer typischen Anwendung sendet der Host dem Endgerät ein vorformatiertes Panel, das sowohl statische Daten als auch Felder enthält, in die Daten eingegeben werden können. Die Terminaloperator-Schlüsseldaten, wie Updates in einem Datenbankeintrag, in die entsprechenden Felder. Wenn die Eingabe abgeschlossen ist (oder die Taste ENTER oder PF auf 3270s gedrückt), wird in der Regel nur die vom Betreiber eingegebenen Daten (modifizierte Daten) in einer Übertragung an den Host gesendet. Der 3270 Terminal-Puffer (im Gerät) konnte ggf. aufgrund des Vorliegens eines "Set-Puffer-Adressenauftrags" (SBA) auf einer einzigen Zeichenbasis aktualisiert werden, der in der Regel den zu schreibenden/zu überschreibenden Daten im Puffer vorausging. Ein kompletter Puffer kann auch mit dem Befehl READ BUFFER oder dem Befehl WRITE (unformatiert oder formatiert im Fall der 3270) gelesen oder ersetzt werden. Block-orientierte Terminals verursachen weniger Systembelastung des Hosts und weniger Netzwerkverkehr als zeichenorientierte Terminals. Sie wirken auch stärker auf den Benutzer, insbesondere über langsame Verbindungen, da die Bearbeitung innerhalb eines Feldes lokal statt je nach Echo aus dem Host-System erfolgt. Frühe Terminals hatten begrenzte Bearbeitungsmöglichkeiten – 3270 Terminals konnten beispielsweise nur Einträge als gültige Zahlen überprüfen. Anschließend integrierte intelligente oder intelligente Terminals Mikroprozessoren und unterstützte die lokale Verarbeitung. Programmierer von blockorientierten Endgeräten nutzten oft die Technik, Kontextinformationen für die laufende Transaktion auf dem Bildschirm zu speichern, möglicherweise in einem versteckten Feld, anstatt abhängig von einem laufenden Programm, um den Status zu verfolgen. Dies war der Vorläufer der HTML-Technik, Kontext in der URL zu speichern, als Daten als Argumente an ein CGI-Programm weitergegeben werden. Im Gegensatz zu einem zeichenorientierten Endgerät, bei dem das Eingeben eines Zeichens in die letzte Position des Bildschirms in der Regel dazu führt, dass das Endgerät eine Zeile nach unten scrollen kann, indem es auf einem blockorientierten Endgerät Daten in die letzte Bildschirmposition eingibt, bewirkt der Cursor gewöhnlich eine Umschlingung - zum Start des ersten eingebbaren Feldes. Programmierer können die letzte Bildschirmposition schützen, um unbeabsichtigte Verpackung zu verhindern. Ebenso könnte ein geschütztes Feld nach einem bestimmbaren Feld die Tastatur sperren und einen akustischen Alarm klingen, wenn der Bediener versuchte, mehr Daten in das Feld einzutragen als erlaubt. Gemeinsame blockorientierte Terminals Hard-copy IBM 1050 IBM 2740 Remote-Job-Eintrag IBM 2770 IBM 3770 IBM 3780 Display Siehe auch Hinweise Referenzen Externe Links Die Terminals Wiki, eine Enzyklopädie von Computerterminals. Text Terminal WIEDER Die TTY demystified Video Terminal Information on the Wayback Machine (archiviert 23. Mai 2010)Directive 1999/5/EG des Europäischen Parlaments und des Rates vom 9. März 1999 über Funkgeräte und Telekommunikationsendgeräte und die gegenseitige Anerkennung ihrer Konformität (R&TTE-Richtlinie) epocalc list of Computer Terminals