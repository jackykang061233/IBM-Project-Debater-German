Prolog ist eine logische Programmiersprache mit künstlicher Intelligenz und rechnerischen Linguistiken. Prolog hat seine Wurzeln in der First-Ordner-Logik, einer formalen Logik und im Gegensatz zu vielen anderen Programmiersprachen, Prolog ist in erster Linie als declarative Programmiersprache gedacht: Die Programmlogik wird in Bezug auf Beziehungen ausgedrückt, dargestellt als Fakten und Regeln. Eine Berechnung wird durch eine Abfrage über diese Beziehungen ausgelöst. Die Sprache wurde in Marseille, Frankreich, 1972 von Alain Colmerauer mit Philippe Roussel entwickelt und umgesetzt, basierend auf Robert Kowalskis verfahrensmäßiger Interpretation von Horn-Klausel. Prolog war eine der ersten logischen Programmiersprachen und bleibt die beliebteste solche Sprache heute, mit mehreren freien und kommerziellen Implementierungen zur Verfügung. Die Sprache wurde für Theorem-Proving, Experten-Systeme, Term-Rewriting, Typ-Systeme und automatisierte Planung, sowie sein ursprüngliches Verwendungszweck, natürliche Sprachverarbeitung verwendet. Moderne Prolog-Umgebungen unterstützen die Erstellung von grafischen Benutzeroberflächen sowie administrative und vernetzte Anwendungen. Prolog eignet sich gut für bestimmte Aufgaben, die von regelbasierten logischen Abfragen wie Suchdatenbanken, Sprachsteuerungssystemen und Füllvorlagen profitieren. Syntax und Semantik In Prolog wird die Programmlogik in Bezug auf die Beziehungen ausgedrückt, und eine Berechnung wird durch eine Abfrage über diese Beziehungen initiiert. Beziehungen und Abfragen werden mit Prologs Einzeldatentyp, dem Begriff, aufgebaut. Die Beziehungen sind durch Klauseln definiert. Bei einer Abfrage versucht die Prolog-Engine, eine Auflösungsrefutation der negierten Abfrage zu finden. Wenn die negierte Abfrage widerlegt werden kann, d.h. es wird eine Instantiation für alle freien Variablen gefunden, die die Verbindung von Klauseln und das Singleton-Set aus der negierten Abfrage falsch macht, so folgt, dass die ursprüngliche Abfrage mit der gefundenen Instantiation eine logische Folge des Programms ist. Dies macht Prolog (und andere logische Programmiersprachen) besonders nützlich für Datenbanken, symbolische Mathematik und Sprachparsing-Anwendungen. Da Prolog unreine Prädikate erlaubt, kann die Überprüfung des Wahrheitswerts bestimmter besonderer Prädikate einen bewussten Nebeneffekt haben, wie zum Beispiel das Drucken eines Wertes auf den Bildschirm. Aus diesem Grund ist es dem Programmierer erlaubt, einige Mengen an konventioneller zwingender Programmierung zu verwenden, wenn das logische Paradigma unbequem ist. Es hat eine rein logische Untermenge, genannt "pure Prolog", sowie eine Reihe von extralogischen Merkmalen. Datentypen Der einzelne Datentyp von Prolog ist der Begriff. Bedingungen sind entweder Atome, Zahlen, Variablen oder Verbindungsbegriffe. Ein Atom ist ein allgemeiner Name ohne inhärente Bedeutung. Beispiele für Atome sind x, rot, Taco und 'some atom'. Zahlen können Schwimmer oder ganze Zahlen sein. ISO-Standard-kompatible Prologsysteme können die Prolog-Flagge gebunden überprüfen". Die meisten der großen Prolog-Systeme unterstützen willkürliche Länge ganze Zahlen. Variablen werden durch einen String aus Buchstaben, Zahlen und Unterstrichzeichen bezeichnet, und beginnen mit einem Großbuchstaben oder Unterstrich. Variablen ähneln den Variablen in der Logik, dass sie Platzhalter für willkürliche Begriffe sind. Ein zusammengesetzter Begriff besteht aus einem Atom namens Functor und einer Reihe von Argumenten, die wiederum Begriffe sind. Die Begriffe der Verbindung werden gewöhnlich als Functor bezeichnet, gefolgt von einer in Klammern enthaltenen gemeinschaftsgetrennten Liste der Argumentbegriffe. Die Anzahl der Argumente wird als Arity bezeichnet. Ein Atom kann als Verbindungsbegriff mit Arität Null betrachtet werden. Ein Beispiel für einen Verbindungsbegriff ist person_friends(zelda,[tom,jim]). Sonderfälle der Begriffe: Eine Liste ist eine geordnete Sammlung von Bedingungen. Es wird durch quadratische Klammern mit den durch Kommas getrennten Begriffen oder im Falle der leeren Liste durch .][Zum Beispiel [1,2,3] oder [rot,grün,blau] bezeichnet. Strings: Eine Sequenz von Zeichen, die von Zitaten umgeben sind, entspricht entweder einer Liste von (numerischen) Zeichencodes, einer Liste von Zeichen (Atome der Länge 1,) oder einem Atom, je nach dem Wert der Prolog Flag double_quotes. Zum Beispiel "zu sein, oder nicht zu sein". ISO Prolog stellt das Atom/1, die Zahl/1, die ganze Zahl/1 und die Float/1-Prädikate für die Typkontrolle bereit. Regeln und Fakten Prolog-Programme beschreiben Beziehungen, definiert durch Klauseln. Pure Prolog ist auf Horn-Klausel beschränkt. Es gibt zwei Arten von Klauseln: Fakten und Regeln. Eine Regel ist von der Form und wird als "Leiter ist wahr, wenn der Körper wahr ist". Der Körper einer Regel besteht aus Aufrufen zu Prädikaten, die die Ziele der Regel genannt werden. Der eingebaute logische Operator ,/2 (d.h. ein Arity 2 Operator mit dem Namen ,) bezeichnet die Konjunktion von Zielen und /;2 die Disjunktion. Konjunktionen und Disjunktionen können nur im Körper auftreten, nicht im Kopf einer Regel. Klauseln mit leeren Körpern werden als Fakten bezeichnet. Ein Beispiel dafür ist: Das entspricht der Regel: Das eingebaute Prädikat true/0 ist immer wahr. Angesichts der obigen Tatsache, kann man fragen: ist crookshanks eine Katze? Was sind Katzen? Klauseln mit Körpern werden als Regeln bezeichnet. Ein Beispiel für eine Regel ist: Wenn wir diese Regel hinzufügen und fragen, was die Dinge sind Tiere? Aufgrund der relativen Natur vieler eingebauter Prädikate können sie typischerweise in mehreren Richtungen verwendet werden. Beispielsweise kann die Länge/2 verwendet werden, um die Länge einer Listenlänge (List, L,) bei einer Listenliste) zu bestimmen, sowie ein Listenskelett einer bestimmten Länge (X, 5) zu erzeugen und auch beide Listenskeletts und ihre Längen zusammen Länge (X, L.) zu erzeugen. In ähnlicher Weise kann append/3 sowohl verwendet werden, um zwei Listen anhängen (ListA, ListB, X) gegeben Listen ListA und ListB) als auch eine bestimmte Liste in Teile spalten append(X, Y, List,) bei einer Listenliste.) Aus diesem Grund genügt für viele Prolog-Programme eine vergleichsweise kleine Bibliothek. Als allgemeine Zielsprache bietet Prolog auch verschiedene integrierte Prädikate, um Routineaktivitäten wie Input/Output, Grafiken und anderweitige Kommunikation mit dem Betriebssystem durchzuführen. Diese Prädikate erhalten keine relationale Bedeutung und sind nur für die Nebenwirkungen, die sie auf dem System zeigen, nützlich. Beispielsweise zeigt das Prädikat schreiben/1 einen Begriff auf dem Bildschirm. Die Execution Execution eines Prolog-Programms wird durch die Buchung eines einzigen Ziels, die Abfrage genannt, initiiert. Logisch versucht die Prolog-Engine, eine Auflösungsrefutation der negierten Abfrage zu finden. Die von Prolog verwendete Auflösungsmethode wird als SLD-Auflösung bezeichnet. Kann die negierte Abfrage widerlegt werden, so folgt, dass die Abfrage mit den entsprechenden variablen Bindungen an Ort und Stelle eine logische Folge des Programms ist. In diesem Fall werden dem Benutzer alle generierten variablen Bindungen gemeldet, und die Abfrage soll erfolgreich sein. Operationell kann die Ausführungsstrategie von Prolog als Verallgemeinerung von Funktionsaufrufen in anderen Sprachen betrachtet werden, wobei ein Unterschied darin besteht, dass mehrere Klauselköpfe einem gegebenen Aufruf entsprechen können. In diesem Fall schafft das System einen Wahlpunkt, vereint das Ziel mit dem Klauselkopf der ersten Alternative und setzt sich mit den Zielen dieser ersten Alternative fort. Wenn ein Ziel im Zuge der Durchführung des Programms scheitert, werden alle variablen Bindungen, die seit dem letzten Wahlpunkt erstellt wurden, nicht gelöst und die Ausführung mit der nächsten Alternative dieses Wahlpunktes fortgesetzt. Diese Ausführungsstrategie wird als chronologische Rückverfolgung bezeichnet. Zum Beispiel: Dies führt dazu, dass folgende Abfrage als zutreffend ausgewertet wird: Dies ergibt sich wie folgt: Zunächst ist der einzige passende Klauselkopf für das Abfragegeschwister(sally, erica) der erste, so dass die Abfrage gleichwertig ist, um den Körper dieser Klausel mit den entsprechenden variablen Bindungen an Ort und Stelle zu belegen, d.h. die Verbindung parent_child(Z,sally) parent_child(Z,erica)). Das nächste Ziel ist das linkeste dieser Konjunktion, d.h. parent_child(Z, sally). Zwei Klauselköpfe passen zu diesem Ziel. Das System schafft einen Wahlpunkt und versucht die erste Alternative, deren Körper Vater_child(Z, sally) ist. Dieses Ziel kann anhand der Tatsache, Vater_Kind(tom, sally,) bewiesen werden, so dass die Bindung Z = tom erzeugt wird, und das nächste zu belegende Ziel ist der zweite Teil der obigen Konjunktion: parent_child(tom, erica). Dies kann wiederum durch die entsprechende Tatsache bewiesen werden. Da alle Ziele nachgewiesen werden konnten, gelingt die Abfrage. Da die Abfrage keine Variablen enthält, werden keine Bindungen an den Benutzer gemeldet. Eine Abfrage mit Variablen, wie: numeriert alle gültigen Antworten auf Backtracking. Beachten Sie, dass mit dem oben genannten Code die Abfrage ?-sibling(sally, sally) auch erfolgreich ist. Man würde zusätzliche Ziele einfügen, um die relevanten Einschränkungen zu beschreiben, wenn gewünscht. Loops und Recursion Iterative Algorithmen können mittels rekursiver Prädikate implementiert werden. Verhandlungen Das eingebaute Prolog-Prädikat \+/1 sorgt für Negation als Ausfall, was eine nicht-monotonische Argumentation ermöglicht. Das Ziel \+ illegal(X) in der Regel wird wie folgt bewertet: Prolog versucht illegal zu beweisen(X). Wenn ein Beweis für dieses Ziel gefunden werden kann, scheitert das ursprüngliche Ziel (d.h. \+ illegal(X). Wenn kein Beweis gefunden werden kann, gelingt das ursprüngliche Ziel. Daher wird der \+/1-Präfixoperator als "nicht nachweisbar" Operator bezeichnet, da die Abfrage ?- \+ Goal.succeeds, wenn Goal nicht nachweisbar ist. Diese Art von Negation ist klingen, wenn ihr Argument zugrunde liegt (d.h. keine Variablen enthält). Die Klanglichkeit geht verloren, wenn das Argument Variablen enthält und das Beweisverfahren abgeschlossen ist. Insbesondere die Abfrage ?- legal(X). jetzt kann nicht verwendet werden, um alle Dinge aufzuzählen, die legal sind. Programmierung in Prolog In Prolog, Ladecode wird als Beratung bezeichnet. Prolog kann interaktiv verwendet werden, indem Sie Abfragen in der Prolog-Prompt eingeben ?-. Wenn es keine Lösung gibt, schreibt Prolog nein. Ist eine Lösung vorhanden, so wird sie gedruckt. Wenn es mehrere Lösungen für die Abfrage gibt, können diese durch Eingabe eines Semikolons angefordert werden. Es gibt Leitlinien für eine gute Programmierpraxis, um die Codeeffizienz, Lesbarkeit und Aufrechterhaltungsfähigkeit zu verbessern. Hier folgen einige Beispielprogramme in Prolog geschrieben. Hallo Welt Ein Beispiel für eine Abfrage: Compiler-Optimierung Jede Berechnung kann als Folge von Zustandsübergängen deklarativ ausgedrückt werden. Als Beispiel könnte ein optimisierender Compiler mit drei Optimierungsdurchläufen als Relation zwischen einem Anfangsprogramm und seiner optimierten Form realisiert werden: oder gleichwertig mit DCG-Notation: Schnellsortierung Der Schnellsortieralgorithmus, der eine Liste seiner sortierten Version enthält: Muster Ein Design-Muster ist eine allgemeine wiederverwendbare Lösung für ein häufig auftretendes Problem in der Software-Design. Einige Design-Muster in Prolog sind Skeletts, Techniken, Klischees, Programm-Schemata, Logik-Beschreibung Schemata und höhere Auftrags-Programmierung. Programmierung der höheren Ordnung Ein höherrangiges Prädikat ist ein Prädikat, das eine oder mehrere andere Prädikate als Argumente nimmt. Obwohl die Unterstützung für die Programmierung von höherer Ordnung Prolog außerhalb der Domäne der Logik der ersten Ordnung, die keine Quantifizierung über Prädikate erlaubt, ISO Prolog hat nun einige eingebaute höherwertige Prädikate wie Call/1, Call/2, Call/3, Findall/3, Setof/3 und Bagof/3. Darüber hinaus, da willkürliche Prolog-Ziele zu Laufzeiten aufgebaut und ausgewertet werden können, ist es einfach, höherwertige Prädikate wie die Maplist/2 zu schreiben, die jedem Mitglied einer bestimmten Liste ein willkürliches Prädikat anwendet, und die Subliste/3, die Elemente filtert, die ein vorgegebenes Prädikat erfüllen, auch das Currying erlauben. Um Lösungen aus der zeitlichen Darstellung (Swer-Substitutionen auf Backtracking) in die räumliche Darstellung (Termine) umzuwandeln, hat Prolog verschiedene All-Lösungen, die alle Antwortsubstitutionen einer bestimmten Abfrage in einer Liste erfassen. Dies kann für Listenverständnis verwendet werden. Zum Beispiel, perfekte Zahlen gleich der Summe ihrer richtigen Divisors: Dies kann verwendet werden, um perfekte Zahlen aufzuzählen, und auch zu überprüfen, ob eine Zahl perfekt ist. Als weiteres Beispiel wendet die Prädikat-Kartenliste ein Prädikat P an alle entsprechenden Positionen in einem Paar Listen an: Wenn P ein Prädikat ist, dass für alle X, P(X,Y) Y mit einem einzigen eindeutigen Wert, Maplist(P, Xs, Ys) entspricht, um die Kartenfunktion in der funktionellen Programmierung als Ys = map(Funktion, Xs) anzuwenden. Der Programmierstil in Prolog wurde in HiLog und λProlog Pionier. Module Für die Programmierung im Großen bietet Prolog ein Modulsystem. Das Modulsystem wird nach ISO standardisiert. Nicht alle Prolog-Compiler unterstützen Module, und es gibt Kompatibilitätsprobleme zwischen den Modulsystemen der großen Prolog-Compiler. Daher werden auf einem Prolog-Compiler geschriebene Module nicht unbedingt an anderen arbeiten. Parfums Es gibt eine spezielle Notation genannt bestimmte Klausel Grammatik (DCGs). Eine über >/-2 definierte Regel anstelle von /-:2 wird durch den Vorprozessor (expand_term/2, eine Anlage analog zu Makros in anderen Sprachen) nach einigen einfachen Umschreiben Regeln erweitert, was zu normalen Prolog-Klausel führt. Insbesondere rüstet das Rewriting das Prädikat mit zwei zusätzlichen Argumenten aus, die verwendet werden können, um implizit Zustand um, analog zu Monaden in anderen Sprachen. DCGs werden häufig verwendet, um Parser oder Listengeneratoren zu schreiben, da sie auch eine bequeme Schnittstelle zu Differenzlisten bieten. Meta-Interpreter und Reflexion Prolog ist eine homoiconic Sprache und bietet viele Möglichkeiten zur Reflexion. Die implizite Ausführungsstrategie ermöglicht es, einen präzisen Meta-Circular-Evaluator (auch Meta-Interpreter genannt) für den reinen Prolog-Code zu schreiben: Wo wahr eine leere Konjunktion darstellt, und Klausel(Leiter, Körper) mit Klauseln in der Datenbank des Formulars Head:- Körper. Da Prolog-Programme selbst Sequenzen von Prolog-Bedingungen sind (/-:2 ist ein Infix-Operator), die mit eingebauten Mechanismen (wie read/1,) leicht gelesen und inspiziert werden können, können kundenspezifische Dolmetscher geschrieben werden, die Prolog mit Domänen-spezifischen Features augmentieren. Zum Beispiel präsentieren Sterling und Shapiro einen Meta-Interpreter, der Argumentation mit Unsicherheit durchführt, hier mit leichten Modifikationen wiedergegeben: Dieser Dolmetscher verwendet eine Tabelle aus eingebauten Prolog-Prädikaten der Form und Klauseln, die als Klausel_cf(Leit, Körper, Gewissheit) dargestellt sind. Bei diesen kann es als Solvabilität (Goal, Bestimmtheit) bezeichnet werden, um Goal auszuführen und ein Maß an Sicherheit über das Ergebnis zu erhalten. Turing Vollständigkeit Pure Prolog basiert auf einer Untermenge von erstklassiger Prädikatlogik, Horn Klauseln, die Turing-complete. Turing Vollständigkeit von Prolog kann gezeigt werden, indem es eine Turing-Maschine simulieren: Ein einfaches Beispiel Turing Maschine wird durch die Tatsachen angegeben: Diese Maschine führt Inkrementierung um eine von einer Nummer in der unary Codierung: Es schleift über eine beliebige Anzahl von 1 Zellen und legt eine zusätzliche 1 am Ende an. Beispielabfrage und Ergebnis: Dies zeigt, wie jede Berechnung deklarativ als Folge von Staatsübergängen ausgedrückt werden kann, die in Prolog als Relation zwischen aufeinanderfolgenden interessierenden Zuständen umgesetzt werden. Implementierung ISO Prolog Die ISO Prolog-Norm besteht aus zwei Teilen. ISO/IEC 13211-1, 1995 veröffentlicht, zielt darauf ab, die bestehenden Praktiken der vielen Implementierungen der Kernelemente von Prolog zu standardisieren. Es hat klargestellte Aspekte der Sprache, die zuvor mehrdeutig waren und zu tragbaren Programmen führt. Es gibt drei Korrigenda: Cor.1:2007, Cor.2:2012 und Cor.3:2017.ISO/IEC 13211-2, veröffentlicht im Jahr 2000, fügt Unterstützung für Module zur Norm hinzu. Die Norm wird von der Arbeitsgruppe ISO/IEC JTC1/SC22/WG17 eingehalten. ANSI X3J17 ist die US Technical Advisory Group für den Standard. Erstellung Für die Effizienz wird Prolog-Code in der Regel zu abstrakten Maschinencode kompiliert, oft beeinflusst von dem Register-basierten Warren Abstract Machine (WAM) Befehlssatz. Einige Implementierungen verwenden abstrakte Interpretation, um Typ- und Modusinformationen von Prädikaten zu kompilieren Zeit, oder kompilieren zu realen Maschinencode für hohe Leistung. Die Entwicklung effizienter Implementierungsmethoden für Prolog-Code ist ein Bereich der aktiven Forschung in der Logik-Programmiergemeinschaft, und verschiedene andere Ausführungsmethoden werden in einigen Implementierungen eingesetzt. Dazu gehören Klausel binarization und stapelbasierte virtuelle Maschinen. Tail-Recursion Prolog-Systeme implementieren typischerweise ein bekanntes Optimierungsverfahren namens "Tail Call Optimation (TCO) für deterministische Prädikate mit Schwanzrekursion oder, allgemeiner, Endanrufe: Der Stapelrahmen einer Klausel wird verworfen, bevor er einen Anruf in einer Endposition durchführt. Daher werden deterministische schwanzrekursive Prädikate mit konstantem Stapelraum, wie Schlaufen in anderen Sprachen, ausgeführt. Term-Indexing Finding-Klausel, die mit einem Begriff in einer Abfrage nicht bestimmbar sind, ist linear in der Anzahl der Klauseln. Term-Indexing verwendet eine Datenstruktur, die Sub-Linear-Time-Ups ermöglicht. Die Indexierung beeinflusst nur die Programmleistung, sie beeinflusst nicht die Semantik. Die meisten Prologs verwenden nur die Indexierung auf den ersten Begriff, da die Indexierung aller Begriffe teuer ist, aber Techniken auf Basis von feldcodierten Wörtern oder überlagerten Codeworten bieten schnelle Indexierung über die volle Abfrage und den Kopf. Hashing Einige Prolog-Systeme, wie WIN-PROLOG und SWI-Prolog, implementieren jetzt Hashing, um große Datensätze effizienter zu handhaben. Dies neigt dazu, sehr große Leistungsgewinne bei der Arbeit mit großen Unternehmen wie WordNet zu liefern. Tabling Einige Prolog-Systeme (B-Prolog, XSB, SWI-Prolog, YAP und Ciao) implementieren eine Memoization-Methode namens Tabling, die den Benutzer von der manuellen Speicherung von Zwischenergebnissen befreit. Tabling ist ein Raum-Zeit-Austausch; Ausführungszeit kann durch mehr Speicher reduziert werden, um Zwischenergebnisse zu speichern: Die in einer Abfrageauswertung auftretenden Subgoals werden in einer Tabelle zusammen mit Antworten auf diese Subgoals beibehalten. Wird ein Subgoal re-encountered, verwendet die Auswertung wieder Informationen aus der Tabelle, anstatt die Auflösung gegen Programmklauseln wiederzuerkennen. Die Tabling kann in verschiedene Richtungen verlängert werden. Es kann rekursive Prädikate durch SLG-Resolution oder lineare Tabling unterstützen. Bei einem mehrgängigen Prolog-System können die Ergebnisse privat auf einen Faden gehalten oder unter allen Threads geteilt werden. Und im inkrementalen Tabulieren könnte die Tabulierung auf Änderungen reagieren. Implementierung in Hardware Im Rahmen des Computersystems der Fünften Generation wurden Versuche unternommen, Prolog in Hardware umzusetzen, um eine schnellere Ausführung mit dedizierten Architekturen zu erreichen. Darüber hinaus hat Prolog eine Reihe von Eigenschaften, die eine Beschleunigung durch parallele Ausführung ermöglichen können. Ein neuerer Ansatz war es, eingeschränkte Prolog-Programme auf ein feldprogrammierbares Gate-Array zu kompilieren. Schnelle Fortschritte bei der allgemeinen Hardware haben jedoch immer mehr spezialisierte Architekturen übernommen. Einschränkungen Obwohl Prolog weit verbreitet in Forschung und Bildung verwendet wird, haben Prolog und andere logische Programmiersprachen keine signifikanten Auswirkungen auf die Computerindustrie im Allgemeinen. Die meisten Anwendungen sind nach industriellen Standards klein, mit weniger als 100.000 Zeilen Code. Die Programmierung im Großen gilt als kompliziert, da nicht alle Prolog-Compiler-Supportmodule unterstützt werden und es Kompatibilitätsprobleme zwischen den Modulsystemen der großen Prolog-Compiler gibt. Die Portabilität von Prolog-Code über die Implementierungen war auch ein Problem, aber die Entwicklungen seit 2007 bedeuteten: "Die Portabilität innerhalb der Familie von Edinburgh/Quintus abgeleitete Prolog-Implementierungen ist gut genug, um die Aufrechterhaltung von tragbaren real-world-Anwendungen zu ermöglichen. "Software, die in Prolog entwickelt wurde, wurde für eine hohe Leistungsstrafe im Vergleich zu herkömmlichen Programmiersprachen kritisiert. Insbesondere kann die nicht-deterministische Bewertungsstrategie von Prolog bei der Programmierung deterministischer Berechnungen problematisch sein, oder auch bei der Verwendung von "Nichts interessierender Nicht-Determinismus" (wobei eine einzige Wahl statt Rückverfolgung über alle Möglichkeiten getroffen wird). Schnitte und andere Sprachkonstrukte müssen verwendet werden, um eine wünschenswerte Leistung zu erreichen, eine der Hauptattraktionen von Prolog zu zerstören, die Fähigkeit, Programme "zurück und nach vorne" auszuführen. Prolog ist nicht rein deklarativ: Aufgrund von Konstrukten wie dem Schnittoperator ist eine Verfahrenslesung eines Prolog-Programms erforderlich, um es zu verstehen. Die Reihenfolge der Klauseln in einem Prolog-Programm ist von Bedeutung, da die Ausführungsstrategie der Sprache davon abhängt. Andere logische Programmiersprachen, wie Datalog, sind wirklich deklarativ, aber beschränken die Sprache.Infolgedessen werden viele praktische Prolog-Programme geschrieben, um sich an Prologs Tiefen-erste Suchauftrag anzupassen, anstatt als rein declarative Logik-Programme. Erweiterungen Verschiedene Implementierungen wurden von Prolog entwickelt, um Logik-Programmierungsfunktionen in zahlreiche Richtungen zu erweitern. Dazu gehören Typen, Modi, Kontraint-Logik-Programmierung (CLP,) objektorientierte Logik-Programmierung (OOLP,) Koncurrenz, lineare Logik (LLP,) funktionelle und übergeordnete Logik-Programmierungsfunktionen sowie Interoperabilität mit Wissensbasen: Types Prolog ist eine untypisierte Sprache. Versuche, Typen einzuführen, gehen zurück in die 1980er Jahre, und ab 2008 gibt es immer noch Versuche, Prolog mit Typen zu erweitern. Typinformationen sind nicht nur für die Typsicherheit nützlich, sondern auch aus Gründen der Prolog-Programme. Moden Die Syntax von Prolog gibt nicht an, welche Argumente eines Prädikats Eingaben sind und welche ausgegeben werden. Diese Informationen sind jedoch von Bedeutung und es wird empfohlen, sie in die Kommentare aufzunehmen. Moden liefern wertvolle Informationen bei der Begründung über Prolog-Programme und können auch verwendet werden, um die Ausführung zu beschleunigen. Constraints Constraint-Logik-Programmierung erweitert Prolog um Konzepte von konstraint Zufriedenheit. Ein strenges Logikprogramm erlaubt Zwänge im Körper von Klauseln, wie: A(X,Y) :- X+Y>0. Sie eignet sich für große kombinatorische Optimierungsprobleme und eignet sich somit für Anwendungen in industriellen Einstellungen, wie z.B. automatisierte Zeit- und Produktionsplanung. Die meisten Prolog-Systeme versenden mit mindestens einem constraint Löser für endliche Domänen, und oft auch mit Lösern für andere Domänen wie rationale Zahlen. Objektorientierung Flora-2 ist ein objektorientiertes Wissensrepräsentations- und -vernunftungssystem basierend auf F-logic und beinhaltet HiLog, Transaction Logik und defeasible Argumentation. Logtalk ist eine objektorientierte Logik-Programmiersprache, die die meisten Prolog-Implementierungen als Back-End-Compiler verwenden kann. Als Mehr-Paradigm-Sprache umfasst sie Unterstützung für Prototypen und Klassen. Oblog ist eine kleine, tragbare, objektorientierte Erweiterung zu Prolog von Margaret McDougall von EdCAAD, University of Edinburgh. Objlog war eine rahmenbasierte Sprache, die Objekte und Prolog II von CNRS, Marseille, Frankreich kombiniert. Prolog+ wurde von Logic Programming Associates entwickelt und erstmals 1989 für MS-DOS PCs veröffentlicht. Unterstützung für andere Plattformen wurde hinzugefügt, und eine zweite Version wurde 1995 veröffentlicht. Ein Buch über Prolog+ von Chris Moss wurde 1994 von Addison-Wesley veröffentlicht. Visual Prolog ist eine multiparadigme Sprache mit Schnittstellen, Klassen, Implementierungen und Objektausdrücken. Graphics Prolog-Systeme, die eine Grafikbibliothek bereitstellen, sind SWI-Prolog, Visual Prolog, WIN-PROLOG und B-Prolog. Concurrency Prolog-MPI ist eine Open-Source-SWI-Prolog-Erweiterung für verteiltes Computing über das Message Passing Interface. Auch gibt es verschiedene gleichzeitige Prolog Programmiersprachen. Einige Prolog-Implementierungen, insbesondere Visual Prolog, SWI-Prolog und Ciao, unterstützen serverseitige Web-Programmierung mit Unterstützung für Web-Protokolle, HTML und XML. Es gibt auch Erweiterungen, um semantische Web-Formate wie RDF und OWL zu unterstützen. Prolog wurde auch als clientseitige Sprache vorgeschlagen. Zusätzlich unterstützt Visual Prolog JSON-RPC und Websockets. Adobe Flash Cedar ist ein freier und einfacher Prolog-Interpreter. Von Version 4 und über Cedar hat eine FCA (Flash Cedar App) Unterstützung. Dies bietet eine neue Plattform zur Programmierung in Prolog durch ActionScript. Andere F-logic erweitert Prolog mit Rahmen/Objekten zur Wissensdarstellung. Transaktionslogik erstreckt sich Prolog mit einer logischen Theorie der staatlich wechselnden Update-Operatoren. Es hat sowohl eine modelltheoretische als auch verfahrenstechnische Semantik. OW Prolog wurde erstellt, um Prologs fehlender Grafik und Schnittstelle zu beantworten. Schnittstellen zu anderen Sprachen Es gibt Frameworks, die zwischen Prolog und anderen Sprachen überbrücken können: Der LPA Intelligence Server ermöglicht die Einbettung von LPA Prolog für Windows innerhalb von C, C, # C,+ Java, VB, Delphi, .Net,Lua Python und anderen Sprachen. Es nutzt den dedizierten String-Datentyp, den LPA Prolog bietet Die Logic Server API ermöglicht sowohl die Erweiterung und Einbettung von Prolog in C, C,+ Java, VB, Delphi, .NET und jede Sprache/Umgebung, die eine .dll oder so nennen kann Es ist für Amzi implementiert! Prolog Amzi! Prolog + Logic Server, aber die API-Spezifikation kann für jede Implementierung zur Verfügung gestellt werden. JPL ist eine bi-direktionale Java Prolog-Brücke, die standardmäßig mit SWI-Prolog verschifft, so dass Java und Prolog einander anrufen (rekursiv) Es ist bekannt, eine gute Konkurrenzunterstützung zu haben und befindet sich unter aktiver Entwicklung. InterProlog, eine Programmierbibliotheksbrücke zwischen Java und Prolog, die bidirektionale Prädikat/Methode zwischen beiden Sprachen implementiert. Java-Objekte können in Prolog-Bedingungen abgebildet werden und umgekehrt. Ermöglicht die Entwicklung von GUIs und anderen Funktionalitäten in Java, während die logische Verarbeitung in der Prolog-Schicht bleibt. Unterstützt XSB, mit Unterstützung für SWI-Prolog und YAP für 2013 geplant. Prova bietet native Syntax-Integration mit Java, Agent Messaging und Reaktionsregeln. Prova positioniert sich als regelbasiertes Skripting (RBS)-System für Middleware. Die Sprache bricht neue Wege in der Kombination von zwingender und deklarativer Programmierung. PRODUKTE Eine einbettbare Prolog-Engine für Java. Es umfasst eine kleine IDE und ein paar Bibliotheken. GNU Prolog for Java ist eine Implementierung von ISO Prolog als Java-Bibliothek (gnu.prolog)Ciao bietet Schnittstellen zu C, C,+ Java und relationalen Datenbanken. C#-Prolog ist ein Prolog-Interpreter geschrieben in (managed) C#.Can leicht in C#-Programme integriert werden. Eigenschaften: zuverlässiger und ziemlich schneller Dolmetscher, Kommandozeilenschnittstelle, Windows-Interface, eingebaut DCG, XML-Prädikate, SQL-Prädikate, ausziehbar. Der vollständige Quellcode ist verfügbar, einschließlich eines Parser-Generators, der zum Hinzufügen von speziellen Zweckerweiterungen verwendet werden kann. Jekejeke Prolog API Archived 2019-12-15 auf der Wayback Machine bietet eng gekoppelte gleichzeitige Ein- und Ausrufmöglichkeiten zwischen Prolog und Java oder Android, mit der markierten Möglichkeit, individuelle Wissensbasisobjekte zu erstellen. Es kann verwendet werden, um den ISO Prolog Dolmetscher in Standalone, Applets, servlets, APKs, etc. einzubetten. Eine Warren Abstrakte Maschine für PHPA Prolog Compiler und Interpreter in PHP 5.3. Eine Bibliothek, die eigenständig oder im Rahmen von Symfony2.1 verwendet werden kann, die aus Stephan Buettchers Arbeit in Java übersetzt wurde, die gefunden werden kann [hier stefan.buettcher.org/cs/wam/index.html] tuProlog ist ein leichtes Prolog-System für verteilte Anwendungen und Infrastrukturen, das bewusst um einen minimalen Kern ausgelegt ist, entweder statisch oder dynamisch durch das Laden/Entladen von Bibliotheken von Prädikaten konfiguriert werden. tuProlog unterstützt native Multiparadigm-Programmierung und bietet ein sauberes, nahtloses Integrationsmodell zwischen Prolog und Mainstream objektorientierten Sprachen – nämlich Java, für tuProlog Java-Version und jede .NET-basierte Sprache (C,# F,.#) für tuProlog . NET-Version. Geschichte Der Name Prolog wurde von Philippe Roussel als Abkürzung für die Programmierung en logique (Französisch für die Programmierung in Logik) gewählt. Sie entstand um 1972 von Alain Colmerauer mit Philippe Roussel, basierend auf Robert Kowalskis verfahrensmäßiger Interpretation von Horn-Klausel. Sie wurde zum Teil durch den Wunsch motiviert, die Verwendung von Logik als deklarative Wissensrepräsentationssprache mit der in Nordamerika in den späten 1960er und frühen 1970er Jahren populären Verfahrensrepräsentation von Wissen zu vereinbaren. Laut Robert Kowalski wurde 1972 das erste Prolog-System von Colmerauer und Phillipe Roussel entwickelt. Die erste Umsetzung von Prolog war ein Dolmetscher in Fortran von Gerard Battani und Henri Meloni geschrieben. David H. D. Warren nahm diesen Dolmetscher nach Edinburgh, und dort ein alternatives Frontend, das kam, um die “Edinburgh Prolog” Syntax, die von den meisten modernen Implementierungen verwendet wurde, zu definieren. Warren hat auch den ersten Compiler für Prolog implementiert und in Zusammenarbeit mit Fernando Pereira das einflussreiche DEC-10 Prolog geschaffen. Warren verallgemeinerte später die Ideen hinter DEC-10 Prolog, um die Warren Abstract Maschine zu schaffen. Die europäischen KI-Forscher befürworteten Prolog, während die Amerikaner Lisp befürworteten und angeblich viele nationalistische Debatten über die Verdienste der Sprachen verursachten. Ein Großteil der modernen Entwicklung von Prolog stammt aus dem Impuls des Computer Systems der Fünften Generation (FGCS), das eine Variante von Prolog namens Kernel Language für sein erstes Betriebssystem entwickelt hat. Pure Prolog war ursprünglich auf die Verwendung eines Auflösungstheorems mit Horn-Klausel des Formulars beschränkt: H :- B1,... Bn. Die Anwendung des Theorem-provers behandelt solche Klauseln wie Verfahren: Zeigen / lösen H, zeigen / lösen B1 und... und Bn. Pure Prolog wurde bald erweitert, jedoch, um Negation als Fehler, in denen negative Bedingungen des Formulars nicht(Bi) gezeigt werden durch versuchen und nicht lösen die entsprechenden positiven Bedingungen Bi.Subsequente Erweiterungen von Prolog durch das ursprüngliche Team eingeführt constraint logics. Verwendung in der Industrie Prolog wurde in Watson verwendet. Watson nutzt die Software DeepQA von IBM und den Rahmen von Apache UIMA (Unstructured Information Management Architecture). Das System wurde in verschiedenen Sprachen geschrieben, darunter Java, C,+ und Prolog, und läuft auf dem Betriebssystem SUSE Linux Enterprise Server 11 unter Verwendung von Apache Hadoop Framework, um verteiltes Computing bereitzustellen. Prolog wird für Muster passend über natürliche Sprache Parse Bäume verwendet. Die Entwickler haben gesagt: "Wir benötigten eine Sprache, in der wir Musteranpassungsregeln über die Parse-Bäume und andere Anmerkungen (z.B. Namenserkennungsergebnisse) und eine Technologie, die diese Regeln sehr effizient ausführen könnte, günstig ausdrücken konnten. Wir fanden heraus, dass Prolog aufgrund seiner Einfachheit und Ausdruckskraft die ideale Wahl für die Sprache war." Prolog wird in der Low-Code Development Platform GeneXus verwendet, die sich um AI konzentriert. Open Source Graph Datenbank TerminusDB wird in prolog implementiert. TerminusDB ist für die kollaborative Erstellung und Heilung von Wissensgraphen konzipiert. Siehe auch Vergleich der Prolog-Implementierungen Logico-linguistische Modellierung. Eine Methode zum Aufbau eines wissensbasierten Systems, das Prolog verwendet. Antwort-Set-Programmierung. Ein vollständig deklarativer Ansatz für die logische Programmierung. Verein für Logikprogrammierung Weitere Sprachen Die Gödel-Sprache ist eine stark eingegebene Implementierung der gleichzeitigen konstraktiven Logikprogrammierung. Es ist auf SICStus Prolog gebaut. Visual Prolog, früher als PDC Prolog und Turbo Prolog bekannt, ist ein stark objektorientierter Dialekt von Prolog, der sich sehr von Standard Prolog unterscheidet. Als Turbo Prolog wurde es von Borland vermarktet, aber es wird nun von der dänischen FirmaPDC (Prolog Development Center) entwickelt und vermarktet, die es ursprünglich produziert. Datalog ist eine Untergruppe von Prolog. Es ist auf Beziehungen beschränkt, die stratifiziert werden können und keine zusammengesetzten Begriffe zulassen. Im Gegensatz zu Prolog ist Datalog nicht Turing-complete. Mercury ist ein Ableger von Prolog in Richtung Software-Engineering im Großen mit einem statischen, polymorphen Typ System, sowie ein Modus- und Determinismussystem. GraphTalk ist eine proprietäre Umsetzung der Warren's Abstract Machine mit zusätzlichen objektorientierten Eigenschaften. In gewisser Weise ist Prolog eine Untergruppe von Planner. Die Ideen in Planner wurden später in der wissenschaftlichen Gemeinschaft Metaphor weiterentwickelt. AgentSpeak ist eine Variante von Prolog zum Programmierverhalten von Agenten in Multi-Agenten-Systemen. Erlang begann mit einer Prolog-basierten Implementierung das Leben und hält viel von Prologs einheitlicher Syntax. Pilog ist eine deklarative Sprache auf PicoLisp gebaut, die die Semantik von Prolog hat, aber die Syntax von Lisp verwendet. Referenzen =Weiterlesen ==