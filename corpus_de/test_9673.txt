In der Informatik ist Müllsammlung (GC) eine Form der automatischen Speicherverwaltung. Der Müllsammler versucht, das durch das Programm zugewiesene Gedächtnis zurückzugewinnen, wird aber nicht mehr als Müll bezeichnet. Müllsammlung wurde von dem amerikanischen Informatiker John McCarthy um 1959 erfunden, um das manuelle Speichermanagement in Lisp zu vereinfachen. Müllsammlung entlastet den Programmierer von der manuellen Speicherverwaltung, wo der Programmierer spezifiziert, welche Objekte zu behandeln und zurück in das Speichersystem und wann zu tun. Andere ähnliche Techniken umfassen Stapelzuweisung, Region Inference, Speichereigentum und Kombinationen von mehreren Techniken. Die Müllentnahme kann einen erheblichen Anteil der gesamten Verarbeitungszeit in einem Programm einnehmen und kann dadurch einen erheblichen Einfluss auf die Leistung haben. Andere Ressourcen als Speicher, wie Netzwerksteckdosen, Datenbankgriffe, Benutzerinteraktionsfenster, Datei- und Gerätedeskriptoren, werden in der Regel nicht von Müllsammlung behandelt. Methoden zur Verwaltung solcher Ressourcen, insbesondere Destruktoren, können ausreichen, um auch Speicher zu verwalten, ohne dass GC benötigt wird. Einige GC-Systeme erlauben es, dass solche anderen Ressourcen mit einem Speicherbereich verbunden werden, der, wenn sie gesammelt werden, die Arbeit verursacht, diese Ressourcen zurückzufordern. Grundsätze Die Grundprinzipien der Müllentnahme sind es, Datenobjekte in einem Programm zu finden, das in Zukunft nicht zugegriffen werden kann und die von diesen Objekten verwendeten Ressourcen wiederherzustellen. Viele Programmiersprachen erfordern Müllsammlung, entweder im Rahmen der Sprachspezifikation (z.B. Java, C, # D, Go und die meisten Scripting-Sprachen) oder effektiv für die praktische Umsetzung (z.B. formale Sprachen wie Lambda-Calculus); diese sollen Müll gesammelte Sprachen sein. Andere Sprachen wurden für die Verwendung mit manuellem Speichermanagement konzipiert, haben aber Müll-gesammelte Implementierungen zur Verfügung (z.B. C und C++). Einige Sprachen, wie Ada, Modula-3 und C++/CLI, ermöglichen sowohl die Müllsammlung als auch das manuelle Speichermanagement, in der gleichen Anwendung mit separaten Heaps für gesammelte und manuell verwaltete Objekte zusammenzuarbeiten; andere, wie D, sind Müllsammeln, ermöglichen es dem Benutzer, manuell Objekte zu löschen und auch die Müllsammlung vollständig zu deaktivieren, wenn Geschwindigkeit erforderlich ist. Während die Integration der Müllentnahme in das Compiler- und Laufzeitsystem der Sprache eine viel breitere Auswahl an Methoden ermöglicht, gibt es post-hoc GC-Systeme, wie Automatische Referenzzählung (ARC), einschließlich einiger, die keine Recompilation erfordern.(Post-hoc GC ist manchmal als Wurf-Sammlung unterschieden.) Der Müllsammler wird fast immer eng mit dem Speicherzuordnungsgerät integriert. Vorteile Die Müllsammlung befreit den Programmierer von der manuellen Verteilung des Speichers. Dies eliminiert oder reduziert einige Fehlerkategorien: Dangling Zeiger, die auftreten, wenn ein Stück Speicher frei ist, während es noch Zeiger darauf gibt, und einer dieser Zeiger wird abgeleitet. Bis dahin kann der Speicher einer anderen Verwendung mit unvorhersehbaren Ergebnissen wieder zugeordnet worden sein. Doppelte freie Fehler, die auftreten, wenn das Programm versucht, eine bereits freigegebene Speicherregion zu befreien, und vielleicht bereits wieder zugewiesen. Bestimmte Arten von Speicherlecks, in denen ein Programm nicht frei Speicher von Gegenständen besetzt, die unlösbar geworden sind, was zu Gedächtniserschöpfung führen kann. Nachteile Müllsammlung verbraucht Rechenressourcen bei der Entscheidung, welcher Speicher frei ist, obwohl der Programmierer diese Informationen bereits kennen kann. Die Strafe für die Bequemlichkeit, die Objektlebensdauer nicht manuell im Quellcode anzuzeigen, ist über Kopf, was zu einer verminderten oder ungleichmäßigen Leistung führen kann. Ein Peer-Reviewed-Papier von 2005 kam zu dem Schluss, dass GC fünfmal den Speicher benötigt, um diesen Overhead zu kompensieren und so schnell wie explizites Speichermanagement durchzuführen. Interaktion mit Speicherhierarchie-Effekten kann diese Überkopf untragbar machen, unter Umständen, die schwer vorherzusagen oder in Routinetests zu erkennen sind. Die Auswirkungen auf die Leistung wurde auch von Apple als Grund für die Annahme von Müllsammlung in iOS gegeben, obwohl es die gewünschte Funktion ist. Der Moment, in dem der Müll tatsächlich gesammelt wird, kann unvorhersehbar sein, was zu Ständen (Pausen zu verschieben/freiem Speicher) führt, die während einer Sitzung verstreut sind. Unvorhersehbare Stände können in Echtzeit-Umgebungen, in der Transaktionsverarbeitung oder in interaktiven Programmen inakzeptabel sein. Inkrementale, gleichzeitige und Echtzeit Müllsammler behandeln diese Probleme mit unterschiedlichen Abschlüssen. Strategien Tracing Tracing Müllsammlung ist die häufigste Art der Müllsammlung, so dass "Garbage-Sammlung" oft bezieht sich auf die Tracing Müllsammlung, anstatt andere Methoden wie Referenzzählung. Die Gesamtstrategie besteht darin, zu bestimmen, welche Objekte Müll gesammelt werden sollen, indem sie die Gegenstände durch eine Kette von Referenzen aus bestimmten Wurzelgegenständen erreichen und den Rest als Müll betrachten und sammeln. Es gibt jedoch eine Vielzahl von Algorithmen, die in der Implementierung verwendet werden, mit unterschiedlichen Komplexitäts- und Leistungsmerkmalen. Referenzzählung Referenzzählung Müllsammlung ist, wo jedes Objekt eine Anzahl von Referenzen darauf hat. Müll wird durch einen Referenzwert von Null identifiziert. Die Referenzzahl des Objekts wird erhöht, wenn eine Referenz auf ihn erstellt wird, und wenn eine Referenz zerstört wird. Wenn der Zählerstand Null erreicht, wird der Speicher des Objekts zurückgewonnen. Wie bei der manuellen Speicherverwaltung und im Gegensatz zu der Tracing Müll-Sammlung garantiert das Referenzzählen, dass Objekte zerstört werden, sobald ihre letzte Referenz zerstört wird, und greift in der Regel nur auf Speicher, der entweder in CPU-Caches, in freizuschaltenden Objekten oder direkt darauf gerichtet ist, und so tendiert dazu, keine signifikanten negativen Nebenwirkungen auf CPU-Cache und virtuellen Speicherbetrieb zu haben. Es gibt eine Reihe von Nachteilen bei der Referenzzählung, die in der Regel durch ausgefeilte Algorithmen gelöst oder gemildert werden kann: Zyklen Wenn sich zwei oder mehr Objekte zueinander beziehen, können sie einen Zyklus erstellen, bei dem weder als gegenseitige Referenzen gesammelt werden, die ihre Referenzzahlen nie Null werden lassen. Einige Müllentnahmesysteme mit Referenzzählung (wie die in CPython) verwenden bestimmte zyklussichere Algorithmen, um sich mit diesem Problem zu beschäftigen. Eine weitere Strategie ist es, schwache Referenzen für die Backpointer zu verwenden, die Zyklen erstellen. Unter Referenzzählung ist eine schwache Referenz ähnlich einer schwachen Referenz unter einem nachfahrenden Müllsammler. Es handelt sich um ein spezielles Referenzobjekt, dessen Existenz die Referenzzahl des Referenzobjekts nicht erhöht. Außerdem ist eine schwache Referenz sicher, indem bei Müll des Referenzobjekts keine schwache Referenz auf ihn verfällt, sondern es nicht erlaubt ist, dangling zu bleiben, was bedeutet, dass es sich zu einem vorhersehbaren Wert, wie einer Null-Bezug, verwandelt. Space Overhead (Referenzzählung)Referenzzählung erfordert Platz für jedes Objekt zugewiesen werden, um seine Referenzzählung zu speichern. Der Zählerstand kann neben dem Speicher des Objekts oder in einer Seitentabelle irgendwo anders gespeichert werden, aber in jedem Fall benötigt jedes einzelne Referenzzählobjekt zusätzlichen Speicher für seine Referenzzahl. Für diese Aufgabe wird üblicherweise Speicherplatz mit der Größe eines unbezeichneten Zeigers verwendet, so dass für jedes Objekt 32 oder 64 Bit Referenzzählspeicher zugeordnet werden müssen. Auf einigen Systemen kann es möglich sein, diesen Overhead zu mildern, indem ein markierter Zeiger verwendet wird, um die Referenzzahl in ungenutzten Bereichen des Speichers des Objekts zu speichern. Oft erlaubt eine Architektur tatsächlich nicht, dass Programme auf den vollen Bereich der Speicheradressen zugreifen, die in ihrer nativen Pointer-Größe gespeichert werden könnten; bestimmte Anzahl von hohen Bits in der Adresse wird entweder ignoriert oder benötigt, um Null zu sein. Hat ein Objekt zuverlässig an einer bestimmten Stelle einen Zeiger, kann der Referenzzähler in den ungenutzten Bits des Zeigers gespeichert werden. Zum Beispiel hat jedes Objekt in Ziel-C einen Zeiger seiner Klasse zu Beginn seines Speichers; auf der ARM64 Architektur mit iOS 7, 19 werden ungenutzte Bits dieses Klassenzeigers verwendet, um die Referenzzahl des Objekts zu speichern. Geschwindigkeit über Kopf (Inkrement/Dekrement) Bei naiven Implementierungen erfordern jede Zuordnung einer Referenz und jede Referenz, die aus dem Geltungsbereich fällt, oft Änderungen eines oder mehrerer Referenzzähler. Wird jedoch in einem gemeinsamen Fall eine Referenz von einer Außenumfangsgröße in eine Innenumfangsgröße kopiert, so dass die Lebensdauer der Innengröße durch die Lebensdauer der Außeneinheit begrenzt wird, kann die Referenzinkrementierung eliminiert werden. Die äußere Größe besitzt die Referenz. In der Programmiersprache C,+ wird diese Technik leicht umgesetzt und unter Verwendung von Konstreferenzen demonstriert. Die Referenzzählung in C+ wird in der Regel mit "Smart Pointers" durchgeführt, deren Konstrukteure, Destrukteure und Zuordnungsbetreiber die Referenzen verwalten. Ein intelligenter Zeiger kann unter Bezugnahme auf eine Funktion übergeben werden, die die Notwendigkeit vermeidet, einen neuen intelligenten Zeiger (der die Referenzzahl auf den Eintrag in die Funktion erhöhen würde und sie am Ausgang abnehmen würde). Vielmehr erhält die Funktion einen Hinweis auf den preiswerten Smart Pointer. Die Deutsch-Bobrow-Methode der Referenzzählung beruht auf der Tatsache, dass die meisten Referenzzählupdates tatsächlich durch in lokalen Variablen gespeicherte Referenzen erzeugt werden. Es ignoriert diese Referenzen, nur Zählen von Referenzen im Haufen, aber bevor ein Objekt mit Referenznummer Null gelöscht werden kann, muss das System mit einem Scan des Stapels überprüfen und Register, dass noch keine andere Referenz vorhanden ist. Ein weiterer wesentlicher Rückgang des Overheads bei Zähleraktualisierungen kann durch Aktualisierung der von Levanoni und Petrank eingeführten Koaleszenzen erreicht werden. Betrachten Sie einen Zeiger, dass in einem bestimmten Intervall der Ausführung mehrmals aktualisiert wird. Es zeigt zunächst auf ein Objekt O1, dann auf ein Objekt O2, und so weiter, bis es am Ende des Intervalls auf ein Objekt zeigt. Ein Referenzzählalgorithmus würde typischerweise rc(O1,-) rc(O2,+) rc(O2,-) rc(O3,+) rc(O3,-) ..., rc(On)++ ausführen. Aber die meisten dieser Updates sind redundant. Um die Referenzzahl am Ende des Intervalls richtig auswerten zu lassen, genügt es, rc(O1-) und rc(On)++ durchzuführen. Levanoni und Petrank haben eine Eliminierung von mehr als 99% der Zähler-Updates in typischen Java Benchmarks gemessen. Erfordert Atomität Diese Modifikationen (Erhöhung und Dekrement) müssen bei der Verwendung in einer mehrgängigen Umgebung atomare Operationen wie Vergleichs- und Swap sein, zumindest für alle Objekte, die geteilt werden, oder potenziell unter mehreren Threads geteilt werden. Atomoperationen sind auf einem Multiprozessor teuer und noch teurer, wenn sie mit Softwarealgorithmen emuliert werden müssen. Es ist möglich, dieses Problem zu vermeiden, indem per-Thread- oder per-CPU-Referenzzählungen hinzugefügt und nur auf die globale Referenzzahl zugegriffen wird, wenn die lokalen Referenzzählungen werden oder nicht mehr Null sind (oder alternativ, mit einem binären Baum von Referenzzählungen, oder sogar deterministische Zerstörung im Austausch für nicht mit einer globalen Referenzzahl überhaupt aufgeben), aber dies addiert signifikante Speicher-Operhead und damit tendiert nur in speziellen Fällen nützlich sein (es. Update-Koalescing von Levanoni und Petrank kann verwendet werden, um alle Atomoperationen aus dem Schreibbarriere zu eliminieren. Zähler werden bei der Programmausführung nie von den Programmfäden aktualisiert. Sie werden nur durch den Kollektor modifiziert, der als einziges zusätzliches Gewinde ohne Synchronisation ausführt. Dieses Verfahren kann als Stopp-the-world-Mechanismus für parallele Programme, sowie mit einem gleichzeitigen Referenzzähler verwendet werden. Nicht Echtzeit Naive Implementierungen der Referenzzählung liefern im Allgemeinen kein Echtzeit-Verhalten, da jede Pointerzuordnung möglicherweise dazu führen kann, dass eine Anzahl von Objekten, die nur durch die insgesamt zugeordnete Speichergröße gebunden sind, rekursiv freigegeben werden kann, während der Faden keine andere Arbeit ausführen kann. Es ist möglich, dieses Problem zu vermeiden, indem man das Freigeben von nicht referenzierten Objekten zu anderen Threads, zu den Kosten von extra Overhead. Escape-Analyse ist eine Compile-time-Technik, die Haufen-Zuweisungen in Stapel-Zuordnungen umwandeln kann, wodurch die Menge der Müllsammlung zu tun. Diese Analyse bestimmt, ob ein innerhalb einer Funktion zugewiesenes Objekt außerhalb davon zugänglich ist. Wird eine funktionslokale Zuordnung einer anderen Funktion oder einem Faden zugänglich gefunden, so soll die Zuordnung entweichen und kann nicht auf dem Stapel erfolgen. Andernfalls kann das Objekt direkt auf dem Stapel zugeordnet und freigegeben werden, wenn die Funktion zurückkehrt, der Haufen und die damit verbundenen Speicherverwaltungskosten umgehen. Verfügbarkeit Im Allgemeinen sind Programmiersprachen auf höherer Ebene wahrscheinlicher, dass Müllsammlung als Standardmerkmal. In einigen Sprachen, die nicht in Müllsammlung gebaut haben, kann es durch eine Bibliothek hinzugefügt werden, wie mit dem Boehm Müllsammler für C und C++. Die meisten funktionellen Programmiersprachen, wie ML, Haskell und APL, haben Müllsammlung eingebaut. Lisp ist besonders bemerkenswert als die erste funktionelle Programmiersprache und die erste Sprache, um Müllsammlung einzuführen. Andere dynamische Sprachen wie Ruby und Julia (aber nicht Perl 5 oder PHP vor Version 5.3, die beide Referenzzählen verwenden), neigen auch JavaScript und ECMAScript dazu, GC zu verwenden. Objektorientierte Programmiersprachen wie Smalltalk und Java bieten in der Regel eine integrierte Müllsammlung. Bemerkenswerte Ausnahmen sind C+ und Delphi, die Destruktoren haben. BASIC BASIC und Logo haben oft Müllsammlungen für längenvariable Datentypen wie Strings und Listen verwendet, um Programmierer nicht mit Speicherverwaltungsdetails zu belasten. Auf der Altair 8800 können Programme mit vielen String-Variablen und wenig String-Raum aufgrund der Müllsammlung lange Pausen verursachen. In ähnlicher Weise scannt der Applesoft BASIC-Interpreter Müllsammlungsalgorithmus wiederholt die String-Deskriptoren für den String mit der höchsten Adresse, um ihn in Richtung Hochspeicher zu verdichten, was zu O (n 2) {\displaystyle O(n^{2}) Leistung und Pausen von wenigen Sekunden bis ein paar Minuten führt. Ein Ersatz Müllsammler für Applesoft BASIC von Randy Wigginton identifiziert eine Gruppe von Strings in jedem Pass über den Haufen und reduziert die Sammelzeit drastisch. BASIC.System, das 1983 mit ProDOS veröffentlicht wurde, bietet einen fensternden Müllsammler für BASIC, der oft schneller ist. Ziel-CWhile die Ziel-C hatte traditionell keine Müllsammlung, mit der Veröffentlichung von OS X 10.5 im Jahr 2007 Apple eingeführt Müllsammlung für Ziel-C 2.0, mit einem hauseigenen entwickelten Laufzeitsammler. Mit der 2012 veröffentlichten OS X 10.8 wurde die Müllsammlung jedoch zugunsten des mit OS X 10.7 eingeführten automatischen Referenzzählers (ARC) von LLVM depreciert. Darüber hinaus seit Mai 2015 Apple verbietet sogar die Verwendung der Müllsammlung für neue OS X-Anwendungen im App Store. Für iOS wurde die Müllsammlung aufgrund von Problemen in der Anwendungsreaktion und -leistung nie eingeführt; stattdessen verwendet iOS ARC. Begrenzte Umgebungen Die Müllentnahme wird aufgrund der üblichen Notwendigkeit einer sehr engen Kontrolle über den Einsatz begrenzter Ressourcen selten auf eingebetteten oder Echtzeitsystemen eingesetzt. Allerdings wurden Müllsammler entwickelt, die mit vielen begrenzten Umgebungen kompatibel sind. Die Microsoft .NETMicro Framework, .NETnanoFramework und Java Platform, Micro Edition sind eingebettete Software-Plattformen, die, wie ihre größeren Cousins, Müllsammlung enthalten. Java Müllsammler in Java JDKs enthalten: G1 Parallel Gleichzeitiger Marken-Sweep-Kollektor (CMS) Serial C4 (Continuous Concurrent Compacting Collector)Shenandoah ZGC Compile-time-Nutzung Die Compile-time Müll-Sammlung ist eine Form der statischen Analyse, die es ermöglicht, den Speicher wiederverwendet und auf der Grundlage von bei der Zusammenstellung bekannten Invarianten wiederherzustellen. Diese Form der Müllsammlung wurde in der Programmiersprache Mercury untersucht, und es sah eine größere Nutzung mit der Einführung des automatischen Referenzzählers (ARC) von LLVM in Apples Ökosystem (iOS und OS X) im Jahr 2011. Echtzeitsysteme Es wurden zunehmende, gleichzeitige und Echtzeit-Gütesammler entwickelt, wie Bakers Algorithmus oder Liebermans Algorithmus. Im Bakers Algorithmus erfolgt die Zuordnung in einer Hälfte eines einzigen Speicherbereichs. Wenn es halb voll wird, wird eine Müllsammlung durchgeführt, die die lebenden Objekte in die andere Hälfte bewegt und die restlichen Objekte implizit behandelt. Das laufende Programm (der Mutator) muss überprüfen, ob jedes Objekt, das es referiert, in der richtigen Hälfte ist, und wenn es nicht quer bewegt wird, während eine Hintergrundaufgabe alle Objekte findet. Generelle Müllsammelsysteme basieren auf der empirischen Beobachtung, dass die meisten Objekte sterben jung. In der Generierungsmüllsammlung werden zwei oder mehr Zuordnungsregionen (Generationen) gehalten, die aufgrund des Alters des Objekts getrennt gehalten werden. Neue Objekte entstehen in der regelmäßig gesammelten jungen Generation, und wenn eine Generation voll ist, werden die Objekte, die noch von älteren Regionen referiert werden, in die nächste älteste Generation kopiert. Gelegentlich wird ein voller Scan durchgeführt. Einige hochrangige Computerarchitekturen umfassen Hardware-Unterstützung für die Echtzeit Müllsammlung. Die meisten Implementierungen von Echtzeit Müllsammlern verwenden Tracing. Solche Echtzeit Müllsammler erfüllen harte Echtzeit-Zwänge, wenn sie mit einem Echtzeit-Betriebssystem verwendet werden. Siehe auch Destructor (Computerprogrammierung)Dead-Code Eliminierung Smart Pointer Virtual Memory Kompression ReferenzenWeiter lesen Jones, Richard; Hosking, Antony; Moss, J. Eliot B. (2011-08-16). The Garbage Collection Handbuch: Die Kunst der automatischen Speicherverwaltung.CRC Angewandte Algorithmen und Datenstrukturen Serie. Chapman und Hall / CRC Presse / Taylor & Francis Ltd. ISBN 978-1-4200-8279-1.(511 Seiten)Jones, Richard; Lins, Rafael (1996-07-12). Müllsammlung: Algorithmen für automatisches dynamisches Speichermanagement (1 ed.). Wiley.ISBN 978-0-47194148-4.(404 Seiten)Schorr, Herbert; Waite, William M. (Aug 1967)."An Efficient Machine-Independent Procedure for Garbage Collection in Various List Structures" (PDF).Kommunikation der ACM.10 (8): 501–506. doi:10.1145/363534.363554.S2CID 5 Proceedings of the International Workshop on Memory Management (IWMM 92). Vortragshinweise in Informatik.Springer-Verlag.637: 1–42.CiteSeerX 10.1.1.47.2438.doi:10.1007/bfb0017182.ISBN 3-540-55940-X. Wilson, Paul R.; Johnstone, Mark S.; Neely, Michael; Boles, David (1995). " Dynamische Speicherzuweisung: Eine Umfrage und kritische Überprüfung". Proceedings of the International Workshop on Memory Management (IWMM 95). Vortragshinweise in Informatik (1 ed.).986: 1–116.CiteSeerX 10.1.1.47.275.doi:10.1007/3-540-60368-9_19.ISBN 978-3-540-60368-9. Externe Links The Memory Management ReferenceThe Very Basics of Garbage Collection Java SE 6 HotSpotTM Virtual Machine Garbage Collection Tuning TinyGC - eine unabhängige Implementierung der BoehmGC API Conservative Garbage Collection Implementierung für C Language MeixnerGC - eine inkrementelle Marke und Kehr Müllsammler für C+ mit intelligenten Zeigern