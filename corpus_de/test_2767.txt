Lisp (historisch LISP) ist eine Familie der Programmiersprachen mit einer langen Geschichte und einer unverwechselbaren, voll elterlichen Präfix-Notation. Ursprünglich im Jahr 1958 spezifiziert, Lisp ist die zweitälteste hochrangige Programmiersprache in weit verbreiteter Nutzung heute. Nur Fortran ist um ein Jahr älter. Lisp hat sich seit seinen frühen Tagen geändert, und viele Dialekte existierten über seine Geschichte. Heute sind die bekanntesten universellen Lisp Dialekte Racket, Common Lisp, Scheme und Clojure. Lisp wurde ursprünglich als praktische mathematische Notation für Computerprogramme erstellt, beeinflusst von (wenn auch nicht ursprünglich abgeleitet) der Notation von Alonzo Church's Lambda Calculus. Es wurde schnell die bevorzugte Programmiersprache für künstliche Intelligenz (KI) Forschung. Als eine der frühesten Programmiersprachen, Lisp Pionier zahlreiche Ideen in der Informatik, einschließlich Baumdatenstrukturen, automatische Speicherverwaltung, dynamische Typisierung, Conditionals, höherwertige Funktionen, Recursion, der selbst-hosting-Compiler, und die Lese-Eval-Druckschleife. Der Name LISP leitet sich von "LISt Processor" ab. Linked Listen sind eine der wichtigsten Datenstrukturen von Lisp und Lisp Quellcode ist aus Listen. So können Lisp-Programme Quellcode als Datenstruktur manipulieren, wodurch die Makrosysteme entstehen, die es Programmierern ermöglichen, neue Syntax oder neue Domänen-spezifische Sprachen zu erstellen, die in Lisp eingebettet sind. Die Austauschbarkeit von Code und Daten gibt Lisp seine sofort erkennbare Syntax. Alle Programmcodes werden als s-expressions oder elterliche Listen geschrieben. Ein Funktionsaufruf oder eine syntaktische Form wird als eine Liste mit dem Namen der Funktion oder des Betreibers und den folgenden Argumenten geschrieben; beispielsweise würde eine Funktion f, die drei Argumente einnimmt, als (f arg1 arg2 arg3) bezeichnet. Geschichte John McCarthy entwickelte Lisp 1958, während er am Massachusetts Institute of Technology (MIT) war. McCarthy veröffentlichte sein Design in einem Papier in Kommunikation der ACM 1960, mit dem Titel "Rekursive Funktionen von symbolischen Ausdrucksformen und ihre Computation von Machine, Teil I". Er zeigte, dass mit ein paar einfachen Operatoren und einer Notation für anonyme Funktionen aus der Kirche, kann man eine Turing-komplete Sprache für Algorithmen bauen. Information Processing Language war die erste KI-Sprache, von 1955 oder 1956, und beinhaltete bereits viele der Konzepte, wie z.B. List-Processing und Recursion, die in Lisp verwendet werden. McCarthys Original-Notation benutzte M-Expressionen, die in S-Expressionen übersetzt werden. Als Beispiel entspricht der M-Expressionswagen[cons[A,B] der S-Expression (Auto (cons A B)). Nachdem Lisp implementiert wurde, wählten Programmierer schnell S-Expressionen und M-Expressionen wurden aufgegeben. M-Expressionen wurden wieder mit kurzlebigen Versuchen von MLisp von Horace Enea und CGOL von Vaughan Prat. Lisp wurde zunächst von Steve Russell auf einem IBM 704 Computer mit gestanzten Karten implementiert. Russell hatte McCarthys Papier gelesen und realisiert (zu McCarthys Überraschung), dass die Lisp eval Funktion in Maschinencode implementiert werden könnte. Das Ergebnis war ein funktionierender Lisp-Interpreter, der verwendet werden konnte, um Lisp-Programme auszuführen, oder besser, "bewerten Sie Lisp-Ausdrücke". Zwei Gruppensprachen-Makros für den IBM 704 wurden zu den primitiven Operationen für die Dekompositionslisten: Auto (Contents of the Address part of Register number) und cdr (Contents of the Decrement part of Register number), wo Register auf Register der zentralen Verarbeitungseinheit des Computers (CPU) verweist. Lisp Dialekte verwenden immer noch Auto und cdr ( und ) für die Operationen, die den ersten Artikel in einer Liste bzw. den Rest der Liste zurückgeben. Der erste vollständige Lisp-Compiler, geschrieben in Lisp, wurde 1962 von Tim Hart und Mike Levin am MIT implementiert. Dieser Compiler stellte das Lisp-Modell der Inkrementalkompilation vor, in dem kompilierte und interpretierte Funktionen frei mischen können. Die in Hart und Levins Memo verwendete Sprache ist dem modernen Lisp-Stil viel näher als McCarthys früherer Code. Die ersten Müllentnahme-Routinen wurden von MIT-Absolvent Daniel Edwards entwickelt. In den 1980er und 1990er Jahren wurde große Anstrengungen unternommen, um die Arbeit an neuen Lisp Dialekten (meist Nachfolger von Maclisp wie ZetaLisp und NIL (Neue Umsetzung von Lisp) in eine einzige Sprache zu vereinen. Die neue Sprache, Common Lisp, war etwas kompatibel mit den Dialekten, die es ersetzt (das Buch Common Lisp die Sprache bemerkt die Kompatibilität der verschiedenen Konstrukte). 1994 veröffentlichte ANSI den Common Lisp-Standard "ANSI X3.226-1994 Informationstechnologie Programming Language Common Lisp."Timeline Verbindung zu künstlicher Intelligenz Seit Beginn war Lisp eng mit der Forschungsgemeinschaft künstlicher Intelligenz verbunden, vor allem auf PDP-10 Systemen. Lisp wurde als Umsetzung der Programmiersprache Micro Planner verwendet, die im berühmten KI-System SHRDLU verwendet wurde. In den 1970er Jahren, als die AI-Forschung kommerzielle Abhilfemaßnahmen hervorbrachte, wurde die Leistung bestehender Lisp-Systeme zu einem wachsenden Thema. Genealogie und Varianten In seiner sechzigjährigen Geschichte hat Lisp viele Variationen zum Kernthema einer S-Expressionssprache hervorgebracht. Darüber hinaus kann jeder gegebene Dialekt mehrere Implementierungen haben – zum Beispiel gibt es mehr als ein Dutzend Implementierungen von Common Lisp. Unterschiede zwischen den Dialekten können durchaus sichtbar sein - zum Beispiel verwendet Common Lisp das Schlüsselwort defun, um eine Funktion zu nennen, aber Scheme verwendet definieren. Innerhalb eines standardisierten Dialekts unterstützen jedoch die entsprechenden Implementierungen die gleiche Kernsprache, aber mit unterschiedlichen Erweiterungen und Bibliotheken. Historisch bedeutsame Dialekte LISTE 1 – Erste Umsetzung. LISTE 1.5 – Erste weit verbreitete Version, entwickelt von McCarthy und anderen am MIT. So benannt, weil es mehrere Verbesserungen auf dem ursprünglichen "LISP 1" Dolmetscher enthielt, aber keine große Umstrukturierung, wie die geplante LISP 2 sein würde. SAMMLUNG 1.6 – Dies war ein Nachfolger von LISP 1.5 im Stanford AI Lab und weit verbreitet auf PDP-10-Systeme, die das TOPS-10-Betriebssystem betreiben. Es wurde von Maclisp und InterLisp veraltet. MACLISP – für das Projekt MAC des MIT entwickelt, MACLISP ist ein direkter Nachkomme von LISP 1.5. Es lief auf die PDP-10 und Multics Systeme. MACLISP würde später kommen, um Maclisp genannt werden, und wird oft als MacLisp bezeichnet. Der MAC in MACLISP ist weder mit Apples Macintosh noch mit McCarthy verwandt. Interlisp – entwickelt bei BBN Technologies für PDP-10-Systeme, die das TENEX-Betriebssystem betreiben, später als "Westküste" Lisp für die Xerox Lisp-Maschinen als InterLisp-D. Eine kleine Version namens "InterLISP 65" wurde für die 6502-basierte Atari 8-Bit-Familiencomputerlinie veröffentlicht. Seit einiger Zeit waren Maclisp und InterLisp starke Konkurrenten. Franz Lisp – ursprünglich ein Projekt der University of California, Berkeley; später entwickelt vonFranz Inc. Der Name ist eine humorvolle Verformung des Namens "Franz Liszt", und bezieht sich nicht auf Allegro Common Lisp, den Dialekt von Common Lisp verkauft von Franz Inc., in den letzten Jahren. XLISP, auf der AutoLISP basiert. Standard Lisp und Portable Standard Lisp wurden weit verbreitet und portiert, vor allem mit dem Computer Algebra System REDUCE. ZetaLisp, auch Lisp Machine Lisp genannt – auf den Lisp-Maschinen verwendet, direkte Nachkommen von Maclisp. ZetaLisp hatte einen großen Einfluss auf Common Lisp. LeLisp ist ein französischer Lisp Dialekt. Einer der ersten Interface Builder (SOS Interface) wurde in LeLisp geschrieben. Schema (1975). Common Lisp (1984,) wie von Common Lisp the Language beschrieben – eine Konsolidierung von mehreren divergierenden Versuchen (ZetaLisp, Spice Lisp, NIL, und S-1 Lisp), um Nachfolgerdialekte zu Maclisp zu schaffen, mit erheblichen Einflüssen aus dem Schema Dialekt auch. Diese Version von Common Lisp war für breitgefächerte Plattformen verfügbar und wurde von vielen als de facto Standard bis zur Veröffentlichung von ANSI Common Lisp (ANSI X3.226-1994) akzeptiert. Unter den am weitesten verbreiteten Subdialekten von Common Lisp sind Steel Bank Common Lisp (SBCL,) CMU Common Lisp (CMU-CL,) Clozure OpenMCL (nicht zu verwechseln mit Clojure,!) GNU CLisp, und spätere Versionen von Franz Lisp; alle halten sich an den späteren ANSI CL Standard (siehe unten). Dylan war in seiner ersten Version eine Mischung aus Scheme mit dem Common Lisp Object System. EuLisp – Versuch, eine neue effiziente und gereinigte Lisp.ISLISP zu entwickeln – versuchen, eine neue effiziente und gereinigte Lisp zu entwickeln. Standardisiert als ISO/IEC 13816:1997 und später als ISO/IEC 13816:2007 überarbeitet Informationstechnologie – Programmiersprachen, Umgebungen und Systemsoftwareschnittstellen – Programmiersprache ISLISP. IEEE-Schema – IEEE-Standard, 1178–1990 (R1995). ANSI Common Lisp – ein amerikanisches National Standards Institute (ANSI) Standard für Common Lisp, erstellt von Unterausschuss X3J13, zu beginnen mit Common Lisp: Die Sprache als Basisdokument und durch einen öffentlichen Konsens Prozess zu arbeiten, um Lösungen für gemeinsame Fragen der Portabilität von Programmen und der Kompatibilität von Common Lisp-Implementierungen zu finden. Obwohl formal ein ANSI-Standard, die Implementierung, den Verkauf, die Nutzung und den Einfluss von ANSI Common Lisp ist und wird weiterhin weltweit gesehen. ACL2 oder "A Computational Logic for Applicative Common Lisp", eine anwendungsfreie (nebeneffektfreie) Variante des Common LISP.ACL2 ist sowohl eine Programmiersprache, die Computersysteme modellieren kann, als auch ein Werkzeug, um Eigenschaften dieser Modelle zu beweisen. Clojure, ein neuer Dialekt von Lisp, der auf die Java virtuelle Maschine kompiliert und einen besonderen Fokus auf Konkurs hat. Game Oriented Assembly Lisp (oder GOAL) ist eine Videospiel Programmiersprache, die von Andy Gavin und dem Jak und Daxter Team bei Naughty Dog entwickelt wurde. Es wurde mit Allegro Common Lisp geschrieben und in der Entwicklung der gesamten Jak und Daxter-Serie von Spielen verwendet. 2000 bis heute Nachdem Lisp in den 1990er Jahren etwas zurückgegangen war, erlebte Lisp nach 2000 eine Wiederaufregung des Interesses. Die meisten neuen Aktivitäten konzentrierten sich auf die Implementierungen von Common Lisp, Scheme, Emacs Lisp, Clojure und Racket und umfasst die Entwicklung neuer tragbarer Bibliotheken und Anwendungen. Viele neue Lisp Programmierer wurden von Schriftstellern wie Paul Graham und Eric S. Raymond inspiriert, um eine andere Sprache als antiquiert zu verfolgen. Neue Lisp Programmierer beschreiben oft die Sprache als Augenöffnungserfahrung und behaupten, wesentlich produktiver als in anderen Sprachen zu sein. Diese Sensibilisierung kann gegen den "AI-Winter" und Lisps kurzen Gewinn Mitte der 1990er Jahre gerichtet werden. Ab 2010 gab es elf aktive Common Lisp-Implementierungen. Scieneer Common Lisp ist eine neue kommerzielle Umsetzung von CMUCL mit einer ersten Veröffentlichung im Jahr 2002. Die Open Source-Community hat neue unterstützende Infrastruktur geschaffen: CLiki ist ein Wiki, das Common Lisp bezogene Informationen sammelt, die Common Lisp-Verzeichnis listet Ressourcen, #lisp ist ein beliebter IRC-Kanal und ermöglicht die Weitergabe und Kommentar von Code-Snippets (mit Unterstützung von lisppaste, ein IRC-Bot geschrieben in Lisp,) Planet Lisp sammelt die Inhalte von verschiedenen Lisp-bezogenen Blogs, auf LispForum-Nutzern diskutieren Lispcing-Themen ist ein Job-Service. Quicklisp ist ein Bibliotheksmanager für Common Lisp. 50 Jahre Lisp (1958–2008) wurde bei LISP50@OOPSLA gefeiert. Es gibt regelmäßig lokale Nutzertreffen in Boston, Vancouver und Hamburg. Weitere Veranstaltungen sind das Europäische Gemeinsame Lisp-Treffen, das Europäische Lisp-Symposium und eine internationale Lisp-Konferenz. Die Scheme-Gemeinschaft unterhält aktiv mehr als zwanzig Implementierungen. In den 2000er Jahren wurden mehrere signifikante neue Implementierungen entwickelt (Hühner, Gambit, Gauche, Ikarus, Larceny, Ypsilon). Der Revised5-Bericht über die Algorithmische Sprachregelung wurde in der Scheme-Gemeinschaft weithin angenommen. Die Scheme Requests for Implementation Prozess hat eine Menge von quasi Standardbibliotheken und Erweiterungen für Scheme erstellt. Nutzergemeinschaften einzelner Scheme-Implementierungen wachsen weiter. 2003 wurde ein neuer Sprachstandardisierungsprozess gestartet und 2007 zum R6RS Scheme-Standard geführt. Der akademische Einsatz von Scheme für die Lehre der Informatik scheint etwas zurückgegangen zu sein. Einige Universitäten nutzen Scheme nicht mehr in ihren Informatik Einführungskursen; MIT nutzt jetzt Python anstelle von Scheme für sein Bachelor-Computerwissenschaftsprogramm und MITx massiven Online-Kurs. Es gibt mehrere neue Dialekte von Lisp: Arc, Hy, Nu, Liskell und LFE (Lisp Flavored Erlang). Der Parser für Julia ist in Femtolisp implementiert, ein Dialekt von Scheme (Julia ist inspiriert von Scheme, die wiederum ein Lisp Dialekt ist). Im Oktober 2019 veröffentlichte Paul Graham eine Spezifikation für Bel, "ein neuer Dialekt von Lisp." Große Dialekte Common Lisp und Scheme repräsentieren zwei große Ströme von Lisp Entwicklung. Diese Sprachen verkörpern deutlich unterschiedliche Designwahlen. Common Lisp ist ein Nachfolger von Maclisp. Die Haupteinflüsse waren Lisp Machine Lisp, Maclisp, NIL, S-1 Lisp, Spice Lisp und Scheme. Es hat viele der Funktionen von Lisp Machine Lisp (ein großer Lisp-Dialect verwendet, um Lisp-Maschinen zu programmieren), aber wurde entwickelt, um effizient auf jedem persönlichen Computer oder Arbeitsplatz zu implementieren. Common Lisp ist eine allgemeine Programmiersprache und verfügt somit über einen großen Sprachstandard mit vielen integrierten Datentypen, Funktionen, Makros und anderen Sprachelementen sowie ein Objektsystem (Common Lisp Object System). Common Lisp leihte auch bestimmte Features von Scheme wie lexical scoping und lexical Schließungen. Gemeinsame Lisp-Implementierungen sind verfügbar, um verschiedene Plattformen wie die LLVM, die Java virtuelle Maschine, x86-64, PowerPC, Alpha, ARM, Motorola 68000 und MIPS, und Betriebssysteme wie Windows, macOS, Linux, Solaris, FreeBSD, NetBSD, OpenBSD, Dragonfly BSD und Heroku anzusprechen.Scheme ist ein statisch umhüllter und richtig rekursiver Dialekt der von Guy L. Steele, Jr. und Gerald Jay Sussman erfundenen Programmiersprache. Es wurde entworfen, um außergewöhnlich klare und einfache Semantik und wenige verschiedene Arten, Ausdrücke zu bilden. Etwa ein Jahrzehnt früher als Common Lisp entworfen, Scheme ist ein minimalistisches Design. Es hat eine viel kleinere Reihe von Standard-Features, aber mit bestimmten Implementierungs-Features (wie Heck-Call-Optimierung und volle Fortsetzungen) nicht in Common Lisp angegeben. Eine Vielzahl von Programmierparadigmen, einschließlich Imperativ, funktionelle und Nachrichtenübermittlung Stile, finden bequeme Ausdruck in Scheme. Scheme entwickelt sich weiter mit einer Reihe von Standards (Revisedn Report on the Algorithmic Language Scheme) und einer Reihe von Scheme Requests for Implementation. Clojure ist ein neuer Dialekt von Lisp, der hauptsächlich auf die Java virtuelle Maschine zielt, und die Common Language Runtime (CLR,) die Python VM, die Ruby VM YARV und Kompilierung auf JavaScript. Es ist entworfen, um eine pragmatische allgemeine Gebrauchssprache zu sein. Clojure zieht erhebliche Einflüsse von Haskell und legt einen sehr starken Akzent auf die Unmutbarkeit. Clojure bietet Zugriff auf Java-Frameworks und Bibliotheken, mit optionalen Typenhinweisen und Typ-Inferenz, so dass Anrufe zu Java Reflexion vermeiden und schnelle primitive Operationen ermöglichen können. Clojure ist nicht entwickelt, um rückwärts kompatibel mit anderen Lisp Dialekten. Darüber hinaus werden Lisp-Dialects als Skripting-Sprachen in vielen Anwendungen verwendet, mit dem bekanntesten Emacs Lisp im Emacs-Editor, AutoLISP und später Visual Lisp in AutoCAD, Nyquist in Audacity und Scheme in LilyPond. Die mögliche kleine Größe eines nützlichen Scheme-Interpreters macht es besonders beliebt bei eingebetteten Skripten. Beispiele sind SIOD und TinyScheme, die beide unter dem generischen Namen Script-fu erfolgreich in den GIMP-Bildprozessor eingebettet wurden". LIBREP, ein Lisp-Interpreter von John Harper, der ursprünglich auf der Emacs Lisp Sprache basiert, wurde in den Sawfish-Fenstermanager eingebettet. Standardisierte Dialekte Lisp hat offiziell standardisierte Dialekte: R6RS Scheme, R7RS Scheme, IEEE Scheme, ANSI Common Lisp und ISO ISLISP. Sprachinnovationen Lisp war die erste Sprache, in der die Struktur des Programmcodes treu und direkt in einer Standard-Datenstruktur dargestellt wird – eine Qualität, die viel später als Homoiconicity bezeichnet wird". So können Lisp-Funktionen in einem Lisp-Programm ohne untergeordnete Manipulationen manipuliert, verändert oder sogar erstellt werden. Dies gilt in der Regel als einer der Hauptvorteile der Sprache hinsichtlich ihrer Ausdruckskraft und macht die Sprache für syntaktische Makros und metazisale Auswertung geeignet. Eine bedingte Verwendung einer if-then-else-Syntax wurde von McCarthy in einem Fortran-Kontext erfunden. Er schlug seine Aufnahme in ALGOL vor, aber es war nicht Teil der Algol 58 Spezifikation. Für Lisp verwendete McCarthy die allgemeinere Kond-Struktur. Algol 60 nahm if–then–else auf und populärte es. Lisp tief beeinflusst Alan Kay, der Leiter des Forschungsteams, das Smalltalk bei Xerox PARC entwickelt hat; und wiederum wurde Lisp durch Smalltalk beeinflusst, wobei später Dialekte objektorientierte Programmierfunktionen (Erinnerungsklassen, Kapselungsinstanzen, Nachrichtenübergabe usw.) in den 1970er Jahren annehmen. Das Objektsystem Flavors stellte das Konzept des Mehrfacherbens und des Mischins vor. Das Common Lisp Object System bietet mehrere Vererbung, Multimethods mit mehrfachem Versand und erstklassige generische Funktionen, was eine flexible und leistungsstarke Form des dynamischen Versands liefert. Es diente als Vorlage für viele nachfolgende Lisp (einschließlich Scheme)-Objektsysteme, die oft über ein Metaobjekt-Protokoll implementiert werden, eine reflektierende metacircular-Design, in der das Objektsystem selbst definiert ist: Lisp war nur die zweite Sprache nach Smalltalk (und ist immer noch eine der wenigen Sprachen), um ein solches Metaobjektsystem zu besitzen. Viele Jahre später schlug Alan Kay vor, dass aufgrund des Zusammenflusses dieser Merkmale nur Smalltalk und Lisp als richtig konzipierte objektorientierte Programmiersysteme angesehen werden konnten. Lisp stellte das Konzept der automatischen Müllsammlung vor, in der das System den Haufen wandert, der nach ungenutztem Speicher sucht. Fortschritte in modernen anspruchsvollen Müllsammlung Algorithmen wie Generierung Müllsammlung wurde durch seine Verwendung in Lisp angeregt. Edsger W. Dijkstra in seiner 1972 Turing Award-Vorlesung sagte: "Mit ein paar sehr Grundprinzipien an seiner Gründung hat es [LISP] eine bemerkenswerte Stabilität gezeigt.Darüber hinaus war LISP der Träger für eine beträchtliche Anzahl in einem Sinne unsere anspruchsvollsten Computer-Anwendungen. LISP wurde als „die intelligenteste Art, einen Computer zu missbrauchen“ bezeichnet. Ich denke, dass Beschreibung ein großes Kompliment, weil es den vollen Geschmack der Befreiung überträgt: Es hat eine Reihe unserer begabten Mitmenschen beim Denken bisher unmöglicher Gedanken unterstützt. " Aufgrund seiner Ressourcenanforderungen in Bezug auf die frührechnerische Hardware (einschließlich der frühen Mikroprozessoren) wurde Lisp nicht so beliebt außerhalb der KI-Gemeinschaft wie Fortran und der ALGOL-abgeänderten C-Sprache. Aufgrund seiner Eignung für komplexe und dynamische Anwendungen genießt Lisp in den 2010er Jahren eine gewisse Rechirurgie des beliebten Interesses. Syntax und Semantik Hinweis: Die Beispiele dieses Artikels sind in Common Lisp geschrieben (obwohl die meisten auch in Scheme gültig sind.) Symbolische Ausdrücke (S-Ausdrücke)Lisp ist eine ausdrucksorientierte Sprache. Anders als in den meisten anderen Sprachen wird zwischen Ausdrücken und Aussagen keine Unterscheidung vorgenommen; alle Codes und Daten werden als Ausdrücke geschrieben. Wenn ein Ausdruck ausgewertet wird, erzeugt er einen Wert (in Common Lisp, gegebenenfalls mehrere Werte), der dann in andere Ausdrücke eingebettet werden kann. Jeder Wert kann jeder Datentyp sein. McCarthys 1958-Papier führte zwei Arten von Syntax ein: Symbolische Ausdrucksformen (S-Expressionen, Sexps), die die interne Darstellung von Code und Daten widerspiegeln; und Meta-Expressionen (M-Expressionen), die Funktionen von S-Expressionen ausdrücken. M-expressionen fanden nie Gefallen, und fast alle Lisps verwenden heute S-expressionen, um sowohl Code als auch Daten zu manipulieren. Die Verwendung von Klammern ist Lisps unmittelbar offensichtlicher Unterschied zu anderen Programmiersprachenfamilien. Als Ergebnis haben die Schüler seit langem Lisp Spitznamen wie Lost In Stupid Parenthesen, oder viele Irritating Superfluous Parenthesen gegeben. Die S-Expressions-Syntax ist aber auch für viel von Lisps Macht verantwortlich: Die Syntax ist extrem regelmäßig, was die Manipulation durch Computer erleichtert. Die Syntax von Lisp ist jedoch nicht auf traditionelle Klammern Notation beschränkt. Es kann auf alternative Notationen erweitert werden. XMLisp ist beispielsweise eine Common Lisp-Erweiterung, die das Metaobjekt-Protokoll verwendet, um S-Expressionen mit der Extensible Markup Language (XML) zu integrieren. Die Abhängigkeit von Ausdrücken gibt der Sprache große Flexibilität. Da Lisp-Funktionen als Listen geschrieben werden, können sie genau wie Daten verarbeitet werden. Dies ermöglicht ein einfaches Schreiben von Programmen, die andere Programme manipulieren (Metaprogrammierung). Viele Lisp Dialekte nutzen diese Funktion mit Makrosystemen, die eine Erweiterung der Sprache fast ohne Limit ermöglicht. Listen Eine Lisp-Liste wird mit seinen Elementen von Whitespace getrennt geschrieben und von Klammern umgeben. Beispielsweise ist (1 2 foo) eine Liste, deren Elemente die drei Atome 1, 2 und foo sind. Diese Werte werden implizit eingegeben: sie sind jeweils zwei ganze Zahlen und ein Lisp-spezifischer Datentyp, der als Symbol bezeichnet wird, und müssen nicht als solche angegeben werden. Die leere Liste () ist auch als spezielles Atom nil dargestellt. Dies ist die einzige Einheit in Lisp, die sowohl ein Atom als auch eine Liste ist. Ausdrücke werden als Listen unter Verwendung von Präfix-Notation geschrieben. Das erste Element in der Liste ist der Name einer Funktion, der Name eines Makros, ein Lambda-Ausdruck oder der Name eines "Sonderoperators" (siehe unten). Der Rest der Liste sind die Argumente. Beispielsweise gibt die Funktionsliste ihre Argumente als Liste zurück, so dass der Ausdruck in die Liste (1 2 foo) auswertet. Das Zitat vor dem Foo im vorhergehenden Beispiel ist ein "Sonderoperator", der sein Argument zurückgibt, ohne es auszuwerten. Jegliche nicht zitierten Ausdrücke werden vor der Auswertung des einschließenden Ausdrucks rekursiv ausgewertet. So bewertet man beispielsweise die Liste (1 2 (34). Beachten Sie, dass das dritte Argument eine Liste ist; Listen können geschachtelt werden. Betreiber Arithmetische Operatoren werden ähnlich behandelt. Der Ausdruck wertet auf 10 aus. Das Äquivalent unter Infix-Notation wäre "1 + 2 + 3 + 4". Lisp hat keine Vorstellung von Betreibern wie in Algol-derived Sprachen implementiert. Arithmetische Operatoren in Lisp sind variadische Funktionen (oder n-ary), die in der Lage, jede Anzahl von Argumenten zu nehmen. Ein C-style '++' Inkrementaloperator wird manchmal unter dem Namen incf implementiert, der Syntaxäquivalent (setq x (+ x 1,) gibt, der den neuen Wert von x zurückgibt. "Special Operators" (manchmal "Sonderformen" genannt) bieten Lisp's Kontrollstruktur. Zum Beispiel, der spezielle Betreiber, wenn drei Argumente. Ist das erste Argument nicht in der Lage, so bewertet es das zweite Argument; andernfalls bewertet es das dritte Argument.Der Ausdruck wertet somit auf (3 4 bar") aus. Dies wäre natürlich sinnvoller, wenn anstelle von nil eine nicht-triviale Expression substituiert wäre. Lisp bietet auch logische Operatoren und, oder und nicht. Die und bzw. die Betreiber führen eine Kurzschlussbewertung durch und werden ihr erstes Nil- bzw. Nicht-Nil-Argument zurückgeben. wird nach James auswerten. Lambda-Ausdrücke und Funktionsdefinition Ein weiterer spezieller Operator, Lambda, dient dazu, Variablen an Werte zu binden, die dann innerhalb eines Ausdrucks ausgewertet werden. Dieser Operator wird auch verwendet, um Funktionen zu schaffen: Die Argumente zu Lambda sind eine Liste von Argumenten, und der Ausdruck oder die Ausdrücke, auf die die Funktion auswertet (der zurückgegebene Wert ist der Wert des zuletzt ausgewerteten Ausdrucks). Der Ausdruck wertet eine Funktion aus, die bei Anwendung ein Argument einnimmt, an Arg bindet und die Nummer eins höher als dieses Argument zurückgibt. Lambda-Ausdrücke werden nicht anders behandelt als benannte Funktionen; sie werden auf die gleiche Weise aufgerufen. Der Ausdruck wertet daher auf 6. Hier machen wir eine Funktionsanwendung: Wir führen die anonyme Funktion aus, indem wir ihm den Wert 5 übergeben. Namensfunktionen werden durch die Speicherung eines Lambda-Ausdrucks in einem Symbol mit dem defun-Makro erzeugt. (defun f (a) b.) definiert eine neue Funktion namens f in der globalen Umgebung. Es ist konzeptuell ähnlich wie der Ausdruck: Wo setf ein Makro ist, das verwendet wird, um den Wert des ersten Arguments fdefinition 'f auf ein neues Funktionsobjekt einzustellen. fdefinition ist eine globale Funktionsdefinition für die Funktion namens f. #' ist eine Abkürzung für den funktionsspezifischen Bediener und gibt ein Funktionsobjekt zurück. Atome Im Original LISP gab es zwei grundlegende Datentypen: Atome und Listen. Eine Liste war eine endlich geordnete Sequenz von Elementen, wobei jedes Element entweder ein Atom oder eine Liste ist, und ein Atom eine Zahl oder ein Symbol war. Ein Symbol war im Wesentlichen ein einzigartiger Name, der als alphanumerischer String im Quellcode geschrieben wurde und entweder als variabler Name oder als Datenelement in der symbolischen Verarbeitung verwendet wurde. Zum Beispiel die Liste (FOO (BAR 1) 2) enthält drei Elemente: das Symbol FOO, die Liste (BAR 1,) und die Zahl 2. Der wesentliche Unterschied zwischen Atomen und Listen war, dass Atome unveränderlich und einzigartig waren. Zwei Atome, die an verschiedenen Orten im Quellcode erschienen, aber in genau der gleichen Weise geschrieben wurden, stellten das gleiche Objekt dar, während jede Liste ein separates Objekt war, das unabhängig von anderen Listen geändert werden konnte und von anderen Listen durch Vergleicher unterschieden werden konnte. Da in späteren Lisp-Dialekten mehr Datentypen eingeführt wurden und Programmierstile entwickelt wurden, verlor das Konzept eines Atoms Bedeutung. Viele Dialekte hielten das Prädikat-Atom für die Vermächtniskompatibilität und definiert es für jedes Objekt, das kein Kons ist. Negative und Listen Eine Lisp-Liste wird als einsam verknüpfte Liste implementiert. Jede Zelle dieser Liste wird als Kons bezeichnet (in Scheme, ein Paar), und besteht aus zwei Zeigern, genannt Auto und cdr. Diese entsprechen jeweils den in der Artikel-Verknüpfungsliste diskutierten Daten und nächsten Feldern. Von den vielen Datenstrukturen, die aus Konszellen aufgebaut werden können, wird eine der grundlegendsten als eine richtige Liste bezeichnet. Eine richtige Liste ist entweder das spezielle nil (leere Liste) Symbol, oder ein Kons, in dem das Auto auf ein Datum (das eine andere Konsstruktur sein kann, wie eine Liste,) und die cdr zeigt auf eine andere richtige Liste. Wird ein bestimmter Kons als Leiter einer verknüpften Liste genommen, so weist sein Auto auf das erste Element der Liste hin, und seine cdr zeigt auf den Rest der Liste. Aus diesem Grund werden die Auto- und Cdr-Funktionen auch als erste und Ruhe bezeichnet, wenn es sich um Konse handelt, die Teil einer verknüpften Liste sind (anstatt einen Baum zu sagen). Eine Lisp-Liste ist also kein Atomobjekt, da es sich bei einer Containerklasse in C+ oder Java um einen Fall handelt. Eine Liste ist nichts anderes als ein Zusammenschluss von verknüpften Konsen. Eine Variable, die sich auf eine bestimmte Liste bezieht, ist einfach ein Zeiger auf die ersten Kons in der Liste. Die Umschaltung einer Liste kann durch Cdring-Down-Liste erfolgen, d.h. durch aufeinanderfolgende cdrs, um jeden Konus der Liste zu besuchen; oder durch die Verwendung von mehreren Funktionen höherer Ordnung, um eine Funktion über eine Liste abzubilden. Da Konse und Listen in Lisp-Systemen so universell sind, ist es ein häufiger Missverständnis, dass sie Lisps einzige Datenstrukturen sind. In der Tat haben alle aber die einfachsten Lisps andere Datenstrukturen, wie Vektoren (Arrays,) Hash-Tabellen, Strukturen und so weiter. S-Ausdrücke stellen Listen dar. Es gibt verschiedene Möglichkeiten, die gleiche Liste wie eine S-Expression zu repräsentieren.Ein Kegel kann als (a.b.) bezeichnet werden, wo a der Wagen und b der cdr ist. Eine längere ordnungsgemäße Liste könnte geschrieben werden (a .(b .(c .(d . nil)))) in punktiert-paar notation. Dies wird üblicherweise als (a b c d) in Listennotation abgekürzt. Eine unsachgemäße Liste kann in einer Kombination der beiden - wie (a b c .d) für die Liste von drei Kegeln geschrieben werden, deren letzte cdr d ist (d.h. die Liste (a. (b.(c.d) in vollständig spezifizierter Form.) Auflistungsverfahren Lisp bietet viele integrierte Verfahren für den Zugriff und die Kontrolle von Listen. Listen können direkt mit dem Listenverfahren erstellt werden, das jede Anzahl von Argumenten nimmt und die Liste dieser Argumente zurückgibt. Aufgrund der Art, wie Listen aus Konspaaren aufgebaut sind, kann der Konsvorgang dazu verwendet werden, ein Element vor einer Liste hinzuzufügen. Beachten Sie, dass das Kons-Verfahren asymmetrisch ist, wie es Listenargumente behandelt, weil wie Listen erstellt werden. Das Antragsverfahren fügt zwei (oder mehr) Listen zueinander an. Weil Lisp-Listen verknüpfte Listen sind, hat Appending zwei Listen asymptotische Zeit Komplexität O (n ) {\displaystyle O(n}) Geteilte Struktur Lisp Listen, einfache verknüpfte Listen, können Struktur miteinander teilen. Das heißt, zwei Listen können den gleichen Schwanz oder die letzte Folge von Kegeln haben. Zum Beispiel nach der Ausführung des folgenden Common Lisp-Codes: Die Listen foo und bar sind (a b c) bzw. (x b c). Der Schwanz (b c) ist jedoch in beiden Listen dieselbe Struktur. Es ist keine Kopie; die auf b und c weisenden Konszellen befinden sich in den gleichen Speicherplätzen für beide Listen. Die Aufteilung von Struktur statt Kopieren kann eine dramatische Leistungsverbesserung. Diese Technik kann jedoch in unerwünschter Weise mit Funktionen interagieren, die Listen als Argumente verändern. Eine Liste zu ändern, z. B. durch den Austausch der c durch eine Gänse, wird die andere beeinflussen: Dies ändert sich an (eine b Gänse), aber damit ändert sich auch Bar an (x b Gänse) – ein möglicherweise unerwartetes Ergebnis. Dies kann eine Quelle von Fehlern sein, und Funktionen, die ihre Argumente ändern, werden aus diesem Grund als zerstörerisch dokumentiert. Aficionados der funktionellen Programmierung vermeiden destruktive Funktionen. Im Dialekt Scheme, der den funktionellen Stil begünstigt, sind die Namen destruktiver Funktionen mit einem vorsichtigen Ausrufpunkt gekennzeichnet, oder bang" – wie set-car!(read set car bang), der das Auto eines Kegels ersetzt. Im Common Lisp Dialekt sind destruktive Funktionen üblich; das Äquivalent von Set-Car! wird rplaca für "ersetzen Auto" genannt. Diese Funktion wird selten gesehen, da Common Lisp eine spezielle Einrichtung, setf, um es einfacher zu definieren und zu verwenden destruktive Funktionen. Ein häufiger Stil in Common Lisp ist, Code funktionell (ohne destruktive Anrufe) zu schreiben, wenn Prototyping, dann destruktive Anrufe als Optimierung hinzufügen, wo es sicher ist, dies zu tun. Selbstbewertende Formen und Zitat Lisp wertet Ausdrücke aus, die vom Benutzer eingegeben werden. Symbole und Listen werten auf einen anderen (in der Regel einfacheren) Ausdruck aus – zum Beispiel wertet ein Symbol den Wert der Variablen aus; (+ 2 3) bewertet auf 5. Jedoch bewerten die meisten anderen Formen sich selbst: wenn sie 5 in Lisp einlaufen, kehrt sie 5 zurück. Jeder Ausdruck kann auch markiert werden, um zu verhindern, dass er ausgewertet wird (wie es für Symbole und Listen erforderlich ist). Dies ist die Rolle des Angebots-Sonderbeteiligten oder dessen Abkürzung ' (eine Anführungszeichen). Zum Beispiel, in der Regel, wenn es das Symbol foo eingibt, gibt es den Wert der entsprechenden Größe (oder einen Fehler, wenn es keine solche Größe gibt). Geben Sie (quote foo) oder in der Regel "foo.Both Common Lisp und Scheme unterstützen auch den mit dem ` Zeichen (grave accent) eingetragenen Backquote Operator (termed quasiquote in Scheme). Dies ist fast das gleiche wie das einfache Zitat, außer es erlaubt, Ausdrücken zu evaluieren und ihre Werte interpoliert in eine zitierte Liste mit den Komma , unquote und comma-at ,@ splice Operatoren. Wenn die variable Schnauze den Wert (bar baz) hat, wertet `(foo ,snue) auf (foo (bar baz), während `(foo @,snue) auf (foo bar baz) auswertet. Die Backquote wird am häufigsten bei der Definition von Makroerweiterungen verwendet. Selbstbewertende Formen und zitierte Formen sind Lisps Äquivalent von Literaten. Es kann möglich sein, die Werte von (mutbaren) Literalen in Programmcode zu ändern. Wenn beispielsweise eine Funktion ein zitiertes Formular zurückgibt und der Code, der die Funktion ruft, das Formular modifiziert, kann dies das Verhalten der Funktion bei nachfolgenden Aufrufen verändern.Eine solche Anführungsform wird in der Regel als schlecht angesehen und wird von ANSI Common Lisp als fehlerhaft definiert (Ergebnis eines undefinierten Verhaltens in kompilierten Dateien, weil der Datei-Compiler ähnliche Konstanten koaleszieren kann, in schreibgeschützten Speicher usw.). Lisp's Formalisierung des Zitats wurde von Douglas Hofstadter (in Gödel, Escher, Bach) und anderen als Beispiel der philosophischen Idee der Selbstreferenz genannt. Umfang und Schließung Die Familie Lisp spaltet sich über den Einsatz des dynamischen oder statischen (a.k.a lexical) Bereichs. Clojure, Common Lisp und Scheme nutzen das statische Scoping standardmäßig, während newLISP, Picolisp und die eingebetteten Sprachen in Emacs und AutoCAD dynamisches Scoping verwenden. Seit Version 24.1, Emacs verwendet sowohl dynamisches als auch lexisches Scoping. Liste Struktur des Programmcodes; Ausbeutung durch Makros und Compiler Eine grundlegende Unterscheidung zwischen Lisp und anderen Sprachen ist, dass in Lisp die textuelle Darstellung eines Programms einfach eine human lesbare Beschreibung der gleichen internen Datenstrukturen (verknüpfte Listen, Symbole, Nummer, Zeichen, etc.) ist, wie dies vom zugrunde liegenden Lisp-System verwendet werden würde. Lisp nutzt dies, um ein sehr leistungsfähiges Makrosystem zu implementieren. Wie andere Makrosprachen wie C gibt ein Makro-Code zurück, der dann kompiliert werden kann. Im Gegensatz zu C-Makros sind die Makros jedoch Lisp-Funktionen und können so die volle Leistung von Lisp nutzen. Außerdem, weil Lisp-Code die gleiche Struktur wie Listen hat, können Makros mit einer der Listenverarbeitungsfunktionen in der Sprache gebaut werden. Kurz gesagt, alles, was Lisp mit einer Datenstruktur tun kann, können Lisp-Makros zum Code. In den meisten anderen Sprachen hingegen ist die Ausgabe des Parsers rein intern für die Sprachumsetzung und kann vom Programmierer nicht manipuliert werden. Diese Funktion erleichtert die Entwicklung effizienter Sprachen in Sprachen. Beispielsweise kann das Common Lisp Object System mit Makros sauber als Spracherweiterung implementiert werden. Dies bedeutet, dass, wenn eine Anwendung einen anderen Vererbungsmechanismus benötigt, sie ein anderes Objektsystem verwenden kann. Dies ist in starkem Gegensatz zu den meisten anderen Sprachen; zum Beispiel Java unterstützt nicht mehrere Vererbung und es gibt keine vernünftige Möglichkeit, es hinzuzufügen. In einfachen Lisp-Implementierungen wird diese Listenstruktur direkt interpretiert, um das Programm auszuführen; eine Funktion ist buchstäblich ein Stück Listenstruktur, die vom Dolmetscher bei der Ausführung durchlaufen wird. Die wichtigsten Lisp-Systeme enthalten auch einen Compiler. Der Compiler übersetzt Listenstruktur in Maschinencode oder Bytecode zur Ausführung. Dieser Code kann so schnell ausgeführt werden, wie der Code, der in herkömmlichen Sprachen wie C. Macros kompiliert wird, vor dem Compilationsschritt erweitert wird und somit einige interessante Optionen bietet. Wenn ein Programm eine vorkomputierte Tabelle benötigt, dann könnte ein Makro die Tabelle zu kompilieren Zeit erstellen, so dass der Compiler nur die Tabelle ausgeben muss und keinen Anrufcode benötigt, um die Tabelle zu Laufzeit zu erstellen. Einige Lisp-Implementierungen haben sogar einen Mechanismus, der es erlaubt, Code während der Verstehenszeit (wenn ein Makro es braucht), aber nicht im emittierten Modul vorhanden sein. Die Auswertung und die Lese-Eval-Druckschleife Lisp-Sprachen werden häufig mit einer interaktiven Befehlszeile verwendet, die mit einer integrierten Entwicklungsumgebung (IDE) kombiniert werden kann. Die Benutzertypen in Ausdrücken an der Befehlszeile oder leiten die IDE, um sie an das Lisp-System zu übertragen. Lisp liest die eingegebenen Ausdrücke, wertet sie aus und druckt das Ergebnis aus. Aus diesem Grund wird die Befehlszeile Lisp als Lese-Eval-Druckschleife (REPL) bezeichnet. Der Grundbetrieb der REPL ist wie folgt. Dies ist eine vereinfachte Beschreibung, die viele Elemente einer echten Lisp, wie z.B. Zitat und Makros, ausgibt. Die Lesefunktion akzeptiert textuelle S-Expressionen als Eingabe und parsiert sie in eine interne Datenstruktur. Zum Beispiel, wenn Sie den Text (+ 1 2) an der Aufforderung eingeben, lesen Sie diese in eine verknüpfte Liste mit drei Elementen: das Symbol +, die Zahl 1, und die Zahl 2. Es kommt also vor, dass diese Liste auch ein gültiges Stück Lisp-Code ist, d.h. es kann ausgewertet werden. Das liegt daran, dass das Auto der Liste eine Funktion nennt – die Additionsoperation. Beachten Sie, dass ein Foo als einziges Symbol gelesen wird. 123 wird als die Zahl hundert und dreiundzwanzig gelesen werden. 123 wird als String 123" gelesen. Die eval-Funktion wertet die Daten aus, liefert dadurch Null oder mehr andere Lisp-Daten zurück. Die Auswertung muss keine Interpretation bedeuten; einige Lisp-Systeme kompilieren jeden Ausdruck zum nativen Maschinencode. Es ist jedoch einfach, die Auswertung als Interpretation zu beschreiben: Um eine Liste zu bewerten, deren Autonamen eine Funktion, eval zuerst bewertet jedes der Argumente in seinem cdr, dann wendet die Funktion auf die Argumente.In diesem Fall ist die Funktion Addition, und sie auf die Argumentliste (1 2) gibt die Antwort 3. Dies ist das Ergebnis der Auswertung. Das Symbol foo wertet den Wert des Symbols foo aus. Daten wie der String 123 wertet auf denselben String aus. Die Liste (quote (1 2 3) bewertet die Liste (1 2 3). Es ist Aufgabe der Druckfunktion, die Ausgabe an den Benutzer darzustellen. Für ein einfaches Ergebnis wie 3 ist dies trivial. Ein Ausdruck, der zu einem Stück Listenstruktur ausgewertet würde, würde erfordern, dass Druck die Liste durchqueren und als S-Expression ausdrucken. Um eine Lisp REPL zu implementieren, ist es notwendig, diese drei Funktionen und eine stufenlose Funktion umzusetzen. ( Natürlich wird die Durchführung von Eval komplex sein, da es auch alle speziellen Betreiber wie ob oder Lambda umsetzen muss.) Dies geschieht, eine grundlegende REPL ist eine Zeile des Codes: (Loop (Druck (Leer (Lese))). Die Lisp REPL liefert typischerweise auch Eingabebearbeitung, Eingabehistorie, Fehlerbehandlung und eine Schnittstelle zum Debugger. Lisp wird in der Regel eagerly ausgewertet. In Common Lisp werden Argumente in applicativer Reihenfolge "(links innermost) ausgewertet, während in Scheme Reihenfolge der Argumente undefiniert ist, so dass Raum für die Optimierung durch einen Compiler. Kontrollstrukturen Lisp hatte ursprünglich sehr wenige Kontrollstrukturen, aber viele weitere wurden während der Entwicklung der Sprache hinzugefügt. ( Lisp's Original Conditional Operator, cond, ist der Vorläufer zu späteren if-then-else Strukturen.) Programmierer im Scheme-Dialekt drücken häufig Schleifen mit Schwanzrekursion aus. Scheme's Commonalität in der akademischen Informatik hat einige Studenten dazu geführt, dass die Schwanzrekursion die einzige oder die häufigste Weise ist, Iterationen in Lisp zu schreiben, aber das ist falsch. Allt-seen Lisp Dialekte haben Imperativ-Stil Iteration Konstrukte, von Scheme's do Schleife zu Common Lisp's komplexen Schleifenausdrücken. Darüber hinaus ist die zentrale Frage, die dies zu einem Ziel macht, anstatt subjektiver Materie, dass Scheme spezifische Anforderungen an die Handhabung von Endanrufen macht, und daher der Grund, dass die Verwendung von Endanmeldungen im Allgemeinen für Scheme ermutigt wird, ist, dass die Praxis ausdrücklich durch die Sprachdefinition unterstützt wird. Die ANSI Common Lisp erfordert hingegen nicht die Optimierung, die allgemein als Endrufbeseitigung bezeichnet wird. So ist die Tatsache, dass Schwanz rekursive Stil als lässiger Ersatz für die Verwendung von traditionellen Iterationskonstrukte (wie Do, Dolist oder Schleife) in Common Lisp entmutigt wird, nicht nur eine Frage der stilistischen Präferenz, sondern potenziell eine der Effizienz (da ein offensichtlicher Schwanzruf in Common Lisp nicht als einfache Sprung kompilieren kann) und Programm Korrektheit (da Schwanzrecursion erhöhen kann Stack-Nutzung in Common Lisp). Einige Lisp-Kontrollstrukturen sind spezielle Operatoren, die den syntaktischen Keywords anderer Sprachen entsprechen. Ausdrücke, die diese Operatoren verwenden, haben das gleiche Oberflächenbild wie Funktionsaufrufe, unterscheiden sich jedoch darin, dass die Argumente nicht notwendig ausgewertet werden - oder im Falle eines Iterationsausdrucks mehr als einmal ausgewertet werden können. Im Gegensatz zu den meisten anderen großen Programmiersprachen ermöglicht Lisp die Implementierung von Kontrollstrukturen mit der Sprache. Mehrere Kontrollstrukturen sind als Lisp-Makros implementiert und können sogar von dem Programmierer, der wissen will, wie sie funktionieren, makroexpandiert werden. Sowohl Common Lisp als auch Scheme haben Betreiber für den nicht-lokalen Steuerstrom. Die Unterschiede in diesen Operatoren sind einige der tiefsten Unterschiede zwischen den beiden Dialekten. Scheme unterstützt re-entrante Fortführungen mit dem Call/cc-Verfahren, das es einem Programm ermöglicht, einen bestimmten Platz in der Ausführung zu speichern (und später wiederherzustellen). Common Lisp unterstützt nicht re-entrant Fortsetzungen, sondern unterstützt mehrere Möglichkeiten der Behandlung von Flucht Fortsetzungen. Oft kann der gleiche Algorithmus in Lisp in einem Imperativ oder einem Funktionsstil ausgedrückt werden. Wie oben erwähnt, neigt Scheme dazu, den Funktionsstil zu bevorzugen, mit Schwanzrekursion und Fortsetzungen, um den Steuerfluss auszudrücken. Imperativ Stil ist jedoch immer noch durchaus möglich. Der von vielen Common Lisp Programmierern bevorzugte Stil kann Programmierern, die für strukturierte Sprachen wie C verwendet werden, eher vertraut erscheinen, während Schemers von reinen Sprachen wie Haskell bevorzugter ist. Aufgrund des frühen Erbes von Lisp in der Listenverarbeitung hat es eine breite Palette von höherwertigen Funktionen in Bezug auf Iteration über Sequenzen. In vielen Fällen, in denen eine explizite Schleife in anderen Sprachen (wie bei einer Schleife in C) in Lisp benötigt würde, kann die gleiche Aufgabe mit einer höherwertigen Funktion erfüllt werden.(Das gleiche gilt für viele funktionelle Programmiersprachen.) Ein gutes Beispiel ist eine Funktion, die in Scheme Karte genannt wird und in Common Lisp wird Mapcar genannt. Bei einer Funktion und einer oder mehreren Listen wendet mapcar die Funktion nacheinander auf die Listenelemente an, um die Ergebnisse in einer neuen Liste zu sammeln: Dies gilt für jedes entsprechende Listenelementpaar, das das Ergebnis (11 22 33 44 55) liefert. Beispiele Hier sind Beispiele für Common Lisp Code. Das grundlegende "Hallo, Welt!"-Programm: Lisp Syntax verleiht sich natürlich wiederkehren. Mathematische Probleme wie die Aufzählung von wiederkehrend definierten Sätzen sind in dieser Notation einfach auszudrücken. Zum Beispiel zur Bewertung der Faktorzahl: Eine alternative Implementierung nimmt weniger Stack-Raum als die vorherige Version, wenn das darunterliegende Lisp-System die Rücklaufrekursion optimiert: Entgegen den obigen Beispielen mit einer iterativen Version, die Common Lisp's Schleifenmakro verwendet: Die folgende Funktion rückt eine Liste um. (Die eingebaute umgekehrte Funktion von Lisp macht dasselbe.) Objektsysteme Verschiedene Objektsysteme und Modelle wurden auf, neben, oder in Lisp gebaut, darunter: Das Common Lisp Object System, CLOS, ist integraler Bestandteil der ANSI Common Lisp. CLOS stammt aus New Flavors und CommonLOOPS. ANSI Common Lisp war die erste standardisierte objektorientierte Programmiersprache (1994, ANSI X3J13). ObjectLisp oder Object Lisp, verwendet von Lisp Machines Incorporated und frühen Versionen von Macintosh Common Lisp LOOPS (Lisp Object-Oriented Programming System) und die späteren CommonLOOPS Flavors, gebaut am MIT, und seine nachkommenden New Flavors (entwickelt von Symbolics). KR (kurz für Wissensrepräsentation) ein zwängebasiertes Objektsystem entwickelt, um das Schreiben von Garnet, einer GUI-Bibliothek für Common Lisp, zu unterstützen. Knowledge Engineering Environment (KEE) verwendet ein Objektsystem namens UNITS und integriert es mit einem Inferenzmotor und einem Wahrheitspflegesystem (ATMS). Siehe auch Selbstmodifizierende Code ReferenzenWeitere Informationen Externe Links Geschichte Geschichte von Lisp – John McCarthys Geschichte vom 12. Februar 1979 Lisp Geschichte – Herbert Stoyans Geschichte aus den Dokumenten kompiliert (von McCarthy als vollständiger als seine eigenen, siehe: McCarthy's History tutial tuts) Geschichte von LISP im Computer History MuseumSpezifikationen und SitzungenVer Europäische Konferenzen Casting SPEL in Lisp, ein Comic-Book-Stil Einführung Tutorial Auf Lisp, ein kostenloses Buch von Paul Graham Practical Common Lisp, Freeware Edition von Peter Seibel Lisp für das Web Land von Lisp Lassen Sie über LambdaInterviewsOral History Interview mit John McCarthy am Charles Babbage Institute, University of Minnesota, Minneapolis. McCarthy diskutiert seine Rolle bei der Entwicklung des Zeitaustauschs am Massachusetts Institute of Technology. Er beschreibt auch seine Arbeit in der künstlichen Intelligenz (KI), die von der Advanced Research Projects Agency finanziert wird, einschließlich der Logik-basierten KI (LISP) und Robotik. Interview mit Richard P. Gabriel (Podcast)Resourcen CLiki: das Common Lisp Wiki Das Common Lisp Verzeichnis (über die Wayback-Maschine; archiviert vom Original)Lisp FAQ Index lisppaste Planet Lisp Weekly Lisp News newLISP - Eine moderne, allgemeine Skriptsprache Lisp bei Curlie