Das Hypertext Transfer Protocol (HTTP) ist ein Anwendungsschichtprotokoll im Internet Protokoll Suite Modell für verteilte, kollaborative Hypermedia-Informationssysteme. HTTP ist die Grundlage der Datenkommunikation für das World Wide Web, wo Hypertext-Dokumente Hyperlinks zu anderen Ressourcen enthalten, auf die der Benutzer leicht zugreifen kann, zum Beispiel durch Mausklick oder durch Tippen auf den Bildschirm in einem Webbrowser. Die Entwicklung von HTTP wurde 1989 von Tim Berners-Lee am CERN initiiert. Die Entwicklung der frühen HTTP-Anfragen für Kommentare (RFCs) war eine koordinierte Anstrengung der Internet Engineering Task Force (IETF) und des World Wide Web Consortiums (W3C) mit der späteren Arbeit in den IETF. HTTP/1 wurde 1997 erstmals dokumentiert (als Version 1.1). HTTP/2 ist ein effizienterer Ausdruck der HTTP-Semantik "on the wire" und wurde 2015 veröffentlicht und wird von 45% der Webseiten verwendet; es wird nun von nahezu allen Webbrowsern und großen Webservern über Transport Layer Security (TLS) mit einer Application-Layer Protocol Negotiation (ALPN)-Erweiterung unterstützt, wo TLS 1.2 oder neuer benötigt wird. HTTP/3 ist der vorgeschlagene Nachfolger von HTTP/2, und zwei Drittel der Webbrowser (beide auf Desktop und Handy) können bereits HTTP/3 verwenden, auf den 20% der Webseiten, die es bereits unterstützen; es verwendet QUIC anstelle von TCP für das zugrunde liegende Transportprotokoll. Wie HTTP/2, es nicht überholt frühere Hauptversionen des Protokolls. Die Unterstützung für HTTP/3 wurde zuerst Cloudflare und Google Chrome hinzugefügt und ist auch in Firefox aktiviert. Technische Übersicht HTTP-Funktionen als Anfrage-Response-Protokoll im Client-Server-Computing-Modell. Ein Webbrowser kann beispielsweise der Client und eine auf einem Computer, der eine Website hostet, laufende Anwendung sein. Der Client übermittelt dem Server eine HTTP-Anforderungsnachricht. Der Server, der Ressourcen wie HTML-Dateien und andere Inhalte bereitstellt oder andere Funktionen im Auftrag des Clients durchführt, gibt eine Antwortnachricht an den Client zurück. Die Antwort enthält vollständige Statusinformationen über die Anfrage und kann auch angeforderte Inhalte in ihrer Nachrichtenstelle enthalten. Ein Webbrowser ist ein Beispiel für einen Benutzeragent (UA). Andere Arten von Benutzer-Agenten umfassen die Indexierungssoftware, die von Such-Providern (Web-Crawler,) Sprach-Browsern, mobilen Apps und anderen Software verwendet wird, die auf Web-Inhalte zugreifen, konsumieren oder anzeigen. HTTP ist so konzipiert, dass Zwischennetzwerkelemente die Kommunikation zwischen Clients und Servern verbessern oder aktivieren können. Hochraffic-Websites profitieren oft von Web-Cache-Servern, die Inhalte im Auftrag von Upstream-Servern zur Verbesserung der Reaktionszeit liefern. Web-Browser haben zuvor Zugriff auf Web-Ressourcen und verwenden sie, wenn möglich, um den Netzverkehr zu reduzieren. HTTP-Proxyserver an privaten Netzwerkgrenzen können die Kommunikation für Clients ohne eine global routable Adresse erleichtern, indem Nachrichten mit externen Servern übertragen werden. HTTP ist ein Anwendungsschicht-Protokoll, das im Rahmen der Internet-Protokoll-Suite entwickelt wurde. Seine Definition vermutet ein zugrunde liegendes und zuverlässiges Transportschichtprotokoll, und Transmission Control Protocol (TCP) wird häufig verwendet. HTTP kann jedoch angepasst werden, um unzuverlässige Protokolle wie das User Datagram Protocol (UDP) zu verwenden, beispielsweise in HTTPU und Simple Service Discovery Protocol (SSDP). HTTP-Ressourcen werden von Uniform Resource Locators (URLs) unter Verwendung der Uniform Resource Identifiers (URI's)-Systeme http und https identifiziert und im Netzwerk lokalisiert. Wie in RFC 3986 definiert, werden URIs als Hyperlinks in HTML-Dokumenten kodiert, um vernetzte Hypertextdokumente zu bilden. HTTP/1.1 ist eine Revision des ursprünglichen HTTP (HTTP/1.0). In HTTP/1.0 wird für jede Ressourcenanforderung eine separate Verbindung zum selben Server hergestellt. HTTP/1.1 kann eine Verbindung mehrmals wiederverwenden, um Bilder, Skripte, Stylesheets usw. nach der Ausgabe der Seite herunterzuladen. Die HTTP/1.1-Kommunikation erfährt daher weniger Latenz, da die Einrichtung von TCP-Verbindungen erhebliche Überlastung aufweist. Geschichte Der Begriff Hypertext wurde 1965 von Ted Nelson im Xanadu-Projekt geprägt, das wiederum von Vannevar Bushs 1930er Vision des Mikrofilm-basierten Informations-Retrieval- und Management-Memex-Systems inspiriert wurde, das in seinem 1945 Essay "As We May Think" beschrieben wurde. Tim Berners-Lee und sein Team am CERN werden mit der Erfindung des ursprünglichen HTTP, zusammen mit HTML und der damit verbundenen Technologie für einen Webserver und einen textbasierten Webbrowser ausgezeichnet. Berners-Lee hat 1989 erstmals das WorldWideWeb-Projekt vorgeschlagen – heute als World Wide Web bekannt. Der erste Webserver ging 1990 live.Das verwendete Protokoll hatte nur eine Methode, nämlich GET, die eine Seite von einem Server anfordern würde. Die Antwort vom Server war immer eine HTML-Seite. Die erste dokumentierte Version von HTTP war die HTTP-Version 0.9 (1991). Dave Raggett leitete 1995 die HTTP Working Group (HTTP WG) und wollte das Protokoll mit erweiterten Operationen, erweiterten Verhandlungen, reicheren Meta-Informationen, verbunden mit einem Sicherheitsprotokoll, das durch zusätzliche Methoden und Headerfelder effizienter wurde. RFC 1945 offiziell eingeführt und erkannt HTTP Version 1.0 im Jahr 1996. Die HTTP WG plante, im Dezember 1995 neue Standards zu veröffentlichen und die Unterstützung für vorstandardisierte HTTP/1.1 auf Basis der damals entwickelten RFC 2068 (genannt HTTP-NG) wurde Anfang 1996 von den großen Browser-Entwicklern rasch übernommen. Die Endbenutzer-Adoption der neuen Browser war schnell. Im März 1996 berichtete ein Webhosting-Unternehmen, dass über 40 % der im Internet verwendeten Browser HTTP 1.1 konform waren. Dasselbe Webhosting-Unternehmen berichtete, dass bis Juni 1996 65% aller Browser, die auf ihre Server zugreifen, HTTP/1.1 konform waren. Der HTTP/1.1 Standard gemäß RFC 2068 wurde im Januar 1997 offiziell veröffentlicht. Verbesserungen und Aktualisierungen des HTTP/1.1-Standards wurden im Juni 1999 unter RFC 2616 veröffentlicht. Im Jahr 2007 wurde die HTTP-Arbeitsgruppe zum Teil gebildet, um die HTTP/1.1 Spezifikation zu aktualisieren und zu klären. Im Juni 2014 veröffentlichte die WG eine aktualisierte sechsteilige Spezifikation, die RFC 2616: RFC 7230, HTTP/1.1: Message Syntax and Routing RFC 7231, HTTP/1.1: Semantics and Content RFC 7232, HTTP/1.1:Conditional RFC 7233, HTTP/1.1: Range Requests RFC 7234, HTTP/1.1: Caching RFC 7235, HTTP/1.1: AuthenticationHTTP/2 wurde im Mai 2015 als RFC 7540 veröffentlicht. HTTP-Sitzung Eine HTTP-Session ist eine Sequenz von Netzwerkanfrage-Response-Transaktionen. Ein HTTP-Client initiiert eine Anfrage durch die Einrichtung einer Übertragungssteuerungsprotokollverbindung (TCP) zu einem bestimmten Port auf einem Server (typischerweise Port 80, gelegentlich Port 8080; siehe Liste der TCP- und UDP-Portnummern). Ein HTTP-Server, der auf diesem Port zuhört, wartet auf die Anforderungsnachricht eines Clients. Nach Erhalt der Anfrage sendet der Server eine Statuszeile wie "HTTP/1.1 200 OK" und eine eigene Nachricht zurück. Die Stelle dieser Nachricht ist typischerweise die angeforderte Ressource, obwohl auch eine Fehlermeldung oder andere Informationen zurückgegeben werden können. Persistente Verbindungen In HTTP/0.9 und 1.0 wird die Verbindung nach einem einzigen Anforderungs-/Antwortpaar geschlossen. In HTTP/1.1 wurde ein Keep-alive-Mechanismus eingeführt, bei dem eine Verbindung für mehr als eine Anfrage wiederverwendet werden konnte. Solche persistenten Verbindungen reduzieren die Anforderungslatenz spürbar, da der Client nach dem Senden der ersten Anfrage die TCP 3-Way-Handshake-Verbindung nicht neu verhandeln muss. Ein weiterer positiver Nebeneffekt ist, dass im Allgemeinen die Verbindung mit der Zeit aufgrund des langsamen Start-Mechanismus von TCP schneller wird. Version 1.1 des Protokolls hat auch Verbesserungen der Bandbreitenoptimierung auf HTTP/1.0 vorgenommen. Zum Beispiel, HTTP/1.1 eingeführt chunked transfer encoding, um Inhalte auf persistente Verbindungen zu streamen, anstatt gepuffert. HTTP Pipelining reduziert die Verzögerungszeit weiter, so dass Clients mehrere Anfragen senden, bevor sie auf jede Antwort warten. Eine weitere Ergänzung zum Protokoll war der Byte-Dienst, bei dem ein Server nur den von einem Client ausdrücklich angeforderten Teil einer Ressource sendet. HTTP-Sitzungszustand HTTP ist ein Stateless-Protokoll. Ein staatenloses Protokoll erfordert nicht, dass der HTTP-Server Informationen oder Status über jeden Benutzer für die Dauer mehrerer Anfragen behält. Einige Web-Anwendungen implementieren jedoch Zustände oder Server-Seitensitzungen mit beispielsweise HTTP-Cookies oder versteckten Variablen innerhalb von Web-Formularen. Die HTTP-Authentifizierung HTTP bietet mehrere Authentifizierungsschemata wie die grundlegende Authentifizierung des Zugriffs und die Authentifizierung des Zugriffs, die über einen Challenge-Response-Mechanismus funktionieren, wobei der Server eine Herausforderung identifiziert und ausgibt, bevor er den gewünschten Inhalt bedient. HTTP bietet einen allgemeinen Rahmen für die Zugriffskontrolle und Authentisierung, über eine umfangreiche Reihe von Challenge-Response-Authentifizierungs-Programmen, die von einem Server verwendet werden können, um eine Client-Anforderung herauszufordern und von einem Client zur Bereitstellung von Authentifizierungsinformationen. Authentikationsgebiete Die HTTP-Authentication-Spezifikation bietet auch ein willkürliches, implementierungsspezifisches Konstrukt für weitere, einer bestimmten Wurzel-URI gemeinsame Teilungsressourcen. Die Realm-Wert-String, falls vorhanden, wird mit der kanonischen Wurzel URI zu der Schutzraumkomponente der Herausforderung kombiniert.Dies ermöglicht es dem Server, separate Authentifizierungsbereiche unter einem Root-URI zu definieren. Nachrichten anfordern Syntax anfordern Ein Client sendet Anforderungsnachrichten an den Server, bestehend aus: einer Anforderungszeile, bestehend aus dem case-sensitiven Anfrageverfahren, einem Raum, dem Anforderungsziel, einem weiteren Raum, der Protokollversion, einer Schlittenrückgabe und einem Zeilenvorschub (z.B. GET-Bilder/logo.png HTTP/1.1;) null oder mehr Anforderungs-Headerfelder, jeweils bestehend aus dem case-insensitiven Feldnamen, einem Kolon, optional führendem Whitespace, dem Feld Whitespace, dem Feldwert, dem Feldwert, dem Feldwert, dem Feldwert, dem Feldwert, dem Feldwert und dem Feldwert, dem Feldwert, dem Feldwert, dem Feldwert, dem Feldwert, dem Feldwert und dem Feld, Im HTTP/1.1 Protokoll sind alle Headerfelder außer Host optional. Eine Anforderungszeile mit nur dem Pfadnamen wird von Servern akzeptiert, um die Kompatibilität mit HTTP-Clients vor der HTTP/1.0 Spezifikation in RFC 1945 zu erhalten. HTTP definiert Methoden (manchmal als Verben bezeichnet, aber nirgendwo in der Beschreibung erwähnt es Verb, noch ist OPTIONS oder HEAD ein Verb), um die gewünschte Aktion auf der identifizierten Ressource anzuzeigen. Was diese Ressource darstellt, ob bereits vorhandene Daten oder Daten, die dynamisch generiert werden, von der Implementierung des Servers abhängt. Oft entspricht die Ressource einer Datei oder der Ausgabe einer ausführbaren, auf dem Server zurückliegenden Datei. Die HTTP/1.0-Spezifikation definierte die Methoden GET, HEAD und POST und die HTTP/1.1-Spezifikation fügte fünf neue Methoden hinzu: PUT, DELETE, CONNECT, OPTIONS und TRACE. Durch die Angabe in diesen Dokumenten sind ihre Semantik bekannt und kann davon abhängen. Jeder Client kann jede Methode verwenden und der Server kann konfiguriert werden, um jede Kombination von Methoden zu unterstützen. Ist ein Verfahren einem Zwischenprodukt unbekannt, wird es als unsichere und nicht-idempotente Methode behandelt. Es gibt keine Grenzen für die Anzahl der Methoden, die definiert werden können, und dies ermöglicht es, zukünftige Methoden festzulegen, ohne bestehende Infrastruktur zu brechen. Beispielsweise definierte WebDAV sieben neue Methoden und RFC 5789 spezifizierte die PATCH-Methode. Method-Namen sind empfindlich. Dies steht im Gegensatz zu HTTP-Header-Feldnamen, die case-insensitive sind. GET Die GET-Methode verlangt, dass die Zielressource eine Darstellung ihres Zustands überträgt. GET-Anfragen sollten nur Daten abrufen und keinen anderen Effekt haben. ( Dies gilt auch für einige andere HTTP-Methoden.) Die W3C hat Leitlinien zu dieser Unterscheidung veröffentlicht und sagt: "Web Application Design sollte durch die oben genannten Prinzipien, aber auch durch die relevanten Einschränkungen informiert werden." Siehe unten sichere Methoden. HINWEIS Das HEAD-Verfahren fordert, dass die Zielressource eine Darstellung ihres Zustands überträgt, wie für eine GET-Anforderung, jedoch ohne die in der Antworteinrichtung eingeschlossenen Darstellungsdaten. Dies ist für das Abrufen der Darstellungsmetadaten im Antwortkopf nützlich, ohne die gesamte Darstellung übertragen zu müssen. POST Die POST-Methode verlangt, dass die Zielressource die in der Anfrage eingeschlossene Darstellung nach der Semantik der Zielressource verarbeitet. Es wird zum Beispiel verwendet, um eine Nachricht an ein Internet-Forum zu veröffentlichen, sich einer Mailingliste anzumelden oder eine Online-Shopping-Transaktion abzuschließen. PUT Die PUT-Methode verlangt, dass die Zielressource ihren Zustand mit dem durch die in der Anfrage eingeschlossene Darstellung definierten Zustand erstellt oder aktualisiert. DELE Das DELETE-Verfahren fordert, dass die Zielressource ihren Zustand löscht. INHALT Die CONNECT-Methode verlangt, dass der Intermediär einen TCP/IP-Tunnel an den durch das Anforderungsziel identifizierten Ursprungsserver festlegt. Es wird häufig verwendet, um Verbindungen über einen oder mehrere HTTP-Proxies mit TLS zu sichern. Siehe HTTP CONNECT-Methode. ABSCHNITT Die OPTIONS-Methode verlangt, dass die Zielressource die HTTP-Methoden überträgt, die sie unterstützt. Dies kann verwendet werden, um die Funktionalität eines Webservers zu überprüfen, indem man "*" anstelle einer bestimmten Ressource anfordert. TRACE Die TRACE-Methode verlangt, dass die Zielressource die empfangene Anfrage in der Antworteinrichtung überträgt. Auf diese Weise kann ein Client sehen, was (falls vorhanden) Änderungen oder Ergänzungen von Vermittlern gemacht wurden. PATCH Das PATCH-Verfahren verlangt, dass die Zielressource ihren Zustand nach dem in der Anfrage eingeschlossenen Darstellung definierten Teilupdate verändert. Alle allgemeinen HTTP-Server müssen mindestens die GET- und HEAD-Methoden implementieren, und alle anderen Methoden werden durch die Spezifikation als optional betrachtet. Sichere Methoden Eine Anforderungsmethode ist sicher, wenn eine Anfrage mit diesem Verfahren keinen beabsichtigten Effekt auf den Server hat.Die Methoden GET, HEAD, OPTIONS und TRACE sind als sicher definiert. Mit anderen Worten sollen sichere Verfahren nur gelesen werden. Sie schließen zwar keine Nebenwirkungen aus, z.B. das Anfordern von Informationen an eine Log-Datei oder das Laden eines Werbekontos, da sie vom Client nicht per Definition angefordert werden. Dagegen sind die Methoden POST, PUT, DELETE, CONNECT und PATCH nicht sicher. Sie können den Zustand des Servers ändern oder andere Effekte wie das Senden einer E-Mail haben. Solche Verfahren werden daher in der Regel nicht durch die Anpassung von Webrobotern oder Web-Crawlern verwendet; einige, die nicht übereinstimmen, neigen dazu, Anfragen ohne Bezug auf Kontext oder Konsequenzen zu machen. Trotz der vorgeschriebenen Sicherheit von GET-Anfragen ist in der Praxis ihre Handhabung durch den Server in keiner Weise technisch beschränkt. Daher kann eine sorgfältige oder bewusste Programmierung nicht-triviale Änderungen auf dem Server verursachen. Dies ist entmutigt, weil es Probleme für Web-Caching, Suchmaschinen und andere automatisierte Agenten verursachen kann, die unbeabsichtigte Änderungen auf dem Server vornehmen können. Beispielsweise kann eine Website das Löschen einer Ressource durch eine URL wie https://example.com/article/1234/delete zulassen, die, wenn willkürlich geraubt, auch mit GET, einfach den Artikel löschen würde. Ein Beispiel dafür war in der Praxis während der kurzlebigen Google Web Accelerator Beta, die willkürliche URLs auf der Seite ein Benutzer sah, wodurch Datensätze automatisch geändert oder gelöscht werden en masse. Die Beta wurde erst Wochen nach ihrer ersten Veröffentlichung nach weit verbreiteter Kritik ausgesetzt. Idempotente Methoden Eine Anforderungsmethode ist idempotent, wenn mehrere identische Anfragen mit diesem Verfahren dieselbe beabsichtigte Wirkung haben wie eine einzige solche Anfrage. Die Methoden PUT und DELETE und sichere Verfahren werden als idempotent definiert. Im Gegensatz dazu sind die Methoden POST, CONNECT und PATCH nicht notwendigerweise idempotent, und daher kann das Senden einer identischen POST-Anfrage mehrfach den Zustand des Servers weiter verändern oder weitere Effekte wie das Senden einer E-Mail haben. In einigen Fällen kann dies wünschenswert sein, aber in anderen Fällen könnte dies auf einen Unfall zurückzuführen sein, z.B. wenn ein Benutzer nicht erkennt, dass seine Handlung zu einer anderen Anfrage führen wird, oder sie erhielten keine ausreichende Rückmeldung, dass ihre erste Anfrage erfolgreich war. Während Web-Browser Alarm-Dialog-Boxen anzeigen können, um Benutzer zu warnen, in einigen Fällen, wo eine Seite neu laden kann eine POST-Anfrage, es ist in der Regel bis zu der Web-Anwendung zu behandeln Fälle, wo eine POST-Anfrage sollte nicht mehr als einmal eingereicht werden. Beachten Sie, ob eine Methode idempotent nicht durch das Protokoll oder Webserver durchgesetzt wird. Es ist durchaus möglich, eine Webapplikation zu schreiben, bei der (z.B.) ein Datenbankeinsatz oder eine andere nicht-idempotente Aktion durch eine GET oder andere Anfrage ausgelöst wird. Diese Empfehlung kann jedoch zu unerwünschten Folgen führen, wenn ein Nutzervertreter annimmt, dass eine Wiederholung derselben Anforderung sicher ist, wenn er nicht ist. Cacheable Methoden Eine Anforderungsmethode ist abspeicherbar, wenn Antworten auf Anfragen mit diesem Verfahren zur zukünftigen Wiederverwendung gespeichert werden können. Die Methoden GET, HEAD und POST werden als Cacheable definiert. Dagegen sind die Methoden PUT, DELETE, CONNECT, OPTIONS, TRACE und PATCH nicht sperrbar. Kopffelder anfordern Fordern Sie Headerfelder an, damit der Client zusätzliche Informationen über die Anforderungszeile weitergeben kann, die als Anforderungs-Modifier (ähnlich den Parametern eines Verfahrens) dienen. Sie geben Informationen über den Client, über die Zielressource oder über die erwartete Bearbeitung der Anfrage. Antwort-Syntax Ein Server sendet Antwortnachrichten an den Client, die aus: einer Statuszeile, bestehend aus der Protokollversion, einem Raum, dem Antwortstatuscode, einem anderen Raum, einem möglicherweise leeren Grundphrase, einer Kutscherückgabe und einem Zeilenfeed (z.B. HTTP/1.1 200 OK);Null- oder mehr Antwort-Header-Felder, jeweils bestehend aus dem case-insensitiven Feldnamen, einem Kolon, optionalem führenden Whitespace, dem Feldtyp und optionalem Rückgabe-Typ, und optionalem Rückgabe- und optionalem Nachlauftext. Antwortstatuscodes In HTTP/1.0 und da die erste Zeile der HTTP-Antwort die Statuszeile genannt wird und einen numerischen Statuscode (wie 404) und einen Textgrundsatz (wie "Nicht gefunden") enthält. Der Antwortstatuscode ist ein dreistelliger Ganzzahlcode, der das Ergebnis des Versuches des Servers darstellt, die entsprechende Anforderung des Clients zu verstehen und zu befriedigen.Die Art und Weise, wie der Client die Antwort behandelt, hängt in erster Linie vom Statuscode und zweitens von den anderen Antwort-Header-Feldern ab. Kunden können nicht alle registrierten Statuscodes verstehen, aber sie müssen ihre Klasse verstehen (gegeben durch die erste Ziffer des Statuscodes) und einen nicht erkannten Statuscode als gleichwertig mit dem x00 Statuscode dieser Klasse behandeln. Die Standardgrundsätze sind nur Empfehlungen und können nach Ermessen des Web-Entwicklers durch "lokale Äquivalente" ersetzt werden. Wenn der Statuscode ein Problem angegeben hat, kann der Benutzer Agent den Grundphrasen dem Benutzer anzeigen, um weitere Informationen über die Art des Problems bereitzustellen. Der Standard erlaubt es dem Benutzer auch, den Grundsatz zu interpretieren, obwohl dies unsinnig sein könnte, da der Standard explizit festlegt, dass Statuscodes maschinenlesbar sind und Grundphrasen human lesbar sind. Die erste Ziffer des Statuscodes definiert seine Klasse: 1XX (informational)Die Anfrage wurde empfangen, fortgesetzt. 2XX (erfolgreich)Die Anfrage wurde erfolgreich empfangen, verstanden und akzeptiert.3XX (Umleitung)Weitere Maßnahmen müssen ergriffen werden, um die Anfrage abzuschließen. 4XX (Client-Fehler) Die Anfrage enthält schlechte Syntax oder kann nicht erfüllt werden. 5XX (Serverfehler)Der Server konnte eine offensichtlich gültige Anfrage nicht erfüllen. Response Header Felder Die Antwort-Header-Felder ermöglichen es dem Server, zusätzliche Informationen über die Statuszeile zu übermitteln, die als Antwort-Modifier fungieren. Sie geben Informationen über den Server oder einen weiteren Zugriff auf die Zielressource oder verwandte Ressourcen. Jedes Antwort-Header-Feld hat eine definierte Bedeutung, die durch die Semantik des Anforderungs- oder Antwortstatuscodes weiter verfeinert werden kann. Verschlüsselte Verbindungen Die beliebteste Art der Erstellung einer verschlüsselten HTTP-Verbindung ist HTTPS. Es gibt auch zwei andere Methoden zur Erstellung einer verschlüsselten HTTP-Verbindung: Secure Hypertext Transfer Protocol und mit dem HTTP/1.1 Upgrade-Header ein Upgrade auf TLS angeben. Browser-Unterstützung für diese beiden ist jedoch fast nicht vorhanden. Beispielsitzung Im Folgenden ist ein Beispielgespräch zwischen einem HTTP-Client und einem HTTP-Server unter www.example.com, Port 80. Nach einer Client-Anfrage (in diesem Fall der Anfragezeile und nur einem Headerfeld) folgt eine leere Zeile, so dass die Anfrage mit einer Doppel-Neuzeile endet, die jeweils in Form einer Schlitten-Rückgabe gefolgt von einem Line-Feed. Das Host-Feld unterscheidet zwischen verschiedenen DNS-Namen, die eine einzelne IP-Adresse teilen, wodurch eine namenbasierte virtuelle Hosting ermöglicht wird. Während optional in HTTP/1.0, es ist obligatorisch in HTTP/1.1.(A "/" (slash) wird in der Regel eine /index.html-Datei holen, wenn es eine gibt.) Server-Antwort Das ETag (Entity-Tag)-Headerfeld wird verwendet, um festzustellen, ob eine geätzte Version der angeforderten Ressource mit der aktuellen Version der Ressource auf dem Server identisch ist. Content-Type gibt den Internet-Medientyp der von der HTTP-Nachricht übermittelten Daten an, während Content-Length seine Länge in Bytes angibt. Der HTTP/1.1 Webserver veröffentlicht seine Fähigkeit, auf Anfragen für bestimmte Byte-Bereiche des Dokuments zu reagieren, indem er das Feld Accept-Ranges: bytes. Dies ist nützlich, wenn der Client nur bestimmte Teile einer vom Server gesendeten Ressource, die Byte-Dienst aufgerufen wird, haben muss. Wenn Connection: close gesendet wird, bedeutet das, dass der Webserver die TCP-Verbindung unmittelbar nach der Übertragung dieser Antwort schließen wird. Die meisten Header-Linien sind optional. Wenn Content-Length fehlt, wird die Länge auf andere Weise bestimmt. Chunked Transfer Coding verwendet eine Stückgröße von 0, um das Ende des Inhalts zu markieren. Identitätscodierung ohne Content-Length liest Inhalt, bis die Steckdose geschlossen ist. Mit einem Content-Encoding wie gzip können die übertragenen Daten komprimiert werden. Ähnliche Protokolle Das Gopher-Protokoll ist ein Content-Lieferungsprotokoll, das Anfang der 1990er Jahre durch HTTP verschoben wurde. Das SPDY-Protokoll ist eine Alternative zu HTTP, die bei Google entwickelt wurde und durch HTTP/2 ersetzt wurde. Das Gemini-Protokoll ist ein Gopher-inspiriertes Protokoll, das datenschutzbezogene Merkmale benötigt. Siehe auch Vergleich von Dateiübertragungsprotokollen Einschränktes Application Protocol – ein semantisch ähnliches Protokoll zu HTTP, aber verwendete UDP- oder UDP-ähnliche Nachrichten, die für Geräte mit eingeschränkter Verarbeitungsfähigkeit gezielt sind; verwendet HTTP und andere Internet-Konzepte wie Internet-Medientyp und Web-Linking (RFC 5988) Inhaltsverhandlungen Digest Access Authentifizierung HTTP Kompression HTTP/2 – entwickelt durch das Hypertext Transfer Protocol (httpbis) Arbeitsgruppe Liste der HTTP-Headerfelder Liste der HTTP-Statuscodes Representational state transfer (REST) Variant Objekt Web cache WebSocket Referenzen Externe Links "Change History for HTTP".W3.org.Retrieved 2010-08-01. Eine detaillierte technische Geschichte von HTTP."Design-Ausgaben für HTTP".W3.org.Retrieved 2010-08-01.Design-Ausgaben von Berners-Lee, als er das Protokoll entworfen hatte. HTTP 0.9 – Wie 1991 umgesetzt