Bei der Berechnung ist ein Namespace eine Reihe von Zeichen (Namen), die verwendet werden, um Objekte verschiedener Art zu identifizieren und zu verweisen. Ein Namespace sorgt dafür, dass alle ein bestimmter Satz von Objekten einzigartige Namen haben, damit sie leicht identifiziert werden können. Namespaces sind häufig als Hierarchien strukturiert, um eine Wiederverwendung von Namen in verschiedenen Kontexten zu ermöglichen. Als Analogie betrachten Sie ein System der Benennung von Menschen, in denen jede Person einen bestimmten Namen hat, sowie einen Familiennamen, der mit ihren Verwandten geteilt wird. Wenn die ersten Namen der Familienmitglieder nur innerhalb jeder Familie einzigartig sind, dann kann jede Person eindeutig durch die Kombination von Vorname und Familienname identifiziert werden; es gibt nur eine Jane Doe, obwohl es viele Janes geben kann. Im Namensraum der Familie Doe reicht nur Jane aus, um diese Person eindeutig zu bezeichnen, während im globalen Namensraum aller Menschen der vollständige Name verwendet werden muss. Prominente Beispiele für Namespaces umfassen Dateisysteme, die Dateien Namen zuordnen. Einige Programmiersprachen organisieren ihre Variablen und Unterprogramme in Namensräumen. Computernetzwerke und verteilte Systeme übertragen Ressourcen, wie Computer, Drucker, Websites und Remotedateien. Betriebssysteme können Kernelressourcen durch isolierte Namespaces aufteilen, um Virtualisierungsbehälter zu unterstützen. In ähnlicher Weise organisieren hierarchische Dateisysteme Dateien in Verzeichnissen. Jedes Verzeichnis ist ein separater Namespace, so dass die Verzeichnisse Buchstaben und Rechnungen beide eine Datei to_jane enthalten können". Bei der Computerprogrammierung werden typischerweise Namespaces verwendet, um Symbole und Kennungen um eine bestimmte Funktionalität zu gruppieren und Namenskollisionen zwischen mehreren Kennungen zu vermeiden, die denselben Namen teilen. Bei der Vernetzung organisiert das Domain Name System Webseiten (und andere Ressourcen) in hierarchische Namensräume. Namenskonflikte Elementnamen werden vom Entwickler definiert. Dies führt oft zu einem Konflikt, wenn man versucht, XML-Dokumente aus verschiedenen XML-Anwendungen zu mischen. Dieses XML enthält HTML-Tabelleninformationen: Dieses XML führt Informationen über eine Tabelle (d.h. ein Möbelstück): Wenn diese XML-Fragmente zusammen hinzugefügt wurden, gäbe es einen Namenskonflikt. Beide enthalten ein Tabelle>/Tabellenelement, aber die Elemente haben unterschiedlichen Inhalt und Bedeutung. Ein XML-Parser weiß nicht, wie man diese Unterschiede behandelt. Lösung über Prefix Name Konflikte in XML lässt sich einfach mit einem Namens-Präfix vermeiden. Das folgende XML unterscheidet zwischen Informationen über die HTML-Tabelle und die Möbel, indem h und f zu Beginn der Elemente vorfixiert werden. Ein Name in einem Namensraum besteht aus einem Namensraumnamen und einem lokalen Namen. Der Namespacename wird üblicherweise als Präfix auf den lokalen Namen angewendet. In augmented Backus–Naur Form: name = <namespace name> Separator <local name> Wenn lokale Namen von sich selbst verwendet werden, wird die Namensauflösung verwendet, um zu entscheiden, auf welche (sofern irgendeine) bestimmte Bezeichnung von einem bestimmten lokalen Namen bezogen wird. Beispiele Die Delegationsdelegation der Verantwortlichkeiten zwischen den Parteien ist wichtig in realen Anwendungen, wie der Struktur des World Wide Web. Namespaces ermöglichen die Übertragung von Identifikationszuweisungen an mehrere Namensausgabeorganisationen unter Beibehaltung der globalen Einzigartigkeit. Eine zentrale Registrierungsbehörde registriert die zugewiesenen Namenspace-Namen. Jeder Namespace-Name wird einer Organisation zugewiesen, die anschließend für die Zuordnung von Namen in ihrem zugewiesenen Namespace verantwortlich ist. Diese Organisation kann eine Namensausgabeorganisation sein, die die Namen selbst zuordnet, oder eine andere Registrierungsbehörde, die Teile ihres Namensraums an verschiedene Organisationen weiterleitet. Hierarchie Ein Benming-Programm, das die Subdelegation von Namensräumen an Dritte ermöglicht, ist ein hierarchischer Namespace. Eine Hierarchie ist rekursiv, wenn die Syntax für die Namenspace-Namen für jede Subdelegation gleich ist. Ein Beispiel für eine wiederkehrende Hierarchie ist das Domain Name System. Ein Beispiel für eine nicht-rekursive Hierarchie ist der einheitliche Ressourcenname, der eine Internet zugewiesene Nummern Authority (IANA)-Nummer repräsentiert. Namespace gegen Umfang Ein Namespace-Name kann einem Namen einen Kontext (scope in der Informatik) zur Verfügung stellen, und die Begriffe werden manchmal austauschbar verwendet. Der Kontext eines Namens kann jedoch auch durch andere Faktoren, wie den Ort, an dem er auftritt oder die Syntax des Namens, bereitgestellt werden. In Programmiersprachen Für viele Programmiersprachen ist Namespace ein Kontext für ihre Kennungen. In einem Betriebssystem ist ein Beispiel von Namespace ein Verzeichnis. Jeder Name in einem Verzeichnis identifiziert eine Datei oder Unterverzeichnis eindeutig. In der Regel können Namen in einem Namensraum nicht mehr als eine Bedeutung haben; d.h. unterschiedliche Bedeutungen können den gleichen Namen nicht im gleichen Namensraum teilen. Ein Namespace wird auch als Kontext bezeichnet, da der gleiche Name in verschiedenen Namensräumen unterschiedliche Bedeutungen haben kann, die jeweils für seinen Namensraum geeignet sind. Im Folgenden sind andere Merkmale von Namensräumen: Namen im Namenraum können sowohl Objekte als auch Konzepte darstellen, sei der Nameraum eine natürliche oder ethnische Sprache, eine konstruierte Sprache, die technische Terminologie eines Berufes, ein Dialekt, ein Soziolekt oder eine künstliche Sprache (z.B. eine Programmiersprache). In der Java-Programmiersprache haben Kennungen, die in Namespaces erscheinen, einen kurzen (lokalen) Namen und einen einzigartigen langen qualifizierten Namen für den Einsatz außerhalb des Namensraums. Einige Compiler (für Sprachen wie C+) kombinieren Namensräume und Namen für den internen Gebrauch im Compiler in einem Prozess namens Mangling. Neben seiner abstrakten sprachtechnischen Nutzung, wie oben beschrieben, haben einige Sprachen unter anderem ein bestimmtes Schlüsselwort für die explizite Namensraumkontrolle. Unten ist ein Beispiel für einen Namensraum in C+: Ein Namespace in der Informatik (manchmal auch Namensbereich genannt), ist ein abstrakter Behälter oder eine Umgebung, die erstellt wird, um eine logische Gruppierung von eindeutigen Kennungen oder Symbolen (d.h. Namen) zu halten. Eine in einem Namensraum definierte Kennung ist nur diesem Namensraum zugeordnet. Die gleiche Kennung kann in mehreren Namensräumen unabhängig definiert werden. Das heißt, eine in einem Namensraum definierte Kennung kann oder darf die gleiche Bedeutung haben wie die gleiche Kennung, die in einem anderen Namensraum definiert ist. Sprachen, die Namespaces unterstützen, geben die Regeln an, die festlegen, zu welchem Namespace eine Kennung (nicht ihre Definition) gehört. Dieses Konzept kann mit einer Analogie dargestellt werden. Stellen Sie sich vor, dass zwei Unternehmen, X und Y, jeweils ID-Nummern ihren Mitarbeitern zuweisen. X sollte nicht zwei Mitarbeiter mit der gleichen ID-Nummer haben, und ebenso für Y; aber es ist kein Problem für die gleiche ID-Nummer bei beiden Unternehmen verwendet werden. Zum Beispiel, wenn Bill für die Firma X und Jane arbeitet für die Firma Y, dann ist es kein Problem, dass jeder von ihnen Mitarbeiter #123 sein. In dieser Analogie ist die ID-Nummer die Kennung, und das Unternehmen dient als Namespace. Es verursacht keine Probleme für dieselbe Kennung, eine andere Person in jedem Namensraum zu identifizieren. In großen Computerprogrammen oder Dokumenten ist es üblich, Hunderte oder Tausende von Kennungen zu haben. Namespaces (oder eine ähnliche Technik, siehe Namespaces speichern) bieten einen Mechanismus zum Verstecken von lokalen Kennungen. Sie stellen ein Mittel zur Gruppierung von logisch verwandten Kennungen in entsprechende Namensräume bereit, wodurch das System modularer wird. Datenspeicher und viele moderne Programmiersprachen unterstützen Namensräume. Speichergeräte verwenden Verzeichnisse (oder Ordner) als Namespaces. Dadurch können zwei Dateien mit demselben Namen auf dem Gerät gespeichert werden, solange sie in verschiedenen Verzeichnissen gespeichert sind. In einigen Programmiersprachen (z.B. C,+ Python) sind die Kennungen Namensräume selbst mit einem umschließenden Namensraum verbunden. So können Namensräume in diesen Sprachen nisten und einen Namensraumbaum bilden. An der Wurzel dieses Baumes ist der nicht genannte globale Namespace. CIt kann seit C99 anonyme Befehle als Namensräume in C verwenden. C++In C,+ wird ein Namespace mit einem Namenspace-Block definiert. In diesem Block können Kennungen genau verwendet werden, wie sie angegeben werden. Außerhalb dieses Blocks muss der Namespace-Spezifikator vorfixiert werden. So muss z.B. außerhalb des Namensraums abc die Bar abc geschrieben werden:bar zuzugreifen. C+ enthält ein weiteres Konstrukt, das diese Verbenheit unnötig macht. Durch das Hinzufügen der Zeile zu einem Stück Code wird das Präfix abc: nicht mehr benötigt. Identifikatoren, die nicht explizit in einem Namensraum angegeben werden, gelten als im globalen Namensraum. Diese Kennungen können genauso verwendet werden, wie sie angegeben werden, oder, da der globale Namespace nicht benannt ist, der Namespace-Spezifikator::: kann vorfixiert werden. Beispielsweise kann foo auch geschrieben werden :foo. Die Namespace-Auflösung in C+ ist hierarchisch. Dies bedeutet, dass innerhalb der hypothetischen Namespace-Food::soup, die Kennung Huhn bezieht sich auf Nahrung::soup::chicken. Wenn Nahrung:: Suppe:: Huhn nicht existiert, dann bezieht es sich auf Nahrung:: Huhn. Wenn weder Nahrung:: Suppe:: Huhn noch Nahrung:: Huhn vorhanden ist, bezieht sich Huhn auf : Huhn, eine Kennung im globalen Namensraum. Namensräume in C+ werden am häufigsten verwendet, um Kollisionen zu vermeiden. Obwohl Namespaces in den letzten C+-Code verwendet werden, verwenden die meisten älteren Codes diese Einrichtung nicht, weil sie in frühen Versionen der Sprache nicht existierten. Beispielsweise wird die gesamte C+ Standard-Bibliothek im Namensraum std definiert, aber vor der Standardisierung waren viele Komponenten ursprünglich im globalen Namensraum. Ein Programmierer kann die Verwendungsrichtlinie einfügen, um die Anforderungen an die Namespace-Auflösung zu umgehen und eine Rückwärtskompatibilität mit einem älteren Code zu erhalten, der erwartet, dass alle Kennungen im globalen Namensraum liegen. Die Verwendung der Verwendungsrichtlinie aus anderen Gründen als der Rückwärtskompatibilität (z.B. Bequemlichkeit) gilt jedoch als gegen gute Code-Praktiken. Java InJava ist die Idee eines Namensraums in Java-Paketen verkörpert. Alle Code gehört zu einem Paket, obwohl dieses Paket nicht explizit benannt werden muss. Der Code aus anderen Paketen wird durch Vorfixieren des Paketnamens vor der entsprechenden Kennung, z.B. Klasse String in Paket Java, aufgerufen. lang kann als java.lang bezeichnet werden. String (dies ist als vollständig qualifizierter Klassenname bekannt). Wie C,+ Java bietet ein Konstrukt, das es unnötig macht, den Paketnamen (Import) einzutragen. Einige Merkmale (z.B. Reflexion) erfordern jedoch den Programmierer, den vollqualifizierten Namen zu verwenden. Im Gegensatz zu C sind+ Namespaces in Java nicht hierarchisch, was die Syntax der Sprache betrifft. Pakete werden jedoch hierarchisch genannt. Zum Beispiel sind alle Pakete, die mit Java beginnen, Teil der Java-Plattform – das Paket java.lang enthält Klassenkern zur Sprache und java.lang. reflektieren enthält Kernklassen, die sich speziell auf Reflexion beziehen. In Java (und Ada, C,# und anderen) drücken Namespaces/Pakete semantische Codekategorien aus. Zum Beispiel enthält in C # Namespace System Code, der vom System bereitgestellt wird (das .NET Framework). Wie spezifisch diese Kategorien sind und wie tief die Hierarchien von Sprache zu Sprache abweichen. Funktionen und Klassenbereiche können als implizite Namensräume angesehen werden, die untrennbar mit Sichtbarkeit, Zugänglichkeit und Objektlebensdauer verbunden sind. C#Namespaces werden in C#-Sprache stark verwendet. Alle .NETFramework-Klassen werden in Namensräumen organisiert, um klarer verwendet und Chaos zu vermeiden. Darüber hinaus werden benutzerdefinierte Namespaces von Programmierern umfassend genutzt, um ihre Arbeit zu organisieren und Kollisionen zu vermeiden. Bei der Befassung einer Klasse sollte entweder ihr vollständig qualifizierter Name angegeben werden, d.h. Namespace, gefolgt vom Klassennamen, oder eine Verwendungserklärung hinzufügen. Damit entfällt die Notwendigkeit, den vollständigen Namen aller Klassen in diesem Namensraum zu erwähnen. In den obigen Beispielen ist System ein Namespace und Konsole und Konvertieren sind Klassen definiert innerhalb von System. PythonIn Python werden durch die einzelnen Module Namensräume definiert, und da Module in hierarchischen Paketen enthalten sein können, sind auch Namespaces hierarchisch. Generell werden beim Import eines Moduls die im Modul definierten Namen über den Namensraum dieses Moduls definiert und durch den vollqualifizierten Namen von den rufenden Modulen eingegriffen. Die von ... import ... Erklärung kann verwendet werden, um die relevanten Namen direkt in den Namensraum des rufenden Moduls einzufügen, und diese Namen können ohne den qualifizierten Namen vom rufenden Modul aufgerufen werden: Da diese direkt Namen importieren (ohne Qualifikation) kann es bestehende Namen ohne Warnung überschreiben. Eine besondere Form der Erklärung ist der Import *, der alle im benannten Paket definierten Namen direkt in den Namensraum des rufenden Moduls importiert. Die Verwendung dieser Art von Import, obwohl innerhalb der Sprache unterstützt, wird in der Regel entmutigt, da sie den Namensraum des rufenden Moduls abfragt und bei Namenskonflikten bereits definierte Namen überschrieben werden. Python unterstützt auch Import x als y als eine Möglichkeit, einen Alias oder einen alternativen Namen für die Nutzung durch das rufende Modul bereitzustellen: XML Namespace In XML ermöglicht die XML-Namespace-Spezifikation die Namen von Elementen und Attributen in einem XML-Dokument einzigartig zu sein, ähnlich der Rolle von Namespaces in Programmiersprachen. Mit XML-Namespaces können XML-Dokumente Element- oder Attributnamen aus mehr als einem XML-Vokabular enthalten. PHPNamespaces wurden ab Version 5.3 in PHP eingeführt. Die Namenskollision von Klassen, Funktionen und Variablen kann vermieden werden. In PHP wird ein Namespace mit einem Namespace-Block definiert. Wir können einen PHP-Namensraum mit folgenden unterschiedlichen Möglichkeiten referenzieren: Namespaces generieren In Programmiersprachen, die keine Sprachunterstützung für Namespaces haben, können Namespaces in gewissem Maße durch eine Kennung Namenskonvention emuliert werden. Beispielsweise verwenden C-Bibliotheken wie libpng für alle Funktionen und Variablen, die Teil ihrer exponierten Schnittstelle sind, häufig ein festes Präfix. Libpng legt Kennungen wie: png_create_write_struct vor Png_get_signatur png_read_row png_set_invalid Diese Benming-Konvention bietet eine angemessene Sicherheit, dass die Identifikatoren einzigartig sind und daher in größeren Programmen ohne Namensaufprall verwendet werden können. Ebenso behalten viele Pakete, die ursprünglich in Fortran (z.B. BLAS, LAPACK) geschrieben wurden, die ersten Buchstaben des Namens einer Funktion vor, um anzuzeigen, zu welcher Gruppe sie gehört. Diese Technik hat mehrere Nachteile: Es skaliert nicht gut, Namensräume zu verschachteln; Identifikatoren werden zu lange, da alle Verwendungen der Identifikatoren vollständig namespace-qualifiziert sein müssen. Individuen oder Organisationen können inkonsistente Benennungskonventionen verwenden, die möglicherweise unerwünschte Fettbildung einführen. Verbindungen oder Abfragen basierende Operationen auf Gruppen von Kennungen, basierend auf den Namensräumen, in denen sie angegeben sind, werden unhandlich oder undurchführbar gemacht. In Sprachen mit eingeschränkter Kennung Länge begrenzt die Verwendung von Präfixen die Anzahl der Zeichen, die verwendet werden können, um zu identifizieren, was die Funktion tut. Dies ist ein besonderes Problem für Pakete, die ursprünglich in FORTRAN 77 geschrieben wurden, die nur 6 Zeichen pro Kennung angeboten haben. Beispielsweise zeigt der Name der BLAS-Funktion DGEMM-Funktion an, dass sie auf Doppelpräzisionsnummern (D) und Generalmatrizen (GE) arbeitet und nur die letzten beiden Zeichen zeigen, was es tatsächlich tut: Matrix-Matrix-Multiplikation (die MM"). Es gibt mehrere Vorteile: Es sind keine speziellen Software-Tools erforderlich, um Namen in Quellcode-Dateien zu finden. Ein einfaches Programm wie Grepsuffices. Es gibt keine Namensraum Namenskonflikte. Es besteht kein Bedarf an Namensvervielfältigung und damit keine möglichen Unvereinbarkeitsprobleme. Siehe auch 11-stellige Lieferstelle ZIP-CodeBinomial Nomenklatur (genus-species in biology)Khemische Nomenklatur Dewey Decimal Classification Digitale Objekt-Identifier Domain Name System Identity (objektorientierte Programmierung)Library of Congress Classification Star Kataloge und astronomische Namenskonventionen XML Namespace Argument-abhängiger Name Lookup == Referenzen ==