Ein byzantinischer Fehler (auch interaktive Konsistenz, Quellenkongruenz, Fehler Lawine, byzantinisches Vertragsproblem, byzantinisches Generalsproblem und byzantinisches Versagen) ist ein Zustand eines Computersystems, insbesondere verteilte Computersysteme, wo Komponenten ausfallen können und es unvollkommene Informationen darüber gibt, ob eine Komponente ausgefallen ist. Der Begriff nimmt seinen Namen von einer Allegorie, das "Byzantine Generals Problem", entwickelt, um eine Situation zu beschreiben, in der, um katastrophale Versagen des Systems zu vermeiden, die Akteure des Systems auf eine konzertierte Strategie zu vereinbaren, aber einige dieser Akteure sind unzuverlässig. In einem byzantinischen Fehler kann eine Komponente wie ein Server uneinheitlich erscheinen, sowohl gescheitert als auch funktionsfähig zu Fehlererkennungssystemen, die unterschiedliche Symptome für verschiedene Beobachter darstellen. Es ist schwierig für die anderen Komponenten zu erklären, dass es gescheitert ist und aus dem Netzwerk ausgeschaltet wird, weil sie zunächst einen Konsens erreichen müssen, in dem die Komponente überhaupt versagt hat. Byzantinische Fehlertoleranz (BFT) ist die Zuverlässigkeit eines fehlertoleranten Computersystems zu solchen Bedingungen. Merkmale Ein byzantinischer Fehler ist jeder Fehler, der verschiedene Symptome für verschiedene Beobachter darstellt. Ein byzantinischer Ausfall ist der Verlust eines Systemdienstes aufgrund einer byzantinischen Störung in Systemen, die Konsens erfordern. Das Ziel der byzantinischen Fehlertoleranz ist es, gegen Störungen von Systemkomponenten mit oder ohne Symptome zu verteidigen, die verhindern, dass andere Komponenten des Systems untereinander eine Einigung erzielen, wenn eine solche Vereinbarung für den korrekten Betrieb des Systems erforderlich ist. Die verbleibenden betriebsrichtigen Komponenten eines byzantinischen Fehlertolerantensystems können den ursprünglich vorgesehenen Service des Systems weiter bereitstellen, vorausgesetzt, es gibt eine ausreichende Anzahl von genau arbeitenden Komponenten, um den Service aufrechtzuerhalten. Byzantinische Versagen gelten als die allgemeinste und schwierigste Klasse von Versagen unter den Ausfallmodi. Der sogenannte Fail-Stop-Versagensmodus nimmt das einfachste Ende des Spektrums ein. Während der Fail-Stop-Fehlermodus einfach bedeutet, dass der einzige Weg zum Failen ein von anderen Knoten erkannter Knotenunfall ist, beinhalten Byzantinische Fehler keine Einschränkungen, was bedeutet, dass der gescheiterte Knoten willkürliche Daten erzeugen kann, einschließlich Daten, die es wie ein funktionierender Knoten erscheinen lassen. Byzantinische Fehler können somit Fehlererkennungssysteme verwechseln, was die Fehlertoleranz erschwert. Trotz der Analogie ist ein byzantinischer Ausfall nicht unbedingt ein Sicherheitsproblem mit feindlichen menschlichen Störungen: es kann rein aus elektrischen oder Softwarefehlern entstehen. Die Begriffe Fehler und Versagen werden hier nach den Standarddefinitionen verwendet, die ursprünglich von einem gemeinsamen Ausschuss für "Fundamental Concepts and Terminology" des Technischen Ausschusses der IEEE-Computergesellschaft für Dependable Computing and Fault Tolerance und der IFIP Working Group 10.4 über Dependable Computing and Fault Tolerance erstellt wurden. Eine Version dieser Definitionen wird auch auf der Seite Dependability Wikipedia beschrieben. Caveat Byzantine Fehlertoleranz betrifft nur die Broadcast-Korrektur, d.h. die Eigenschaft, dass, wenn eine Komponente einen einheitlichen Wert auf andere Komponenten sendet (d.h. den gleichen Wert an die anderen Komponenten sendet), sie alle genau den gleichen Wert erhalten, oder wenn der Broadcaster nicht konsistent ist, stimmen die anderen Komponenten auf einem gemeinsamen Wert überein. Diese Art von Fehlertoleranz umfasst nicht die Korrektheit des Wertes selbst, z.B. eine adversariale Komponente, die bewusst einen falschen Wert sendet, sondern diesen Wert konsequent an alle Komponenten sendet, wird nicht im byzantinischen Fehlertoleranzschema erfasst. Formale Definition Einstellung:Gegeben einem System von n Komponenten, von denen t unehrlich sind, und vorausgesetzt nur Punkt-zu-Punkt-Kanal zwischen allen Komponenten. Wann immer eine Komponente Ein Versuch, einen Wert x zu übertragen, die anderen Komponenten sind erlaubt, miteinander zu diskutieren und die Konsistenz von A's Sendung überprüfen, und schließlich auf einem gemeinsamen Wert y. Eigentum: Das System soll Byzantinischen Fehlern widerstehen, wenn eine Komponente A einen Wert x aussenden kann, und dann: Wenn A ehrlich ist, dann stimmen alle ehrlichen Komponenten dem Wert x zu. In jedem Fall vereinbaren alle ehrlichen Komponenten den gleichen Wert y. Varianten: Das Problem wurde bei synchroner und asynchroner Kommunikation untersucht. Der vorstehende Kommunikationsgraph wird als vollständiges Diagramm angenommen (d.h. jede Komponente kann miteinander diskutieren), aber der Kommunikationsgraph kann eingeschränkt werden. Es kann auch in einem realistischeren Problem entspannt werden, bei dem die fehlerhaften Komponenten nicht zusammenfallen, um die anderen in Fehler zu locken. In dieser Einstellung wurden praktische Algorithmen entwickelt. Geschichte Das Problem, den byzantinischen Konsens zu erhalten, wurde von Robert Shostak konzipiert und formalisiert, der ihm das interaktive Konsistenzproblem übergab. Diese Arbeit wurde 1978 im Rahmen des NASA-geförderten SIFT-Projekts im Computer Science Lab von SRI International durchgeführt. SIFT (für Software Implemented Fault Tolerance) war das Gehirn Kind von John Wensley, und basierte auf der Idee, mehrere allgemeine Computer zu verwenden, die durch paarweise Messaging kommunizieren würde, um einen Konsens zu erreichen, auch wenn einige der Computer fehlerhaft waren. Zu Beginn des Projekts war nicht klar, wie viele Computer insgesamt benötigt werden, um zu gewährleisten, dass eine Verschwörung von n fehlerhaften Computern die Bemühungen der richtig funktionierenden nicht behindern konnte, um Konsens zu erreichen. Shostak zeigte, dass ein Minimum von 3n+1 benötigt wird und ein zwei-round 3n+1 Messaging-Protokoll entwickelt, das für n=1 funktionieren würde. Sein Kollege Marshall Pease verallgemeinerte den Algorithmus für jede n > 0 und bewies, dass 3n+1 sowohl notwendig als auch ausreichend ist. Diese Ergebnisse wurden zusammen mit einem späteren Nachweis von Leslie Lamport über die Sufficiency von 3n unter Verwendung digitaler Signaturen in der Halbzeitschrift, Pfarrvertrag in der Gegenwart von Fehlern veröffentlicht. Die Autoren erhielten den Edsger W. Dijkstra-Preis 2005 für diese Arbeit. Um das interaktive Konsistenzproblem leichter zu verstehen, hat Lamport eine bunte Allegorie entwickelt, in der eine Gruppe von Armee Generale einen Plan für den Angriff einer Stadt formuliert. In seiner Originalversion warf die Geschichte die Generale als Kommandanten der albanischen Armee. Der Name wurde geändert, schließlich auf Byzantine, auf den Vorschlag von Jack Goldberg, um zukunftssicher jede mögliche Offense geben. Diese Formulierung des Problems, zusammen mit einigen zusätzlichen Ergebnissen, wurden von den gleichen Autoren in ihrem 1982, "The Byzantine Generals Problem" präsentiert. Analogie In seiner einfachsten Form greifen einige Generäle eine Festung an und müssen als Gruppe nur entscheiden, ob sie angreifen oder sich zurückziehen. Einige Generäle mögen es vorziehen, anzugreifen, während andere lieber zurückziehen. Wichtig ist, dass alle Generäle eine gemeinsame Entscheidung treffen, denn ein halbherziger Angriff von einigen Generalen würde zu einem Rout werden, und wäre schlimmer als ein koordinierter Angriff oder ein koordinierter Rückzug. Das Problem ist kompliziert durch die Anwesenheit von verräterischen Generalen, die nicht nur eine Abstimmung für eine suboptimale Strategie abgeben können, sie können dies selektiv tun. Zum Beispiel, wenn neun Generäle wählen, von denen vier Unterstützung angreifen, während vier andere zugunsten des Rückzugs sind, kann der neunte General eine Stimme des Rückzugs zu diesen Generäle zu Gunsten des Rückzugs senden, und eine Stimme des Angriffs auf den Rest. Diejenigen, die einen Rückzug vom neunten General erhalten, werden sich zurückziehen, während der Rest angreifen wird (die möglicherweise nicht gut für die Angreifer gehen). Das Problem ist weiter kompliziert, indem die Generäle physisch getrennt sind und ihre Stimmen über Boten senden müssen, die keine Stimmen abgeben oder falsche Stimmen abgeben können. Auflösung Byzantinische Fehlertoleranz kann erreicht werden, wenn die loyalen (nicht-faulty) Generäle eine Mehrheitsvereinbarung über ihre Strategie haben. Es kann einen Standardwert geben, der auf fehlende Nachrichten angegeben wird. Beispielsweise können fehlende Nachrichten einen Nullwert erhalten werden. Wenn die Vereinbarung darüber besteht, dass die Null-Abstimmungen in der Mehrheit sind, kann eine vorab zugewiesene Standardstrategie verwendet werden (z.B. Retreat). Die typische Kartierung dieser Geschichte auf Computersysteme ist, dass die Computer die Generäle sind und ihre digitalen Kommunikationssystem-Links die Boten sind. Obwohl das Problem in der Analogie als Entscheidungs- und Sicherheitsproblem formuliert wird, kann es in der Elektronik nicht einfach durch kryptographische digitale Signaturen gelöst werden, da Fehler wie falsche Spannungen sich durch den Verschlüsselungsprozess ausbreiten können. So kann ein Bauteil einer Komponente funktionsfähig und fehlerbehaftet erscheinen, was ein Konsens darüber verhindert, ob die Komponente fehlerhaft ist oder nicht. BeispieleJedere Beispiele von byzantinischen Fehlern, die aufgetreten sind, sind in zwei gleichwertigen Zeitschriftenpapieren angegeben. Diese und weitere Beispiele sind auf den NASA DASHlink-Webseiten beschrieben. Diese Webseiten beschreiben auch einige Phänomene, die Byzantinische Fehler verursachen können. Byzantinische Fehler wurden selten und an unregelmäßigen Stellen während der Ausdauerprüfung für die neu gebauten Unterseeboote der Virginia-Klasse beobachtet, zumindest bis 2005 (wenn die Probleme öffentlich gemeldet wurden). Einige Lösungen wurden 1982 von Lamport, Shostak und Pease beschrieben. Sie begannen mit der Feststellung, dass das Problem der Generale reduziert werden kann, um ein "Commander and Lieutenants" Problem zu lösen, wo loyale Lieutenants alle gemeinsam handeln müssen und dass ihre Handlung dem entsprechen muss, was der Commander in dem Fall, dass der Commander loyal ist: Eine Lösung betrachtet Szenarien, in denen Nachrichten geschmiedet werden können, die aber Byzantinisch-fault-tolerant sein werden, solange die Zahl der disloyalen Generäle weniger als ein Drittel der Generäle beträgt. Die Unmöglichkeit, sich mit einem Drittel oder mehreren Verrätern zu befassen, verringert sich letztlich, um zu beweisen, dass der eine Commander und zwei Lieutenants Probleme nicht gelöst werden können, wenn der Commander verräterisch ist. Um dies zu sehen, vermuten wir, dass wir einen verräterischen Commander A und zwei Lieutenants, B und C haben: Wenn A B angreift und C zurückzieht, und B und C Nachrichten an einander senden, A's Nachricht weiterleiten, weder B noch C kann herausfinden, wer der Verräter ist, da es nicht notwendig ist A - ein anderer Lieutenant hätte die Nachricht aus A fälschen können. Es kann gezeigt werden, daß, wenn n die Zahl der Generale insgesamt ist und t die Zahl der Verräter darin ist n, dann nur dann Lösungen für das Problem gibt, wenn n > 3t und die Kommunikation synchron ist (gebundene Verzögerung). Eine zweite Lösung erfordert unvorhersehbare Nachrichtensignaturen. Für sicherheitskritische Systeme können digitale Signaturen (in modernen Computersystemen, dies kann in der Praxis mit der Public-key-Kryptographie erreicht werden) Byzantinische Fehlertoleranz in Gegenwart einer beliebigen Anzahl von verräterischen Generäle bieten. Bei sicherheitskritischen Systemen (wo die Sicherheit intelligente Bedrohungen anspricht, während die Sicherheit die inhärenten Gefahren einer Aktivität oder Mission anspricht) bieten einfache Fehlererkennungscodes, wie z.B. CRCs, schwächere, aber oft ausreichende Deckung zu viel geringeren Kosten. Dies gilt sowohl für byzantinische als auch für nicht-byzantinische Fehler. Außerdem schwächen manchmal Sicherheitsmaßnahmen die Sicherheit und umgekehrt. Somit sind kryptographische digitale Signaturverfahren keine gute Wahl für sicherheitskritische Systeme, es sei denn, es gibt auch eine bestimmte Sicherheitsbedrohung. Während Fehlererkennungscodes, wie CRC, besser sind als kryptographische Techniken, bieten keine ausreichende Abdeckung für aktive Elektronik in sicherheitskritischen Systemen. Dies wird durch das Schrödinger CRC-Szenario illustriert, in dem eine CRC-geschützte Nachricht mit einem einzigen byzantinischen fehlerhaften Bit unterschiedliche Daten für verschiedene Beobachter darstellt und jeder Beobachter ein gültiges CRC sieht. Auch präsentiert wird eine Variation der ersten beiden Lösungen, die Byzantinisch-fault-tolerantes Verhalten in einigen Situationen ermöglichen, in denen nicht alle Generäle direkt miteinander kommunizieren können. Mehrere Systemarchitekturen wurden entworfen, um 1980, die Byzantinische Fehlertoleranz umgesetzt. Dazu gehören: Drapers FTMP, Honeywells MMFCS und SRIs SIFT. Fortgeschrittene Lösungen Im Jahr 1999 haben Miguel Castro und Barbara Liskov den "Practical Byzantine Fault Tolerance" (PBFT)-Algorithmus vorgestellt, der eine leistungsstarke byzantinische State-Maschinenreplikation bietet, tausende Anfragen pro Sekunde mit Submillisekunden-Anhebungen in der Latenz. Nach PBFT wurden mehrere BFT-Protokolle eingeführt, um seine Robustheit und Leistung zu verbessern. Zum Beispiel befassten sich Q/U, HQ, Zyzzyva und ABsTRACTs mit den Leistungs- und Kostenproblemen, während andere Protokolle, wie Aardvark und RBFT, ihre Robustheitsprobleme behandelten. Darüber hinaus versuchte Adapt, bestehende BFT-Protokolle durch anpassungsfähiges Schalten zwischen ihnen zu nutzen, um die Systemstabilität und -leistung bei Änderung der zugrunde liegenden Bedingungen zu verbessern. Darüber hinaus wurden BFT-Protokolle eingeführt, die vertrauenswürdige Komponenten nutzen, um die Anzahl der Repliken zu reduzieren, z.B. A2M-PBFT-EA und MinBFT. Motiviert von PBFT wurde Tendermint BFT für teilweise asynchrone Netzwerke eingeführt und wird hauptsächlich für Proof of Stake Blockchains verwendet. BFT-Implementierungen Ein Beispiel für BFT ist Bitcoin, ein Peer-to-Peer-Digital-Cash-System. Das Bitcoin-Netzwerk arbeitet parallel, um eine Blockchain zu erzeugen, mit der das System Byzantinische Fehler überwinden und eine kohärente globale Sicht auf den Zustand des Systems erreichen kann. Einige Flugzeugsysteme, wie das Boeing 777 Aircraft Information Management System (über sein ARINC 659 SAFEbus-Netzwerk), das Flugkontrollsystem Boeing 777 und die Flugkontrollsysteme Boeing 787 verwenden byzantinische Fehlertoleranz; da es sich um Echtzeitsysteme handelt, müssen ihre byzantinischen Fehlertoleranzlösungen sehr niedrige Latenzzeiten aufweisen. Beispielsweise kann SAFEbus Byzantinische Fehlertoleranz in der Größenordnung einer Mikrosekunde hinzugefügter Latenz erreichen. Einige Raumfahrzeugflugsysteme wie die des SpaceX Dragon betrachten Byzantinische Fehlertoleranz in ihrem Design. Byzantinische Fehlertoleranzmechanismen verwenden Komponenten, die eine eingehende Nachricht (oder nur ihre Signatur) an andere Empfänger dieser eingehenden Nachricht wiederholen. Alle diese Mechanismen machen die Annahme, dass der Akt der Wiederholung einer Nachricht die Ausbreitung von byzantinischen Symptomen blockiert. Bei Systemen, die eine hohe Sicherheits- oder Sicherheitskritik aufweisen, müssen diese Annahmen als wahr für eine akzeptable Fehlerbedeckung angesehen werden. Bei der Bereitstellung von Beweisen durch Tests, eine Schwierigkeit ist die Schaffung einer ausreichend breiten Palette von Signalen mit byzantinischen Symptomen. Solche Tests erfordern wahrscheinlich spezialisierte Fehlerinjektoren. Software UpRight ist eine Open Source-Bibliothek für den Aufbau von Diensten, die sowohl Abstürzen (auf) als auch Byzantinische Verhaltensweisen (rechts) tolerieren, die viele dieser Protokolle Innovationen einschließt. Die BFT-SMaRt-Bibliothek ist eine leistungsstarke byzantinische Fehlertolerante State Machine Replikationsbibliothek, die in Java entwickelt wurde. Diese Bibliothek implementiert ein Protokoll, das PBFTs sehr ähnlich ist, plus komplementäre Protokolle, die einen Zustandstransfer und eine On-the-Fly-Rekonfiguration von Hosts bieten. BFT-SMaRt ist der jüngste Aufwand zur Umsetzung der staatlichen Maschinenreplikation, der immer noch aktiv gepflegt wird. Archistar nutzt eine schlanke BFT-Schicht für die Kommunikation. Es Prototypen eines sicheren Multi-Cloud-Speichersystems mit Java lizenziert unter LGPLv2. Der Fokus liegt auf Einfachheit und Lesbarkeit, er will die Grundlage für weitere Forschungsprojekte sein. Askemos ist eine gleichzeitige, Müllsammel-, persistente Programmierplattform an der Spitze von replizierten Zustandsmaschinen, die Byzantinische Fehler tolerieren. Es Prototypen einer Ausführungsumgebung, die intelligente Verträge erleichtert. Siehe auch Referenzen Externe Links Byzantinische Fehlertoleranz im RKBExplorer Dieser Artikel gibt einen Überblick über den Liberalismus in Lettland. Sie beschränkt sich auf liberale Parteien mit beträchtlicher Unterstützung, vor allem durch eine Vertretung in der Saeima. Das Zeichen ⇒ bezeichnet eine andere Partei in diesem Schema. Für die Aufnahme in diese Regelung ist es nicht notwendig, dass sich Parteien als liberale Partei bezeichneten. Hintergrund Lettland war einer der ersten Länder des Ersten Weltkriegs, die einige Ideen aus der Weimarer Verfassung 1919 annahmen. Der deutsche liberale Anwalt Hugo Preuß (Preuss) wird oft als Autor des Entwurfs der Verfassung, der von der Weimarer Nationalversammlung verabschiedet wurde, dem Historiker William L. Shirer in einem Buch The Rise and Fall of the Third Reich als "das liberalste und demokratische Dokument seiner Art, das das zwanzigste Jahrhundert je gesehen hatte ... voller genialer und bewundernswerter Geräte, die das Werk eines fast fehlerfreien In Lettland sind einige frühe Rechtsexperten wie Kārlis Dišlers, Fēlikss Cielēns und moderne Tagesrichter einig, dass die Weimarer Verfassung dem Wortlaut der Verfassung Lettlands (Satversme) zugrunde lag und in gewisser Weise eine Synthese zwischen der Weimarer Verfassung und dem Westminster-System im Vereinigten Königreich darstellt. Geschichte Liberalismus in Lettland war eine kleine, aber wichtige Kraft seit 1922 in Lettland. Die aktuelle Wiedereingliederung nach der Wiedereingliederung von 1990. Heute ist der lettische Weg (Latvijas Ceļš, Mitglied LI, ELDR) ein Recht der liberalen Partei des Zentrumsmarktes. Gegenwärtig ist die Partei mit der ersten Partei Lettlands zu LPP/LC zusammengeschlossen. Moderate deutsche Liberale in Lettland bildete die deutsch-palästinensische Demokratische Partei (Deutsch-Baltische Demokratische Partei/Vācbaltu demokrātiskā partija) 1934: Die Partei wird, zusammen mit allen anderen politischen Parteien, nach einem Putsch von Kārlis Ulmanis Deutsche baltische Progressive Party 1918 verboten: Radikale deutsche Liberale in Lettland bildeten die deutsch-paltische Progressive Partei (Deutsch-Baltische Fortschrittliche Partei/Vācbaltu progresīvā partija) 1934: Die Partei ist von der Demokratischen Partei zum demokratischen Zentrum 1922 verboten: Kurz nach seiner Gründung fusionierte die Demokratische Partei (Demokrātiskā partija) mit der radikalen Demokratischen Partei (Radikālā Demokrātiskā partija) und der Volkspartei (gerichtetaužu partija) in das Demokratische Zentrum (Demokrātiskais centrs). Die Partei wird von den späteren Präsidenten Lettlands, Jānis Čakste und Gustavs Zemgals geleitet. 1934: Die Party ist verboten. Im Exil wird es von der Liberalen Partei (Liberāļu partija) Latgalian Democratic Party 1920 fortgesetzt:Latgalische Liberale bildeten die Latgalische Demokratische Partei (Latgales demokrātu partija) 1926:Die Partei fusionierte in die Latgalische Demokratische Farmers Union (Latgales demokrātisko zemnieku savienība) Mizrochi 1922: Liberale jüdische Zionisten bildeten die Mizrachi 1934: Die Partei ist von der Partei des Demokratischen Zentrums zu der Demokratischen Partei Lettlands 1992 verboten: Eine Partei des Demokratischen Zentrums (Demokrātiskā centra partija) wird als Neugründung des ⇒ Democratic Centre 1994 gegründet: Die Partei fusionierte mit einer anderen Gruppe in die Demokratische Partei Saimnieks (Demokrātiskā partija Saimnieks) 1997: Viele Mitglieder sind der Arbeiterpartei und der lettischen Nationalen Reformpartei 1999 beigetreten: Die Partei wird Lettisch Demokratische Partei umbenannt (Latvijas demokrātiskā partija) Lettlands Weg 1993: Die Liberalen aus der Volksfront Lettlands gründeten den lettischen Weg (Latvijas Ceļš) 2006: Lettlands Weg schmiedete eine Allianz mit der ersten Partei Lettlands, die das LPP/LC bildete. 2010: LPP/LC trat mit der Volkspartei in die Hände, um die Allianz For a Good Latvia (Par Labu Latviju) zu bilden. 2011: Die Partei der Menschen ist entbunden, so ist die PLL-Allianz. Für Lettlands Entwicklung 2013: Politische Partei Für Lettlands Entwicklung, gegründet von Einārs Repše 2014: Juris Pūce wurde zum neuen Vorsitzenden gewählt. Die Partei wurde Mitglied der ALDE (Allianz der Liberalen und Demokraten für Europa) 2017:Die im Stadtrat von Riga gewählte Partei in einer Wahlbündnis mit der lettischen Vereinigung der Regionen 2018: Die Wahlbündnis Entwicklung/For! wurde von der Entwicklung Lettlands, BewegungFor! und Izaugsme Liberale Führer Demokrātiskais Centrs: Jānis Čakste Lettische Entwicklung gebildet: Rechtsanwälte Siehe auch Geschichte der lettischen Politik Lettlands Liste der politischen Parteien in Lettland == Referenzen ==