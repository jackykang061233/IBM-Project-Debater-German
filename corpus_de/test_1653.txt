Das Network Time Protocol (NTP) ist ein Netzwerkprotokoll zur Taktsynchronisation zwischen Computersystemen über paketvermittelte, variable Latency-Datennetze. Seit 1985 ist NTP eines der ältesten Internet-Protokolle im aktuellen Einsatz. NTP wurde von David L. Mills der Universität Delaware entworfen. NTP soll alle teilnehmenden Computer innerhalb von wenigen Millisekunden von Coordinated Universal Time (UTC) synchronisieren. Es verwendet den Kreuzungsalgorithmus, eine modifizierte Version von Marzullos Algorithmus, um genaue Zeitserver auszuwählen und ist entworfen, um die Auswirkungen der variablen Netzwerklatenz zu mildern. NTP kann in der Regel Zeit bis innerhalb von zehn Millisekunden über das öffentliche Internet, und kann besser als eine Millisekundengenauigkeit in lokalen Netzwerken unter idealen Bedingungen erreichen. Asymmetrische Strecken und Netzüberlastung können Fehler von 100 ms oder mehr verursachen. Das Protokoll wird in der Regel in Bezug auf ein Client-Server-Modell beschrieben, kann aber ebenso einfach in Peer-to-Peer-Beziehungen verwendet werden, in denen beide Peers den anderen als eine potenzielle Zeitquelle betrachten. Implementierungen senden und empfangen Zeitstempel mit dem User Datagram Protocol (UDP) auf Portnummer 123. Sie können auch Broadcasting oder Multicasting verwenden, wo Clients nach einem anfänglichen Rundtrip-Kalibrierungsaustausch passiv Zeitaktualisierungen hören. NTP liefert eine Warnung vor jeder bevorstehenden Sprung zweiten Anpassung, aber keine Informationen über lokale Zeitzonen oder Tageslichtsparzeit übertragen. Das aktuelle Protokoll ist die Version 4 (NTPv4), die eine vorgeschlagene Norm ist, wie in RFC 5905 dokumentiert. Es ist rückwärtskompatibel mit der in RFC 1305 angegebenen Version 3. Network Time Security (NTS), eine sichere Version von NTP mit TLS und AEAD ist derzeit ein vorgeschlagener Standard und dokumentiert in RFC 8915. Geschichte 1979 wurde die Netzzeitsynchronisationstechnik in der eventuell ersten öffentlichen Demonstration von Internetdiensten, die über ein transatlantisches Satellitennetz liefen, auf der National Computer Conference in New York eingesetzt. Die Technologie wurde später in der Internet Engineering Note (IEN) 173 beschrieben und daraus ein öffentliches Protokoll entwickelt, das in RFC 778 dokumentiert wurde. Die Technologie wurde zunächst im Rahmen des Hello Routing-Protokolls in einem lokalen Netzwerk eingesetzt und im Fuzzball-Router implementiert, einem experimentellen Betriebssystem, das in der Netzwerkprototypisierung eingesetzt wurde, wo sie seit vielen Jahren lief. Andere verwandte Netzwerktools waren sowohl damals als auch heute verfügbar. Dazu gehören die Daytime- und Time-Protokolle zur Erfassung der Zeit der Ereignisse sowie die ICMP Timestamp-Nachrichten und die IP Timestamp-Option (RFC 781). Weitere vollständige Synchronisationssysteme, obwohl die Datenanalyse von NTP und die Takttrennalgorithmen fehlt, umfassen die Unix daemon timed, die einen Wahlalgorithmus verwendet, um einen Server für alle Clients zu ernennen; und die Digital Time Synchronization Service (DTSS), die eine Hierarchie von Servern ähnlich dem NTP Stratum Modell verwendet. Im Jahr 1985 wurde die NTP-Version 0 (NTPv0) sowohl in Fuzzball als auch in Unix implementiert, und in RFC 958 wurden die NTP-Paket-Header- und Rundtrip-Verzögerungs- und Offset-Berechnungen, die in NTPv4 bestanden, dokumentiert. Trotz der relativ langsamen Computer und Netzwerke, die zur Zeit zur Verfügung stehen, wurde in der Regel eine Genauigkeit von besser als 100 Millisekunden auf Atlantic-Spannungsverbindungen mit einer Genauigkeit von zehn Millisekunden auf Ethernet-Netzwerken erreicht. 1988 wurde in RFC 1059 eine wesentlich vollständigere Spezifikation des NTPv1-Protokolls mit zugehörigen Algorithmen veröffentlicht. Es zog auf die experimentellen Ergebnisse und den in RFC 956 dokumentierten Taktfilter-Algorithmus und war die erste Version, um die Client-Server und Peer-to-Peer-Modi zu beschreiben. 1991 wurden die NTPv1-Architekturen, Protokolle und Algorithmen mit der Veröffentlichung eines Artikels von David L. Mills in den IEEE Transactions on Communications auf eine breitere Ingenieurgemeinde aufmerksam gemacht. 1989 wurde die RFC 1119 veröffentlicht, die NTPv2 mittels einer Zustandsmaschine definiert, mit Pseudocode, um ihre Operation zu beschreiben. Es führte ein Management-Protokoll und kryptographische Authentifizierungsschema, die beide in NTPv4 überlebt haben, zusammen mit dem Großteil des Algorithmus. Allerdings wurde das Design von NTPv2 wegen mangelnder formaler Korrektheit durch die DTSS-Gemeinschaft kritisiert, und das Taktauswahlverfahren wurde geändert, um Marzullos Algorithmus für NTPv3 auf den Weg zu bringen. 1992 definierte RFC 1305 NTPv3. Die RFC beinhaltete eine Analyse aller Fehlerquellen, vom Referenztakt bis zum Endkunden, die die Berechnung einer Metrik ermöglichte, die die Wahl des besten Servers hilft, wo mehrere Kandidaten zu widersprechen scheinen. Broadcast-Modus wurde eingeführt. In den folgenden Jahren, da neue Features hinzugefügt wurden und Algorithmus Verbesserungen gemacht wurden, wurde deutlich, dass eine neue Protokollversion erforderlich war. Im Jahr 2010 wurde RFC 5905 mit einer vorgeschlagenen Spezifikation für NTPv4 veröffentlicht. Das Protokoll ist seitdem deutlich vorangegangen, und ab 2014 muss noch eine aktualisierte RFC veröffentlicht werden. Nach der Pensionierung von Mills von der University of Delaware wird die Referenz-Implementierung derzeit als Open Source-Projekt unter der Leitung von Harlan Stenn beibehalten. Clock strata NTP verwendet ein hierarchisches, halbschichtiges System von Zeitquellen. Jede Ebene dieser Hierarchie wird als Stratum bezeichnet und ist für den Referenztakt oben eine mit Null beginnende Zahl zugeordnet. Ein auf einen Stratum n-Server synchronisierter Server läuft in der Stratum n + 1.Die Zahl stellt den Abstand zum Referenztakt dar und wird verwendet, um zyklische Abhängigkeiten in der Hierarchie zu verhindern. Stratum ist nicht immer ein Hinweis auf Qualität oder Zuverlässigkeit; es ist üblich, Stratum 3 Zeitquellen zu finden, die höher sind als andere Schicht 2 Zeitquellen. Im folgenden ist eine kurze Beschreibung der Schichten 0, 1, 2 und 3 vorgesehen. Stratum 0Diese sind hochpräzise Zeiterfassungsgeräte wie Atomuhren, GPS oder andere Funkuhren. Sie erzeugen einen sehr genauen Impuls pro Sekunde, der einen Interrupt und Zeitstempel auf einem angeschlossenen Computer auslöst. Stratum 0 Geräte sind auch als Referenztakte bekannt. NTP-Server können sich nicht als Stratum 0 bewerben.Ein Stratum-Feld, das auf 0 in NTP-Paket gesetzt ist, zeigt eine nicht spezifizierte Schicht an. Stratum 1 Dies sind Computer, deren Systemzeit innerhalb einiger Mikrosekunden ihrer angeschlossenen Stratum 0 Geräte synchronisiert wird. Stratum 1 Server können mit anderen Stratum 1 Servern für Sanity-Check und Backup. Sie werden auch als primäre Zeitserver bezeichnet. Stratum 2. Dies sind Computer, die über ein Netzwerk auf Stratum 1 Server synchronisiert werden. Oft sucht ein Stratum 2 Computer mehrere Stratum 1 Server. Stratum 2 Computer können auch mit anderen Stratum 2 Computern speisen, um stabilere und robuste Zeit für alle Geräte in der Peer-Gruppe zu bieten. Stratum 3 Dies sind Computer, die auf Stratum 2 Server synchronisiert sind. Sie verwenden die gleichen Algorithmen für Peering und Datensampling als Stratum 2 und können selbst als Server für Stratum 4 Computer und so weiter fungieren. Die obere Grenze für die Schicht beträgt 15; die Schicht 16 wird verwendet, um anzuzeigen, dass ein Gerät unsynchronisiert ist. Die NTP-Algorithmen auf jedem Computer interagieren, um einen Bellman-Ford-Kurzpfad-Spannungsbaum zu konstruieren, um die akkumulierte Hin- und Rückfahrtsverzögerung für alle Clients zu minimieren. Zusätzlich zu Stratum kann das Protokoll die Synchronisationsquelle für jeden Server anhand einer Referenzkennung (refid) identifizieren. TimestampsDie von NTP verwendeten 64-Bit-Zeitstempel bestehen aus einem 32-Bit-Teil für Sekunden und einem 32-Bit-Teil für fraktionierte Sekunde, so dass eine Zeitskala, die über alle 232 Sekunden (136 Jahre) und eine theoretische Auflösung von 2 -32 (23 Sekunden3 Picosekunden) rollt. NTP verwendet eine Epoche vom 1. Januar 1900. Der erste Überrollvorgang erfolgt daher am 7. Februar 2036. NTPv4 führt ein 128-Bit-Datumsformat ein: 64 Bit für die zweiten und 64 Bit für die Bruchsekunde. Die bedeutendsten 32-Bits dieses Formats sind die Era Number, die in den meisten Fällen Überlegenheit löst. Laut Mills, "Der 64-Bit-Wert für die Fraktion reicht aus, um die Zeit zu lösen, die ein Photon benötigt, um ein Elektron mit der Lichtgeschwindigkeit zu passieren. Der 64-Bit-Sekundärwert reicht aus, um eine eindeutige Zeitdarstellung bis zum Ende des Universums zu liefern." Taktsynchronisationsalgorithmus Ein typischer NTP-Client sucht regelmäßig einen oder mehrere NTP-Server. Der Client muss seine Zeitversatz- und Rundwegverzögerung berechnen. Zeitversatz θ, die Differenz der absoluten Zeit zwischen den beiden Takten, ist definiert durch θ = s ( t 1 - t 0) + ( t 2 - t 3 ) 2 | \{displaystyle \theta =link\vert \{frac t_{1}-t_{0})+(t_{2}-t_{3}}{2}}\right\vert } und die Rundwegverzögerung δ um δ = ( t 3 - t 0) − ( t 2 - t 1 ) \{displaystyle \delta =t_{3}-t_{0})-(t_{2}-t_{1 ,wo t0 der Zeitstempel des Clients der Anfragepaketübertragung ist, t1 der Zeitstempel des Servers der Anfragepaketaufnahme, t2 der Zeitstempel der Antwortpaketübertragung und t3 der Zeitstempel des Clients des Antwortpaketempfangs. Um den Ausdruck für den Offset abzuleiten, beachten Sie, dass für das Anfragepaket t 0 + θ + δ / 2 = t 1 \{displaystyle t_{0}+\theta +\delta /2=t_{1} und für das Antwortpaket t 3 + θ - δ / 2 = t 2 \{displaystyle t_{3}+\theta \-delta /2=t_{2} Das Lösen für θ liefert die Definition des Zeitversatzes. Die Werte für θ und δ werden durch Filter geleitet und einer statistischen Analyse unterzogen. Ausreißer werden verworfen und eine Schätzung des Zeitversatzes wird von den besten drei verbleibenden Kandidaten abgeleitet. Die Taktfrequenz wird dann eingestellt, um den Offset allmählich zu reduzieren, wodurch eine Rückkopplungsschleife entsteht. Eine genaue Synchronisation wird erreicht, wenn sowohl die eingehenden als auch ausgehenden Routen zwischen dem Client und dem Server symmetrische Sollverzögerung aufweisen. Wenn die Routen keine gemeinsame Nennverzögerung aufweisen, besteht eine systematische Vorspannung aus der Hälfte der Differenz zwischen Vorwärts- und Rückwärtsfahrtzeiten. Software-Implementierungen Durchführung Die NTP-Referenz-Implementierung, zusammen mit dem Protokoll, wurde seit über 20 Jahren kontinuierlich entwickelt. Rückwärtskompatibilität wurde beibehalten, da neue Features hinzugefügt wurden. Es enthält mehrere empfindliche Algorithmen, insbesondere um die Uhr zu disziplinieren, die sich beim Synchronisieren mit Servern, die verschiedene Algorithmen verwenden, verhalten können. Die Software wurde auf fast jede Rechenplattform, einschließlich PCs, portiert. Es läuft als Daemon ntpd unter Unix oder als Dienst unter Windows. Referenztakte werden unterstützt und deren Offsets werden in gleicher Weise wie Remoteserver gefiltert und analysiert, obwohl sie in der Regel häufiger abgefragt werden. Diese Umsetzung wurde im Jahr 2017 geprüft und fand zahlreiche potenzielle Sicherheitsprobleme. SNTPSimple Network Time Protocol (SNTP) ist eine weniger komplexe Implementierung von NTP, mit dem gleichen Protokoll, aber ohne die Speicherung von Zustand über längere Zeiträume zu erfordern. Es wird in einigen eingebetteten Systemen und in Anwendungen verwendet, in denen die volle NTP-Fähigkeit nicht erforderlich ist. Windows Time Alle Microsoft Windows-Versionen seit Windows 2000 beinhalten den Windows Time Service (W32Time), der die Möglichkeit hat, den Computertakt auf einen NTP-Server zu synchronisieren. W32Time wurde ursprünglich für das Kerberos Version 5 Authentifizierungsprotokoll implementiert, welches Zeit innerhalb von 5 Minuten des richtigen Wertes benötigt, um Wiederholungsangriffe zu verhindern. Die Version in Windows 2000 und Windows XP implementiert nur SNTP und verletzt mehrere Aspekte der NTP-Version 3 Standard. Ab Windows Server 2003 und Windows Vista wurde W32Time mit einer signifikanten Teilmenge von NTPv3 kompatibel. Microsoft sagt, dass W32Time die Zeitsynchronisation mit einer zweiten Genauigkeit nicht zuverlässig halten kann. Wenn eine höhere Genauigkeit gewünscht wird, empfiehlt Microsoft die Verwendung einer neueren Version von Windows oder einer anderen NTP-Implementierung. Ab Windows 10 Version 1607 und Windows Server 2016 kann W32Time konfiguriert werden, um die Zeitgenauigkeit von 1 s, 50 ms oder 1 ms unter bestimmten festgelegten Betriebsbedingungen zu erreichen. OpenNTPDIm Jahr 2004 präsentierte Henning Brauer OpenNTPD, eine NTP-Implementierung mit einem Fokus auf Sicherheit und umfasst ein privilegiertes Design. Während es genauer auf die einfacheren generischen Bedürfnisse von OpenBSD-Nutzern ausgerichtet ist, umfasst es auch einige Protokoll-Sicherheitsverbesserungen, während es noch mit bestehenden NTP-Servern kompatibel ist. Eine tragbare Version ist in Linux-Paket-Repositories verfügbar. Ntimed Ein neuer NTP-Client, ntimed, wurde 2014 von Poul-Henning Kamp gestartet und 2015 verlassen. Die neue Implementierung wurde von der Linux Foundation als Ersatz für die Referenz-Implementierung gesponsert, da es beschlossen wurde, eine neue Implementierung von Grund auf zu schreiben, als die Größe der Referenz-Implementierung zu reduzieren. Obwohl es nicht offiziell freigegeben wurde, kann ntimed Uhren zuverlässig synchronisieren. NTPsec NTPsec ist eine Gabel der Referenz-Implementierung, die systematisch sicherheitsgehärtet wurde. Der Gabelpunkt war im Juni 2015 und reagierte 2014 auf einen Kompromissausbruch. Die erste Produktionsaussendung im Oktober 2017. Zwischen der Entfernung von unsicheren Funktionen, der Entfernung der Unterstützung für veraltete Hardware und der Entfernung der Unterstützung für veraltete Unix-Varianten, NTPsec hat in der Lage, 75 % der ursprünglichen Codebase wegzubekommen, wodurch der Rest mehr auditierbar. Eine Prüfung des Codes 2017 ergab acht Sicherheitsfragen, darunter zwei, die nicht in der ursprünglichen Referenz-Implementierung vorhanden waren, aber NTPsec erlitt nicht acht weitere Fragen, die in der Referenz-Implementierung verblieben waren. chrony chrony kommt standardmäßig in Red Hat Distributionen und ist in den Ubuntu Repositories. chrony richtet sich an gewöhnliche Computer, die instabil sind, in den Schlafmodus gehen oder intermittierende Verbindung zum Internet haben. chrony ist auch für virtuelle Maschinen konzipiert, eine viel instabilere Umgebung. Es zeichnet sich durch geringen Ressourcenverbrauch (Kosten) aus und unterstützt Precision Time Protocol Hardware für mehr Zeitstempelgenauigkeit. Es hat zwei Hauptkomponenten: chronyd, ein Daemon, das ausgeführt wird, wenn der Computer beginnt, und chronyc, eine Befehlszeilenschnittstelle zum Benutzer für seine Konfiguration. Es wurde als sehr sicher bewertet und mit nur wenigen Zwischenfällen, ist sein Vorteil die Vielseitigkeit seines Codes, von Grund auf geschrieben, um unnötige Komplexität zu vermeiden. Unterstützung für Network Time Security (NTS) wurde auf Version 4.0.chrony ist unter GNU General Public License Version 2 verfügbar, wurde 1997 von Richard Curnow erstellt und wird derzeit von Miroslav Lichvar gepflegt. Sekunden Am Tag eines zweiten Sprungereignisses erhält ntpd Benachrichtigung von einer Konfigurationsdatei, einem beigefügten Referenztakt oder einem Remoteserver. Obwohl die NTP-Uhr während des Ereignisses tatsächlich gestoppt wird, aufgrund der Anforderung, dass die Zeit unbedingt zu erhöhen scheinen muss, alle Prozesse, die die Systemzeit abfragen, verursachen es um einen winzigen Betrag zu erhöhen, die Reihenfolge der Ereignisse zu bewahren. Sollte eine negative Sprungsekunde jemals notwendig werden, würde sie mit der Sequenz 23:59:58, 00:00:00, überspringen 23:59:59 gelöscht werden. Eine alternative Implementierung, genannt Leap smearing, besteht darin, den zweiten Leap schrittweise während eines Zeitraums von 24 Stunden, von Mittag bis Mittag in UTC-Zeit einzuführen. Diese Implementierung wird von Google (beide intern und auf ihren öffentlichen NTP-Servern) und von Amazon AWS verwendet. Sicherheit Bei der Referenzimplementierung der NTP-Codebasis wurden nur einige andere Sicherheitsprobleme identifiziert, aber diejenigen, die 2009 erschienen waren, waren Anlass für eine erhebliche Besorgnis. Das Protokoll wurde über seine gesamte Geschichte überarbeitet und überprüft. Die Codebasis für die Referenzumsetzung hat seit mehreren Jahren Sicherheitsaudits aus mehreren Quellen durchgeführt. 2014 wurde ein Stack-Puffer-Überlauf-Exploit entdeckt und gepatelt. Apple war genug besorgt über diese Schwachstelle, dass es seine Auto-Update-Fähigkeit zum ersten Mal verwendet. Einige Implementierungsfehler sind grundsätzlich, wie eine fehlende Rückmeldung in einer Routine, die zu einem unbegrenzten Zugriff auf Systeme führen kann, die einige Versionen von NTP im Root Daemon laufen. Systeme, die den Wurzeldämon nicht verwenden, wie BSD, unterliegen diesem Fehler nicht. Ein Sicherheitsaudit von drei NTP-Implementierungen 2017, die im Auftrag der Kerninfrastrukturinitiative der Linux Foundation durchgeführt wurden, schlug vor, dass sowohl NTP als auch NTPsec problematischer waren als Chrony aus Sicherheitsgründen. NTP-Server können anfällig für Man-in-the-Middle-Angriffe sein, es sei denn, Pakete werden kryptographisch zur Authentifizierung unterschrieben. Der rechnerische Overhead kann diese unpraktisch auf geschäftigen Servern machen, insbesondere während der Denial von Service-Angriffen. NTP-Nachricht spoofing von einem Man-in-the-Middle-Angriff kann verwendet werden, um Uhren auf Client-Computern zu bewegen und eine Reihe von Angriffen basierend auf Bypassing von kryptografischen Schlüsselausbrüchen zu ermöglichen. Einige der von gefälschten NTP-Nachrichten betroffenen Dienste sind TLS, DNSSEC, verschiedene Cache-Programme (wie DNS-Cache), BGP, Bitcoin und eine Reihe von persistenten Login-Programmen. NTP wurde in verteilter Denial von Service-Angriffen verwendet. Eine kleine Abfrage wird an einen NTP-Server gesendet, wobei die Rückgabeadresse spoofed die Zieladresse ist. Ähnlich wie beim DNS-Amplifikations-Angriff reagiert der Server mit einer viel größeren Antwort, die es einem Angreifer ermöglicht, die Menge der Daten, die an das Ziel gesendet werden, wesentlich zu erhöhen. Um die Teilnahme an einem Angriff zu vermeiden, kann NTP-Server-Software aktualisiert werden oder Server können konfiguriert werden, um externe Abfragen zu ignorieren. Zur Verbesserung der NTP-Sicherheit wurde eine sichere Version namens Network Time Security (NTS) entwickelt und aktuell von mehreren Zeitservern unterstützt. Siehe auch Allan variance Clock-Netzwerk International Atomic Time IRIG Zeitcode NITZ NTP-Pool Ntpdate Notes Referenzen Weiter lesen Definitionen von verwalteten Objekten für Network Time Protocol Version 4 (NTPv4).doi:10.17487/RFC5907.RFC 5907.Network Time Protocol (NTP) Server-Option für DHCPv6.doi:10.17487/RFC5908.RFC 5908. Externe Links Offizielle Website Official Stratum One Time Servers list IETF NTP Arbeitsgruppe Microsft Windows genaue Zeitführung und mehr Zeit und NTP Papier NTP Umfrage 2005Current NIST Sprung Sekunden Datei kompatibel mit ntpd David L. Mills, Eine kurze Geschichte von NTP Zeit: Confessions of an Internet Timekeeper (PDF), abgerufen 2021-02-07