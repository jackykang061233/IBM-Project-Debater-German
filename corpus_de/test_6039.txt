Julia ist eine leistungsstarke, dynamische Programmiersprache. Während es eine allgemeine Sprache ist und verwendet werden kann, um jede Anwendung zu schreiben, sind viele seiner Eigenschaften gut geeignet für numerische Analyse und Rechenwissenschaft. Distinktive Aspekte des Designs von Julia umfassen ein Typsystem mit parametrischem Polymorphismus in einer dynamischen Programmiersprache; mit mehrfachem Versand als Kernprogrammierungsparadigma. Julia unterstützt gleichzeitiges, (mögliches) paralleles und verteiltes Computing (mit oder ohne Verwendung von MPI oder dem eingebauten entsprechend OpenMP-Style Threads) und direktes Ansprechen von C- und Fortran-Bibliotheken ohne Leimcode. Julia verwendet einen Just-in-time (JIT)-Compiler, der in der Julia-Gemeinschaft als Just-in-time (JAOT) bezeichnet wird, da Julia den gesamten Code (standardmäßig) auf den Maschinencode kompiliert, bevor es läuft. Julia ist Müllsammeln, verwendet eager Auswertung und umfasst effiziente Bibliotheken für Floating-Point-Berechnungen, lineare Algebra, Zufallszahlenerzeugung und regelmäßige Expressionsanpassung. Viele Bibliotheken sind verfügbar, darunter einige (z.B. für schnelle Fourier-Transformationen), die zuvor mit Julia gebündelt wurden und jetzt getrennt sind. Mehrere Entwicklungstools unterstützen die Codierung in Julia, wie integrierte Entwicklungsumgebungen (z.B. Microsofts Visual Studio Code, mit Erweiterungen, die Julia-Unterstützung zu IDEs hinzufügen, z.B. Debugging und Linting-Unterstützung); mit integrierten Werkzeugen, z.B. einem Profiler (und Flammengraph-Unterstützung für den eingebauten Eins zur Verfügung stehen), Debugging und dem Rebugger.jl-Paket "unterstützt wiederholt-Execution mehr. History Work on Julia wurde 2009 von Jeff Bezanson, Stefan Karpinski, Viral B. Shah und Alan Edelman gestartet, die eine freie Sprache schaffen, die sowohl hoch als auch schnell war. Am 14. Februar 2012 startete das Team eine Website mit einem Blog-Post, der die Mission der Sprache erklärt. In einem Interview mit InfoWorld im April 2012 sagte Karpinski vom Namen Julia: "Es gibt keinen guten Grund, wirklich. Es schien wie ein hübscher Name. "Bezanson sagte, er wählte den Namen auf der Empfehlung eines Freundes, dann Jahre später schrieb: Vielleicht steht Julia für “Jeffs ungewöhnliche Lisp ist automatisiert”? Seit dem Start 2012 ist die Julia Community gewachsen, und "Julia wurde von Nutzern von mehr als 10.000 Unternehmen heruntergeladen", mit mehr als 29 Millionen Downloads ab Juli 2021, um 87% in einem Jahr (andere Julia verwandte Statistiken bis zu 113,%) und wird an mehr als 1.500 Universitäten verwendet, Die JuliaCon akademische Konferenz für Julia Nutzer und Entwickler wurde jährlich seit 2014 mit der letzten Jahr 2020 JuliaCon begrüßt über 28.900 Version 0.3 wurde im August 2014 veröffentlicht, Version 0.4 im Oktober 2015, Version 0.5 im Oktober 2016 und Version 0.6 im Juni 2017. Sowohl Julia 0.7 (eine nützliche Veröffentlichung für Testpakete, als auch für das Wissen, wie man sie für 1.0 aufrüstet) und Version 1.0 wurden am 8. August 2018 veröffentlicht. Arbeit an Julia 0,7 war ein "Räumunternehmen" (z.B. wegen "sehr neuer Optimierer") und einige Änderungen an der Semantik vorgenommen wurden, z.B. die Iterationsschnittstelle wurde vereinfacht; und die Syntax änderte sich etwas (mit der Syntax nun stabil, und das gleiche für 1.x und 0.7). Der Release-Kandidat für Julia 1.0 (Julia 1.0.0-rc1) wurde am 7. August 2018 veröffentlicht, und die Endversion am Tag später (und bis jetzt sind Julia 1.0.x die ältesten Versionen, die noch unterstützt werden, mit langfristiger Unterstützung (LTS); für mindestens ein Jahr. Julia 1.1 wurde im Januar 2019 mit einer neuen "Ausnahmestapel"-Sprache veröffentlicht. Bugfix-Versionen werden ungefähr monatlich erwartet, für 1.4.x und 1.0.x und Julia 1.0.1 bis 1.0.5 haben diesem Zeitplan gefolgt. Julia 1.2 wurde im August 2019 veröffentlicht, und es hat z.B. einige integrierte Unterstützung für Webbrowser (zum Testen bei JavaScript VM) und Julia 1.5 im August 2020 (und damit sind Julia 1.4.x, 1.3.x, 1.2.x und Julia 1.1.xreleases nicht mehr erhalten). Julia 1.3 fügte z.B. komponierbare multi-Threaded Parallelismus und ein binäres Artefaktensystem für Julia-Pakete hinzu. Julia 1.4 erlaubte eine bessere Syntax für Array-Indexing, um z.B. 0-basierte Arrays zu handhaben, mit A[begin+1] für das zweite Element des Arrays A.Das Speichermodell wurde ebenfalls geändert. Mindestfreigabe 1.4.2 festgelegt z.B. ein Zlib-Problem, doppelte Dekompressionsgeschwindigkeit. Julia 1.5 fügt Rekord und Wiederholung Debugging-Unterstützung, für Mozillas Rr-Tool. Es ist eine große Veröffentlichung, mit geändertem Verhalten in der REPL (soft Scope,) wie in Jupyter verwendet, aber voll kompatibel für Nicht-REPL-Code. Die meisten der Thread-API wurde als stabil markiert, und mit dieser Veröffentlichung "arbiträre unmutbare Objekte - unabhängig davon, ob sie Felder haben, die mutierbare Objekte referenzieren oder nicht - können jetzt stapelweise zugeordnet werden", reduzieren Heap-Zuordnungen, z.B. Ansichten werden nicht mehr zugeteilt. Alle Versionen haben an der Leistung gearbeitet, aber vor allem arbeiten an Julia 1.5 gezielte so genannte Zeit-zu-erst-plot-Leistung, im Allgemeinen die Geschwindigkeit der Zusammenstellung selbst (im Gegensatz zur Leistung des generierten Codes), und fügt Tools für Entwickler zur Verbesserung der Paketbelastung hinzu. Auch Julia 1.6 verbessert diese Leistung noch mehr. Pakete, die in Julia 1.0.x arbeiten, sollten in 1.1.x oder neuer arbeiten, aktiviert durch die vorwärtskompatibele Syntax-Garantie. Eine bemerkenswerte Ausnahme waren Fremdsprachen-Interface-Bibliotheken wie JavaCall.jl (für JVM-Sprachen wie Java oder Scala) und Rcall.jl (R-Sprache) durch einige Threading-bezogene Änderungen (in einer Zeit, in der alle Threading-Funktionalität in Julia experimentell markiert wurde). Das Problem war besonders kompliziert für Javas JVM, da es einige besondere Erwartungen hat, wie der Stack-Adressraum genutzt wird. Ein Workaround namens JULIA_ALWAYS_COPY_STACKS wurde für Julia 1.3.0 veröffentlicht, während ein vollständiger Fix für Java anhängig ist und kein festgelegtes Datum hat. Darüber hinaus zeigen JVM-Versionen seit Java 11 dieses Problem nicht. Julia 1.6 hatte ein Fälligkeitsdatum, das bis Ende 2020 verschoben wurde, und Julia 1.7 ist in der Entwicklung. Julia 1.6 war die größte Veröffentlichung seit 1.0, schneller auf vielen Fronten, z.B. eingeführt parallele Vorkompilation und schnellere Beladung von Paketen, in einigen Fällen "50x Beschleunigung in Ladezeiten für große Bäume binärer Artefakte", und ist wahrscheinlich die nächste langfristige Unterstützung (LTS) Freisetzung von Julia. Der Meilenstein für 2.0 hat derzeit kein festgelegtes Datum. Julia 1.6.2 wurde am 14. Juli 2021 veröffentlicht, und Julia 1.7 und 1.8 sind die nächsten Meilensteine, mit der ehemaligen auf den 1. Juni 2021 verschoben (d.h. seitdem ist 1.7 im Feature freeze) und ab Version 1.7 Julia Entwicklung ist wieder auf zeitbasierte Releases. Bemerkenswerte Anwendungen hat Julia einige hochkarätige Nutzer angezogen, vom Investment Manager BlackRock, der es für die Zeitreihenanalyse verwendet, zum britischen Versicherer Aviva, der es für Risikoberechnungen verwendet. Im Jahr 2015 nutzte die Federal Reserve Bank of New York Julia, um Modelle der US-Wirtschaft zu machen, wobei die Sprache die Modellschätzung "etwa 10 mal schneller" als die vorherige MATLAB-Implementierung machte. Julias Mitbegründer gründeten Julia Computing im Jahr 2015, um den Kunden bezahlte Support-, Schulungs- und Beratungsleistungen zu bieten, obwohl Julia weiterhin frei zu bedienen ist. Auf der JuliaCon-Konferenz 2017 gaben Jeffrey Regier, Keno Fischer und andere bekannt, dass das Celeste-Projekt Julia dazu benutzte, "Spitzenleistung von 1,54 petaFLOPS mit 1,3 Millionen Threads" auf 9300 Knights Landing (KNL)-Knoten des Cori II (Cray XC40) Supercomputers zu erreichen (dann 6. schnellster Computer in der Welt). Julia schließt sich damit an C, C,+ und Fortran als hochrangige Sprachen an, in denen petaFLOPS Berechnungen erreicht wurden. Drei der Julia-Co-Creators sind die Empfänger des James H. Wilkinson-Preises 2019 für Numerische Software (bewertet alle vier Jahre) "für die Schaffung von Julia, ein innovatives Umfeld für die Schaffung von leistungsstarken Tools, die die Analyse und Lösung von rechnerischen Wissenschaftsproblemen ermöglichen. "Also, Alan Edelman, Professor für angewandte Mathematik am MIT, wurde ausgewählt, um den IEEE Computer Society Sidney Fernbach Award 2019 zu erhalten "für hervorragende Durchbrüche in High-Performance Computing, lineare Algebra, und Rechenwissenschaft und für Beiträge zur Julia Programmiersprache. "JuliaComputing und NVIDIA verkünden "die Verfügbarkeit der Julia Programmiersprache als vorverpackter Container auf der NVIDIA GPU Cloud (NGC) Containerregistrierung" mit NVIDIA unter Angabe von "Easily Deploy Julia on x86 and Arm .][Julia bietet ein Paket für ein umfassendes HPC-Ökosystem für maschinelles Lernen, Datenwissenschaft, verschiedene wissenschaftliche Domänen und Visualisierung. " Zusätzlich wurde "Julia von der Climate Modeling Alliance als einzige Umsetzungssprache für ihr globales Klimamodell der nächsten Generation ausgewählt. Dieses Multi-Millionen-Dollar-Projekt zielt darauf ab, ein irdisches Klimamodell aufzubauen, das Einblicke in die Auswirkungen und Herausforderungen des Klimawandels bietet. "Julia wird von der NASA und dem brasilianischen INPE für Raummissionsplanung und Satellitensimulation verwendet. Ein weiterer Versuch ist, an einem eingebetteten Projekt zu arbeiten, um einen Satelliten im Weltraum zu steuern, der Julia zur Einstellungskontrolle benutzt. JuliaCon Seit 2014 veranstaltet die Julia Community eine jährliche Julia Konferenz, die sich auf Entwickler und Nutzer konzentriert. Die erste JuliaCon fand in Chicago statt und startete das jährliche Ereignis der Konferenz. Seit 2014 findet die Konferenz über mehrere Standorte statt, darunter das MIT und die University of Maryland, Baltimore. Das Event-Publikum ist von einigen Dutzend Menschen auf über 28.900 einzigartige Teilnehmer während der JuliaCon 2020 gewachsen, die praktisch stattfand. JuliaCon 2021 findet praktisch zwischen dem 28. und 30. Juli 2021 mit Keynote-Adressen von Jan Vitek, Xiaoye Sherry Li und Soumith Chintala statt. Julia Community Die Julia Community hat eine Präsenz auf mehreren Plattformen: Twitter, LinkedIn, Facebook, Slack, Zulip, Discord, Diskurs, Stack Overflow, YouTube und mehr. Seit Mai 2017 beschäftigt die Julia Language einen Community-Manager; zuerst Alex Arsland, der bis Ende 2019 und aktuell Logan Kilpatrick diente. Sponsoren Die Julia-Sprache wurde 2014 zu einem NumFOCUS Fiscally Sponsored-Projekt, um die langfristige Nachhaltigkeit des Projekts sicherzustellen. Dr. Jeremy Kepner am MIT Lincoln Laboratory war in seinen frühen Tagen Gründungsssponsor des Julia-Projekts. Darüber hinaus sind Fonds der Gordon and Betty Moore Foundation, der Alfred P. Sloan Foundation, Intel und Agenturen wie NSF, DARPA, NIH, NASA und FAA für die Entwicklung von Julia unerlässlich. Mozilla, der Hersteller von Firefox-Webbrowser, mit seinen Forschungsstipendien für H1 2019, gesponsert "ein Mitglied des offiziellen Julia-Teams" für das Projekt "Bringing Julia to the Browser", was Firefox und andere Webbrowser bedeutet. Die Julia Language wird auch von einzelnen Spendern auf GitHub unterstützt. Julia Computing Julia Computing, Inc. wurde 2015 von Viral B. Shah, Deepak Vinchhi, Alan Edelman, Jeff Bezanson, Stefan Karpinski und Keno Fischer gegründet. Im Juni 2017 hat Julia Computing von General Catalyst und Gründer Collective 4,6 Millionen US-Dollar an der Saatfinanzierung angehoben, im selben Monat wurde von der Alfred P. Sloan Stiftung "910.000 US-Dollar für die Entwicklung von Open-Source Julia, einschließlich 160.000 US-Dollar für die Diversität in der Julia-Gemeinschaft" geopfert, und im Dezember 2019 erhielt das Unternehmen 1,1 Millionen US-Dollar-Mittel von der US-Regierung zur "Entwicklung eines neuralen Komponenten-Maschinen-Learning-Tools zur Reduzierung des Gesamtenergieverbrauchs". Im Juli 2021 kündigte Julia Computing an, dass sie eine $24 Millionen Dollar Serie A unter der Leitung von Dorilton Ventures aufnahmen. Sprache Features Julia ist eine allgemeine Programmiersprache, während ursprünglich auch für numerische / technische Computing konzipiert. Es ist auch nützlich für Low-Level-Systeme Programmierung, als Spezifikationssprache, und für Web-Programmierung auf Server- und Clientseite. Laut der offiziellen Website, die Hauptmerkmale der Sprache sind Multiple-Versand: Bereitstellung der Fähigkeit, das Funktionsverhalten über viele Kombinationen von Argumenttypen zu definieren Dynamisches Typsystem: Typen für Dokumentation, Optimierung und Versand Leistung nähert sich dem von statisch eingegebenen Sprachen wie C A eingebauten Paketmanager Lisp-ähnliche Makros und andere Metaprogrammierungseinrichtungen Anruf C-Funktionen direkt: keine Wrapper oder spezielle APIs Fähigkeit zur Schnittstelle mit anderen Sprachen, z.B. Python mit PyCall, R mit RCall, und Java/Scala mit JavaCall Leistungsstarke Shell-ähnliche Fähigkeiten, um andere Prozesse zu verwalten Entwickelt für parallele und verteilte Computing Coroutines: leichtes grünes Gewinde Benutzerdefinierte Typen sind so schnell und kompakt wie integrierte Automatische Generierung von effizienten, spezialisierten Code für verschiedene Argumenttypen Elegante und erweiterbare Konvertierungen und Promotionen für numerische und andere Arten Effiziente Unterstützung für Unicode, einschließlich aber nicht beschränkt auf UTF-8Multiple Versand (auch als Multimethods in Lisp bezeichnet) ist eine Verallgemeinerung von Single-Versand – der polymorphe Mechanismus verwendet in gemeinsamen objektorientierten Programmierung (OherOP-Sprachen). In Julia sind alle Betontypen Subtypen von abstrakten Typen, direkt oder indirekt Subtypen der Jede Art, die die Spitze der Typhierarchie ist. Konkrete Typen können nicht selbst unterschrieben werden, wie sie in anderen Sprachen können; Zusammensetzung wird stattdessen verwendet (siehe auch Erbschaft vs Subtyping). Julia zeichnet bedeutende Inspiration aus verschiedenen Dialekten von Lisp, einschließlich Scheme und Common Lisp, und es teilt viele Funktionen mit Dylan, auch eine mehrfach-dispatch-orientierte dynamische Sprache (die eine ALGOL-ähnliche freie Form-Infix-Syntax anstelle einer Lisp-ähnlichen Präfix-Syntax, während in Julia alles ein Ausdruck ist), und mit Fortress, eine andere numerische Programmiersprache (die mehrere Versand und eine raffinierte parametrische Art enthält). Während Common Lisp Object System (CLOS) mehrere Versand in Common Lisp, nicht alle Funktionen sind generische Funktionen. In Julia, Dylan und Festung ist die Extensibilität der Standard, und die eingebauten Funktionen des Systems sind alle generisch und erweiterbar. In Dylan ist der mehrfache Versand ebenso grundlegend wie in Julia: Alle benutzerdefinierten Funktionen und sogar grundlegende eingebaute Operationen wie + sind generisch. Dylans Typsystem unterstützt jedoch nicht vollständig parametrische Typen, die typischer für die ML-Sprache sind. CLOS erlaubt standardmäßig nicht den Versand an den parametrischen Typen von Common Lisp; solche erweiterte Versandsemantik kann nur als Erweiterung durch das CLOS Metaobject Protocol hinzugefügt werden. Durch konvergentes Design verfügt Fortress auch über einen mehrfachen Versand auf parametrischen Arten; im Gegensatz zu Julia ist Fortress jedoch statisch und nicht dynamisch gemustert, mit separaten Berechnungs- und Ausführungsphasen. Die Sprachmerkmale sind in der folgenden Tabelle zusammengefasst: Standardmäßig muss die Julia-Laufzeit vorinstalliert werden, da der anwenderspezifische Quellcode ausgeführt wird. Alternativ kann eine eigenständige Ausführung, die keinen Julia Quellcode benötigt, mit PackageCompiler.jl gebaut werden. Julias syntaktische Makros (verwendet für die Metaprogrammierung), wie Lisp-Makros, sind stärker als Textsubstitutionsmakros, die im Vorprozessor einiger anderer Sprachen wie C verwendet werden, weil sie auf der Ebene der abstrakten Syntaxbäume (ASTs) arbeiten. Julias Makrosystem ist hygienisch, unterstützt aber auch gezielte Erfassung, wenn gewünscht (wie für anaphorische Makros) mit dem Esc-Konstrukt. InteractionDie offizielle Distribution von Julia umfasst eine interaktive Befehlszeile Lese-Eval-Druckschleife (REPL), mit einer durchsuchbaren Geschichte, Tab-Vervollständigung und engagierten Hilfe- und Shell-Modi, die verwendet werden können, um Code schnell zu experimentieren und zu testen. Das folgende Fragment stellt ein Beispiel für die Stichprobensitzung dar, bei dem Strings automatisch von println konkatiert werden: Die REPL gibt Benutzerzugriff auf die Systemhülle und Hilfemodus, indem Sie ; oder ?nach der Eingabeaufforderung (vor jedem Befehl) jeweils. Es hält auch die Geschichte der Befehle, einschließlich zwischen Sitzungen. Code, der innerhalb des interaktiven Abschnitts von Julia getestet oder in eine Datei mit einer .jl-Erweiterung gespeichert werden kann und aus der Befehlszeile durch Tippen ausläuft: Julia wird von Jupyter unterstützt, einer Online-Interaktive Notebook-Umgebung und Pluto.jl, einem "reaktiven Notebook" (wo Notebooks als reine Julia-Dateien gespeichert werden), einem möglichen Ersatz für die frühere Art. Die Verwendung mit anderen Sprachen Julia ist in der Praxis mit vielen Sprachen interoperabel (z.B. Mehrheit der Top 10–20 Sprachen im beliebten Gebrauch). Julias ccall-Keyword wird verwendet, um C-exportierte oder Fortran freigegebene Bibliothek Funktionen einzeln zu nennen, und Pakete, um andere Sprachen wie Python, R, MATLAB, Java oder Scala anrufen zu lassen. Und Pakete für andere Sprachen, z.B. Python (oder R oder Ruby), d.h. pyjulia, um nach Julia zu rufen. Julia hat Unterstützung für den neuesten Unicode 13.0, mit UTF-8 verwendet für Strings (standardmäßig) und für Julia Quellcode (nur erlaubt legal UTF-8 in der neuesten Version), was auch als Option gemeinsame Mathe-Symbole für viele Betreiber, wie ∈ für den in Operator. Julia hat Pakete, die Markup-Sprachen wie HTML (und auch für HTTP,) XML, JSON und BSON unterstützen, sowie für Datenbanken und Web-Nutzung im Allgemeinen. Das Paketsystem Julia verfügt über einen integrierten Paketmanager und umfasst ein Standard-Registrysystem. Pakete werden am häufigsten als Quellcode auf GitHub verteilt, obwohl Alternativen auch verwendet werden können. Pakete können auch als Binaries mit Artefakten installiert werden. Julias Paketmanager wird verwendet, um Pakete abzufragen und zu kompilieren, sowie Management-Umgebungen. Federated Paket Registries werden unterstützt, so dass Registries außer dem Beamten lokal hinzugefügt werden. Implementierung Julias Kern wird in Julia und C umgesetzt, zusammen mit C+ für die LLVM Abhängigkeit. Die Parsing und Code-Niederlassung sind in FemtoLisp implementiert, einem Scheme-Dialekt. Das LLVM-Compiler-Infrastrukturprojekt wird als rückseitiges Ende für die Erzeugung von 64-Bit- oder 32-Bit-optimiertem Maschinencode in Abhängigkeit von der Plattform Julia verwendet. Mit einigen Ausnahmen (z.B. PCRE) wird die Standardbibliothek in Julia implementiert. Der bemerkenswerteste Aspekt der Umsetzung von Julia ist seine Geschwindigkeit, die oft in einem Faktor von zwei relativ zu voll optimierten C-Code (und damit oft eine Größenordnung schneller als Python oder R). Die Entwicklung von Julia begann im Jahr 2009 und eine Open-Source-Version wurde im Februar 2012 veröffentlicht. Aktuelle und zukünftige Plattformen Während Julia tier 1 macOS-Unterstützung, Bedeutung für Intel-basierte Macs, Unterstützung für die brandneue Apple M1-basierte Macs ist nicht explizit spezifiziert (und weder für Windows auf ARM). Julia wird jedoch behauptet, mit Rosetta 2 (das muss Julia emulieren) in Ordnung (bei reduzierter Leistung) zu arbeiten. Die Arbeit an der nativen Full-Speed-M1-Unterstützung (d.h. ohne Emulation) erfolgt meist, und viele Programme können funktionieren, wenn eine solche Anlage von Julia verwendet wird, da nur eine Julia-Tests passieren (außer "zu viele offene Dateien"). Da Julia JIT verwendet, erzeugt Julia nativen Maschinencode direkt, bevor eine Funktion wird zuerst laufen (d.h. ein anderer Ansatz als Kompilieren auf Bytecode, die Sie standardmäßig verteilen, auf einer virtuellen Maschine (VM,) wie bei z.B. Java/JVM laufen zu lassen; dann aus dem Bytecode beim Laufen übersetzt, wie von Dalvik auf älteren Versionen von Android getan). Julia hat vier Unterstützer. Alle IA-32 Prozessoren, die die i686 Subarchitecture vollständig implementieren, werden unterstützt und 64-Bit x86-64 (aka amd64,) weniger als ein Jahrzehnt alt, werden unterstützt. ARMv8 (AArch64) Prozessoren werden in erster Stufe vollständig unterstützt, und ARMv7 und ARMv6 (AArch32) werden mit einigen Höhlen (untere Ebene) für Julia 1.0.x unterstützt und hatten auch offizielle Ausführbare für spätere Versionen, während 32-Bit ARM-Unterstützung wurde später auf Stufe 3 herabgradiert (wie immer, inoffizielle Binaries sind für Julia 1.5.1). CUDA (d.h. Nvidia GPUs; Implementierung von PTX) hat tier 1 Unterstützung, mit Hilfe eines externen Pakets. Es gibt auch Pakete, die andere Beschleuniger unterstützen, wie z.B. Googles TPUs, und AMDs GPUs haben auch Unterstützung mit z.B. OpenCL; und experimentelle Unterstützung für den AMD ROCm Stack. Julia's Downloads-Seite bietet für alle offiziell unterstützten Plattformen Ausführungsmöglichkeiten (und Quelle). Auf einigen Plattformen muss Julia möglicherweise aus dem Quellcode (z.B. dem Original Raspberry Pi) mit spezifischen Build-Optionen, die getan wurde und inoffizielle vorgefertigte Binaries (und Bauanleitungen) sind verfügbar.Julia wurde auf mehreren ARM-Plattformen gebaut. PowerPC (64-bit) hat tier 3 Unterstützung, was bedeutet, dass es "kann oder nicht bauen". Julia wird nun in Raspbian unterstützt, während die Unterstützung besser für neuere Pis ist, z.B. diejenigen mit ARMv7 oder neuer; die Unterstützung von Julia wird von der Raspberry Pi Foundation gefördert. Es gibt auch Unterstützung für Webbrowser/JavaScript durch JSExpr.jl; und die alternative Sprache von Webbrowsern, WebAssembly, hat minimale Unterstützung für mehrere kommende externe Julia Projekte. Julia kann zu ARM kompilieren; so, in der Theorie, Android-Apps können mit der NDK gemacht werden, aber für jetzt Julia wurde gemacht, unter Android nur indirekt laufen, dh mit einer Ubuntu chroot auf Android. Siehe auch Vergleich der numerischen Analysesoftware Vergleich der statistischen Pakete Unterschiedliche Programmierhinweise Referenzen Weiter lesen Nagar, Sandeep (2017). Anfang Julia Programmierung: Für Ingenieure und Wissenschaftler.Springer.ISBN 9781484231715. Bezanson, J; Edelman, A; Karpinski, S; Shah, V. B (2017). "Julia: Ein neuer Ansatz zur numerischen Berechnung". SIAM Review.59 (1): 65–98.arXiv:1411.1607.CiteSeerX 10.1.1.760.8894.doi:10.1137/141000671.S2CID 13026838.Joshi, Anshul (2016). Julia für Data Science - Erkunden Sie die Welt der Datenwissenschaft von Grund auf mit Julia an Ihrer Seite. Packt.ISBN 9781783553860. Offizielle Website julia auf GitHubFrederic Vester (23. November 1925 – 2. November 2003) war ein deutscher Biochemiker und Experte auf dem Gebiet der Ökologie. Biographie Vester wurde in Saarbrücken geboren und studierte Chemie an den Universitäten Mainz, Paris und Hamburg. Von 1955 bis 1957 war er Postdoktorand an der Yale University und Cambridge. Von 1957 bis 1966 arbeitete er an der Saarland University, Saarbrücken, und ab 1969 arbeitete er in München, zuerst am Max-Planck-Institut. 1970 gründete er die private Münchner Frederic Vester Studiengruppe fürBiologie undUmwelt GmbH ("Frederic Vester Study Group for Biology and Environment, Ltd.) nach seinem Tod die Frederic Vester GmbH ("Frederic Vester, Ltd."). Von 1982 bis 1989 war er Professor an der Bundeswehr-Universität München, und von 1989 bis 1991 war er Professor für Angewandte Wirtschaft an der Hochschule St. Gallen, Schweiz. Vesters Ideen beeinflussten die Bildung der Umweltbewegung und der Grünen Partei in Deutschland. Er war Mitglied des Clubs von Rom. Er war mit Anne Vester verheiratet. Das Paar hatte drei Kinder und sechs Enkelkinder. Er starb in München. Work Networked Thinking Vester wurde als Pionier des vernetzten Denkens, einer Kombination von cybernetischen und systemischen Ideen und Komplexität bekannt. Zentrale Ideen des Netzwerkdenkens umfassen die Betrachtung eines Systems als Netz von miteinander verbundenen Effekten, was zu einem auftauchenden Verhalten des Gesamtsystems führt. Diese Netzwerke können durch die Verwendung von Protokollen, mathematischen Netzwerken, Computersoftware beschrieben werden, so dass selbst jemand mit dem grundlegendsten Verständnis von Netzwerken Beziehungen sehen wird, einschließlich positiver und negativer Feedbackschleifen. Simulationen von systemischen Netzwerken können dazu beitragen, die langfristigen Auswirkungen einzelner Maßnahmen zu bestimmen. Das Sensitivity Model Vester's Sensitivity Model verbindet diese Ideen und wird seit den 1980er Jahren in Studien von Ford, UNESCO und anderen Organisationen eingesetzt. Veröffentlichungen Die meisten Vesters-Bücher wurden in Deutsch sowie in anderen Sprachen veröffentlicht, obwohl selten in Englisch. Eine Liste seiner Werke umfasst: 1976, Ballungsgebiete in der Krise (Urban Systems in Crisis) 1979, Das Überlebensprogramm (Plan für Survival) 1982, Das kybernetische Zeitalter (The Cybernetic Age) 1985, Ein Baum ist mehr als Baum(A Tree is More than a Tree) 1990, Leitmotiv vernetztes Denken (Key Themes of Networked Thinking) 1991,Ausfahrt Zukunft: Strategien für den Verkehr von morgen (Gateway Future: Strategien for the Transportation of Tomorrow) 1999, Crashtest Mobilität (Crashtest Mobility) 2002,Aufmerksamkeit im Unterricht (Attentiveness in the Classroom) 2002, Neuland des Denkens (Uncharted Territory of Thought) 2002, Denken, Lernen, Vergessen (Thinking, Learning, Forgetting) 2002, Phänomen 2007 Stress (Phenomenon vernetzt World) 2002 Ideas and Tools for Tackling Complexity (MCB) ISBN 3-939314-05-6Vester ist auch Autor des Software-Tools Sensitivity model und mehrerer cybernetischer Spiele: 1997 Ecopolicy – das kybernetische Strategiespiel (Ecopolicy - The Cybernetic Strategy Game)1980/1996 Ökolopoly. Ein kybernetisches Umweltspiel (Ecopoly - A Cybernetic Environment Game) Referenzen Externe Links Frederic Vester im Deutschen Bibliothekskatalog Professional Biographie von Dr. Vester (Englisch) Frederic Vester im Saarländischen Biografien