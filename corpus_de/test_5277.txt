Real-time Computing (RTC) ist der Begriff der Informatik für Hardware- und Softwaresysteme, die einer "real-time constraint" unterliegen, z.B. von Ereignis zu Systemantwort. Echtzeit-Programme müssen die Reaktion innerhalb bestimmter Fristen garantieren, oft als Fristen bezeichnet". Echtzeit-Reaktionen werden oft in der Größenordnung von Millisekunden und manchmal Mikrosekunden verstanden. Ein in Echtzeit nicht spezifiziertes System kann in der Regel keine Antwort innerhalb eines Zeitrahmens garantieren, obwohl typische oder erwartete Antwortzeiten gegeben werden können. Die Echtzeit-Verarbeitung scheitert, wenn nicht innerhalb einer festgelegten Frist zu einem Ereignis abgeschlossen; Fristen müssen immer eingehalten werden, unabhängig von der Systembelastung. Es wurde ein Echtzeitsystem beschrieben, das "eine Umgebung durch Empfangen von Daten, Verarbeitung und Rückgabe der Ergebnisse so schnell kontrolliert, dass die Umgebung zu diesem Zeitpunkt beeinträchtigt wird". Der Begriff Echtzeit wird auch in der Simulation verwendet, um zu bedeuten, dass die Simulationsuhr mit der gleichen Geschwindigkeit wie eine reale Uhr läuft, und in Prozesssteuerungs- und Unternehmenssystemen bedeutet "ohne signifikante Verzögerung". Echtzeit-Software kann ein oder mehrere der folgenden verwenden: Synchrone Programmiersprachen, Echtzeit-Betriebssysteme und Echtzeit-Netzwerke, die jeweils wesentliche Rahmenbedingungen für den Aufbau einer Echtzeit-Software-Anwendung bieten. Systeme, die für viele missionskritische Anwendungen eingesetzt werden, müssen Echtzeit sein, wie zum Beispiel zur Steuerung von Flug-für-Draht-Flugzeugen oder Anti-Lock-Bremsen, die beide eine sofortige und genaue mechanische Reaktion erfordern. Geschichte Der Begriff Realzeit ergibt sich aus seiner Verwendung in der Frühsimulation, bei der ein realer Prozess mit einer Rate simuliert wird, die dem realen Prozess entspricht (jetzt Echtzeitsimulation genannt, um Mehrdeutigkeit zu vermeiden). Analoge Computer waren am häufigsten in der Lage, mit einem viel schnelleren Tempo als Echtzeit zu simulieren, eine Situation, die genauso gefährlich sein könnte wie eine langsame Simulation, wenn sie nicht auch erkannt und berücksichtigt wurden. Minicomputer, vor allem in den 1970er Jahren, als sie in dedizierte Embedded-Systeme wie DOG (Digital on-screen graphische) Scanner eingebaut wurden, erhöhten die Notwendigkeit von Low-Latency-Prioritäts-Antworten auf wichtige Interaktionen mit eingehenden Daten und so Betriebssystemen wie Data General's RDOS (Real-Time Disk Operating System) und RTOS mit Hintergrund- und Foreground-Scheduling sowie der Digital Corporation. Hintergrund-foreground-Scheduling erlaubte niedrige Prioritätsaufgaben CPU-Zeit, wenn keine Vordergrundaufgabe erforderlich, um auszuführen, und gab absolute Priorität im Vordergrund zu Threads/tasks mit der höchsten Priorität. Auch Echtzeit-Betriebssysteme würden für die zeitliche Aufteilung von Mehrbenutzern verwendet werden. Beispielsweise könnte Data General Business Basic im Vordergrund oder Hintergrund von RDOS laufen und weitere Elemente in den Planungsalgorithmus einführen, um es für Menschen, die über dumme Terminals interagieren, besser geeignet zu machen. Einmal, als die MOS Technology 6502 (im Commodore 64 und Apple II) und später, als die Motorola 68000 (im Macintosh, Atari ST und Commodore Amiga) populär waren, konnte jeder seinen Heimcomputer als Echtzeit-System nutzen. Die Möglichkeit, andere Interrupts für festcodierte Schleifen mit definiertem Timing zu deaktivieren, und die niedrige Interrupt-Latenz erlaubte die Implementierung eines Echtzeit-Betriebssystems, wodurch die Benutzeroberfläche und die Festplatte geringere Priorität als der Echtzeit-Gewinde. Im Vergleich dazu erzeugt der programmierbare Interrupt-Controller der Intel CPUs (8086..80586) eine sehr große Latenz und das Windows-Betriebssystem ist weder ein Echtzeit-Betriebssystem noch erlaubt es ein Programm, die CPU vollständig zu übernehmen und einen eigenen Scheduler zu verwenden, ohne native Maschinensprache zu verwenden und damit alle unterbrechenden Windows-Codes zu übertreffen. Es existieren jedoch mehrere Kodierungsbibliotheken, die auf einer Vielzahl von Betriebssystemen Echtzeit-Fähigkeiten in hoher Sprache bieten, beispielsweise Java Real Time. Die Motorola 68000 und anschließende Familienmitglieder (68010, 68020 etc.) wurden auch bei Herstellern industrieller Kontrollsysteme populär. Dieser Anwendungsbereich ist ein Bereich, in dem Echtzeit-Kontrolle echte Vorteile hinsichtlich Prozessleistung und Sicherheit bietet. Kriterien für Echtzeit-Computing Ein System soll Echtzeit sein, wenn die Gesamtkorrektheit einer Operation nicht nur von ihrer logischen Korrektheit, sondern auch von der Zeit abhängt, in der sie durchgeführt wird. Real-time-Systeme sowie ihre Fristen werden durch die Folge der fehlenden Frist klassifiziert: Hard – eine Frist fehlt, ist ein totaler Systemausfall. Firm – seltene Terminfehle sind tolerierbar, können aber die Qualität des Systems beeinträchtigen. Die Nützlichkeit eines Ergebnisses ist nach Ablauf der Frist null. Weich – die Nützlichkeit eines Ergebnisses verschlechtert sich nach Ablauf der Frist und verschlechtert damit die Servicequalität des Systems. Das Ziel eines harten Echtzeitsystems ist es, sicherzustellen, dass alle Termine eingehalten werden, aber für weiche Echtzeitsysteme wird das Ziel eine bestimmte Teilmenge von Terminen erfüllen, um einige anwendungsspezifische Kriterien zu optimieren. Die jeweils optimierten Kriterien hängen von der Anwendung ab, aber einige typische Beispiele umfassen die Maximierung der Anzahl der erfüllten Fristen, die Minimierung der Lateness der Aufgaben und die Maximierung der Anzahl der hochrangigen Aufgaben, die ihre Fristen erfüllen. Harte Echtzeitsysteme werden verwendet, wenn es zwingend notwendig ist, dass ein Ereignis innerhalb einer strengen Frist umgesetzt wird. Solche starken Garantien sind für Systeme erforderlich, bei denen die Reaktion in einem bestimmten Zeitintervall nicht zu einem großen Verlust in irgendeiner Weise führen würde, insbesondere die Umgebung physisch zu schädigen oder das menschliche Leben zu bedrohen (obwohl die strenge Definition einfach ist, dass das Fehlen der Frist ein Ausfall des Systems darstellt). Einige Beispiele für harte Echtzeitsysteme: Ein Automotor-Steuersystem ist ein hartes Echtzeitsystem, da ein verzögertes Signal einen Motorausfall oder Beschädigung verursachen kann. Medizinische Systeme wie Herzschrittmacher. Obwohl die Aufgabe eines Schrittmachers einfach ist, sind medizinische Systeme wie diese aufgrund des potentiellen Risikos für das menschliche Leben in der Regel dazu verpflichtet, gründliche Tests und Zertifizierungen durchzuführen, was wiederum eine harte Echtzeit-Computing erfordert, um nachweisbare Garantien zu bieten, dass ein Ausfall unwahrscheinlich oder unmöglich ist. Industrielle Prozesssteuerungen, wie eine Maschine auf einer Montagelinie. Wird die Maschine verzögert, könnte das Produkt auf der Montagelinie über die Reichweite der Maschine hinausgehen (das Produkt unberührt lassen), oder die Maschine oder das Produkt könnte durch die Aktivierung des Roboters zum falschen Zeitpunkt beschädigt werden. Wird der Ausfall erkannt, würden beide Fälle zu einem Stillstand der Montagelinie führen, was die Produktion verlangsamt. Wird der Ausfall nicht erkannt, könnte ein Produkt mit einem Defekt es durch Produktion machen oder in späteren Produktionsschritten Schäden verursachen. Harte Echtzeit-Systeme finden typischerweise eine Interaktion auf einem niedrigen Niveau mit physikalischer Hardware, in eingebetteten Systemen. Frühe Videospielsysteme wie die Atari 2600 und Cinematronics Vektorgrafiken hatten aufgrund der Art der Grafik- und Timing-Hardware harte Echtzeitanforderungen. Softmodems ersetzen ein Hardwaremodem mit Software, die auf der CPU eines Computers läuft. Die Software muss alle wenigen Millisekunden ausführen, um die nächsten Audiodaten zu erzeugen, die ausgegeben werden sollen. Wenn diese Daten verspätet sind, verliert das empfangende Modem die Synchronisation, wodurch eine lange Unterbrechung, da die Synchronisation wieder hergestellt wird oder die Verbindung vollständig verloren geht. Viele Drucker haben harte Echtzeit-Anforderungen, wie Inkjets (die Tinte muss zum richtigen Zeitpunkt abgelegt werden, da der Druckkopf die Seite überquert), Laserdrucker (der Laser muss zum richtigen Zeitpunkt aktiviert werden, wenn der Strahl über die rotierende Trommel scannt), Punktmatrix und verschiedene Arten von Zeilendruckern (der Schlagmechanismus muss zum richtigen Zeitpunkt aktiviert werden, da der Druckmechanismus mit der gewünschten Ausgabe in Einklang kommt). Ein Ausfall in einem dieser würde entweder fehlende Ausgabe oder fehlerhafte Ausgabe verursachen. Im Rahmen von Multitasking-Systemen wird die Planungspolitik normalerweise vorrangig (vor-emptive Scheduler) betrieben. In einigen Situationen können diese eine harte Echtzeit-Performance gewährleisten (z.B. wenn die Aufgaben und ihre Prioritäten im Voraus bekannt sind). Es gibt andere harte Echtzeitplaner, wie z.B. Raten-Monotonik, die in allgemeinen Systemen nicht üblich sind, da sie zusätzliche Informationen benötigen, um eine Aufgabe zu planen: nämlich eine gebundene oder schlimmste Schätzung, wie lange die Aufgabe ausführen muss. Spezifische Algorithmen zur Terminierung solcher harter Echtzeit-Aufgaben existieren, wie zum Beispiel früheste Frist, die, ohne die Überleitung der Kontextschaltung zu ignorieren, für Systemlasten von weniger als 100 % ausreicht. Neue Overlay-Scheduling-Systeme, wie ein adaptiver Partitionsplaner helfen bei der Verwaltung großer Systeme mit einer Mischung aus harten Echtzeit- und nicht Echtzeit-Anwendungen. Firm Echtzeit-Systeme sind vernebelt definiert, und einige Klassifikationen enthalten sie nicht, unterscheiden nur harte und weiche Echtzeit-Systeme. Einige Beispiele für feste Echtzeitsysteme: Die zuvor als harte Echtzeit beschriebene Montagelinie Maschine könnte stattdessen als feste Echtzeit betrachtet werden. Eine versäumte Frist verursacht immer noch einen Fehler, der behandelt werden muss: Es könnte Maschinen geben, um einen Teil als schlecht zu markieren oder aus der Montagelinie auszuwerfen, oder die Montagelinie könnte gestoppt werden, so dass ein Bediener das Problem korrigieren kann. Solange diese Fehler jedoch selten sind, können sie toleriert werden. Weiche Echtzeit-Systeme werden typischerweise verwendet, um Probleme des gleichzeitigen Zugangs zu lösen und die Notwendigkeit, eine Reihe angeschlossener Systeme durch wechselnde Situationen auf dem neuesten Stand zu halten. Einige Beispiele für weiche Echtzeitsysteme: Software, die die Flugpläne für kommerzielle Airliner aufrechterhält und aktualisiert. Die Flugpläne müssen recht aktuell gehalten werden, aber sie können mit der Latenz von einigen Sekunden arbeiten. Live-Audio-Video-Systeme sind auch in der Regel weiche Echtzeit. Ein Tonrahmen, der spät gespielt wird, kann dazu führen, dass ein kurzer Audio-Glitch (und kann dazu führen, dass alle nachfolgenden Audios entsprechend verzögert werden, wodurch eine Wahrnehmung, dass das Audio langsamer als normal gespielt wird), aber dies kann besser sein als die Alternativen, Stille, statische, einen vorherigen Audiorahmen oder geschätzte Daten. Ein Videorahmen, der verspätet ist, verursacht in der Regel noch weniger Störungen für Zuschauer. Das System kann auch in Zukunft mit Workload-Prädiktions- und Rekonfigurationsmethoden arbeiten und wiederherzustellen. Ebenso sind Videospiele oft weich Echtzeit, insbesondere wenn sie versuchen, eine Ziel-Rahmenrate zu erfüllen. Da das nächste Bild nicht im Voraus berechnet werden kann, da es von Eingaben des Players abhängt, steht nur eine kurze Zeit zur Verfügung, um das gesamte für die Erstellung eines Videorahmens benötigte Computing durchzuführen, bevor dieser Frame angezeigt werden muss. Wenn die Frist versäumt ist, kann das Spiel mit einer niedrigeren Framerate fortfahren; je nach Spiel kann dies nur seine Grafik beeinflussen (wenn das Gameplay mit normaler Geschwindigkeit weitergeht), oder das Gameplay selbst kann verlangsamt werden (was bei älteren Konsolen der dritten und vierten Generation üblich war). Echtzeit in der digitalen Signalverarbeitung In einem Echtzeit-Digital-Signalverarbeitungsprozess (DSP) können die analysierten (Eingang) und generierten (Ausgangs-)Proben in der Zeit, in der sie zum Eingeben und Ausgeben derselben Menge von Proben unabhängig von der Verarbeitungsverzögerung kontinuierlich verarbeitet (oder erzeugt) werden. Es bedeutet, dass die Verarbeitungsverzögerung auch dann begrenzt werden muss, wenn die Verarbeitung unbegrenzt weitergeht. Das bedeutet, dass die mittlere Verarbeitungszeit pro Probe, einschließlich Overhead, nicht größer ist als die Probenahmeperiode, was die gegenseitige Abtastrate ist. Dies ist das Kriterium, ob die Proben in großen Segmenten zusammengefasst und als Blöcke verarbeitet oder einzeln verarbeitet werden und ob lange, kurze oder nicht vorhandene Ein- und Ausgabepuffer vorhanden sind. Betrachten Sie ein Audio-DSP-Beispiel; wenn ein Prozess 2.01 Sekunden benötigt, um zu analysieren, zu synthetisieren oder zu verarbeiten 2.00 Sekunden Klang, ist es nicht Echtzeit. Wenn es jedoch 1,99 Sekunden dauert, ist es oder kann in einen Echtzeit-DSP-Prozess gemacht werden. Eine gemeinsame Lebensanalogik steht in einer Linie oder Warteschlange, die auf den Checkout in einem Lebensmittelgeschäft wartet. Wenn die Linie asymptotisch länger und länger ohne Grenzen wächst, ist der Checkout-Prozess nicht Echtzeit. Wenn die Länge der Linie begrenzt wird, werden Kunden so schnell verarbeitet und ausgegeben, wie sie eingegeben werden, dann ist dieser Prozess Echtzeit. Der Lebensmittelhändler könnte aus dem Geschäft gehen oder zumindest verlieren, wenn er seinen Check-out-Prozess nicht in Echtzeit machen kann; so ist es grundsätzlich wichtig, dass dieser Prozess Echtzeit ist. Ein Signalverarbeitungsalgorithmus, der nicht mit dem Fluss von Eingangsdaten aufrecht erhalten kann, wobei der Ausgang weiter und weiter hinter dem Eingang fällt, ist nicht Echtzeit. Wird jedoch die Verzögerung des Ausgangs (bezogen auf den Eingang) bezüglich eines Prozesses begrenzt, der über eine unbegrenzte Zeit arbeitet, so ist dieser Signalverarbeitungsalgorithmus Echtzeit, auch wenn die Durchsatzverzögerung sehr lang sein kann. Live vs. real-time Echtzeit-Signalverarbeitung ist notwendig, aber nicht ausreichend in und von selbst, für Live-Signalverarbeitung wie das, was in Live-Event-Unterstützung benötigt wird. Live-Audio-Digital-Signalverarbeitung erfordert sowohl Echtzeit-Betrieb als auch eine ausreichende Grenze zur Durchsatzverzögerung, um für Performer mit Bühnenmonitoren oder In-Ohr-Monitoren tolerierbar zu sein und nicht als Lip-Sync-Fehler durch das Publikum auch direkt die Performer zu beobachten. Die tolerierbaren Grenzen für die Latenz für die Live-, Echtzeit-Verarbeitung sind Gegenstand von Untersuchungen und Debatten, werden jedoch zwischen 6 und 20 Millisekunden geschätzt. Echtzeit-Bidirektionale Telekommunikationsverzögerungen von weniger als 300 ms ("Rundreise" oder doppelte unidirektionale Verzögerung) werden als akzeptabel angesehen, um unerwünschte Gespräche im Gespräch zu vermeiden. Real-time und leistungsfähige Echtzeit-Computing ist manchmal missverstanden, um Hochleistungs-Computing zu sein, aber das ist keine genaue Klassifizierung. Beispielsweise kann ein massiver Supercomputer, der eine wissenschaftliche Simulation durchführt, eine beeindruckende Leistung bieten, aber er führt keine Echtzeitrechnung durch. Umgekehrt, wenn die Hardware und Software für ein Anti-Lock-Bremssystem entwickelt worden sind, um seine erforderlichen Fristen zu erfüllen, sind keine weiteren Leistungsgewinne obligatorisch oder sogar nützlich. Darüber hinaus, wenn ein Netzwerk-Server mit Netzwerk-Verkehr hochgeladen ist, seine Antwortzeit kann langsamer sein, aber wird (in den meisten Fällen) noch erfolgreich, bevor es aus (ihre Frist). Ein solcher Netzwerk-Server würde daher nicht als Echtzeit-System betrachtet werden: Zeitversagen (Verzögerungen, Zeitausfälle, etc.) sind typischerweise klein und kompartalisiert (begrenzt in der Wirkung), sind aber keine Katastrophenversagen. In einem Echtzeit-System, wie dem FTSE 100 Index, würde eine Verlangsamung über Grenzen oft als katastrophal in seinem Anwendungskontext angesehen werden. Die wichtigste Anforderung eines Echtzeit-Systems ist gleichbleibende Leistung, nicht hohe Durchsatz. Einige Arten von Software, wie viele Schachspielprogramme, können in beide Kategorien fallen. Zum Beispiel muss ein Schachprogramm, das in einem Turnier mit einer Uhr gespielt wird, über einen Schritt vor einer bestimmten Frist entscheiden oder das Spiel verlieren, und ist daher eine Echtzeit-Rechnung, aber ein Schachprogramm, das unbegrenzt laufen darf, bevor es nicht bewegt wird. In beiden Fällen ist jedoch eine hohe Leistung wünschenswert: Je mehr Arbeit ein Turnier Schach-Programm kann in der zugeteilten Zeit, desto besser werden seine Bewegungen sein, und je schneller ein untrainierter Schach-Programm läuft, desto schneller wird es sich bewegen können. Dieses Beispiel verdeutlicht auch den wesentlichen Unterschied zwischen Echtzeit-Rechnungen und anderen Berechnungen: Wenn das Turnier-Chassis-Programm keine Entscheidung über seinen nächsten Schritt in seiner zugeteilten Zeit trifft, verliert es das Spiel - d.h. es scheitert als Echtzeit-Rechnung -, während im anderen Szenario angenommen wird, die Frist zu erfüllen ist nicht notwendig. Die Leistungsfähigkeit ist indikativ für die in einer bestimmten Zeit durchgeführte Verarbeitungsmenge, während Echtzeit die Möglichkeit ist, mit der Verarbeitung zu einer Nutzleistung in der zur Verfügung stehenden Zeit zu gelangen. Nahe Echtzeit Der Begriff "nahe Echtzeit" oder "nahe Echtzeit" (NRT) im Telekommunikations- und Computing bezieht sich auf die Zeitverzögerung, die durch automatisierte Datenverarbeitung oder Netzwerkübertragung zwischen dem Auftreten eines Ereignisses und der Nutzung der verarbeiteten Daten, wie zum Beispiel für Anzeige- oder Rückmeldungs- und Kontrollzwecke, eingeführt wird. Beispielsweise zeigt ein Nah-Real-Time-Display ein Ereignis oder eine Situation, wie es zu der aktuellen Zeit minus der Bearbeitungszeit existierte, wie fast die Zeit des Live-Events. Die Unterscheidung zwischen den Begriffen "near real time" und "real time" ist etwas vernebelt und muss für die jeweilige Situation definiert werden. Der Begriff bedeutet, dass es keine signifikanten Verzögerungen gibt. In vielen Fällen würde die als Echtzeit beschriebene Verarbeitung genauer als "nahe Echtzeit" beschrieben werden. Nahe Echtzeit bezieht sich auch auf verzögerte Echtzeitübertragung von Sprache und Video. Es ermöglicht das Spielen von Videobildern in etwa Echtzeit, ohne auf eine ganze große Videodatei warten zu müssen, um herunterladen. Inkompatible Datenbanken können in gängige Flachdateien exportieren/importieren, die die andere Datenbank planmäßig importieren/exportieren kann, so dass sie gemeinsame Daten in "nahe Echtzeit" miteinander synchronisieren/ teilen können. Die Unterscheidung zwischen "nahe Echtzeit" und Echtzeit variiert, und die Verzögerung ist abhängig von Art und Geschwindigkeit der Übertragung. Die Verzögerung in naher Echtzeit liegt typischerweise in einem Bereich von 1-10 Sekunden. Es gibt verschiedene Methoden, um die Konstruktion von Echtzeitsystemen zu unterstützen, von denen ein Beispiel MASCOT ist, eine alte, aber sehr erfolgreiche Methode, die die gleichzeitige Struktur des Systems darstellt. Weitere Beispiele sind HOOD, Real-Time UML, AADL, das Ravenscar-Profil und Real-Time Java. Siehe auch Referenzen Weiter lesen Burns, Alan; Wellings, Andy (2009), Real-Time Systems and Programming Languages (4th ed,.) Addison-Wesley, ISBN 978-0-321-41745-9 Buttazzo, Giorgio (2011,) Hard Real-Time Computing Systems: Predictable Scheduling Algorithms and Applications, New York, NY: Springer, ISBN 9781461406761. Liu, Jane W. S. (2000,) Echtzeitsysteme, Upper Saddle River, NJ: Prentice Hall. International Journal of Time-Critical Computing Systems Externe Links IEEE Technical Committee on Real-Time Systems Euromicro Technical Committee on Realtime Systems Das Was, Wo und Warum der Echtzeit-Simulation "DESIGN eines REAL-TIME-PROGRAMMS-SYSTEMs". Computer und Automatisierung.XII (9): 26–34.Sep 1963.][ Notizen, die hoffentlich Probleme aufzeigen, die in Echtzeit-Design betrachtet werden sollten.