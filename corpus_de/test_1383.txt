BLAKE ist eine kryptographische Hash-Funktion basierend auf Dan Bernsteins ChaCha-Stream-Chiffre, jedoch wird vor jeder ChaCha-Runde eine permutierte Kopie des Eingangsblocks, XORed mit Rundkonstanten, hinzugefügt. Wie SHA-2 gibt es zwei Varianten, die sich in der Wortgröße unterscheiden. ChaCha arbeitet auf einer 4×4 Reihe von Wörtern. BLAKE kombiniert wiederholt einen 8-Worte Hash-Wert mit 16 Nachrichtenwörtern, wobei das ChaCha-Ergebnis um den nächsten Hash-Wert gekürzt wird. BLAKE-256 und BLAKE-224 verwenden 32-Bit-Worte und produzieren Verdauungsgrößen von 256 Bit bzw. 224 Bit, während BLAKE-512 und BLAKE-384 64-Bit-Worte verwenden und Verdauungsgrößen von 512 Bit bzw. 384 Bit erzeugen. Die auf BLAKE basierende Hash-Funktion BLAKE wurde 2012 bekannt gegeben. Die auf BLAKE2 basierende Hashfunktion BLAKE3 wurde 2020 bekannt gegeben. Die Geschichte BLAKE wurde dem NIST Hash-Funktionswettbewerb von Jean-Philippe Aumasson, Luca Henzen, Willi Meier und Raphael C.-W Phan vorgelegt. 2008 gab es 51 Einträge. BLAKE machte es in die letzte Runde bestehend aus fünf Kandidaten, aber verloren Keccak in 2012, die für den SHA-3 Algorithmus ausgewählt wurde. Algorithm Like SHA-2, BLAKE kommt in zwei Varianten: eine, die 32-Bit-Worte verwendet, verwendet für die Berechnung von Hashes bis zu 256 Bit lang, und eine, die 64-Bit-Worte verwendet, verwendet für die Berechnung von Hashes bis zu 512 Bit lang. Die Core-Block-Transformation kombiniert 16 Eingabewörter mit 16 Arbeitsgrößen, wobei zwischen Blöcken nur 8 Wörter (256 oder 512 Bit) erhalten bleiben. Es verwendet eine Tabelle mit 16 konstanten Wörtern (die führenden 512 oder 1024 Bits des fraktionierten Teils von π), und eine Tabelle mit 10 16-Elementen-Permutationen: σ[0] = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 σ[1] = 14 10 4 8 6 1 12 0 2 7 5 3 σ[2] = 11 8 12 0 5 Es wird 8 mal pro Vollrunde durchgeführt: j ← σ[r%10][2×i // Indexberechnungen k ← σ[r%10][2×i+1 a + b + (m[j] ⊕ n[k]]] /Step 1 (mit Eingabe)d ← (d ⊕ a) >> 16 c ← c + d /Step 2 (keine Eingabe) b ← (b ⊕ c) >> 12 a ← a + b + (m[k] ⊕ n[j)] /Step 3 (mit Eingabe)d ← (d ⊕ a) >> 8 c ← c + d /Step 4 (keine Eingabe) b ← (b ⊕ c) >> 7 r ist die runde Zahl (0–13), und ich schwankt von 0 bis 7. Die Unterschiede in der Viertelrunde von ChaCha sind: Der Zusatz der Nachrichtenwörter wurde hinzugefügt. Die Drehrichtungen wurden umgekehrt. "BLAKE nutzt die Permutation des ChaCha-Streams mit Drehungen in die entgegengesetzte Richtung. Einige haben eine erweiterte Optimierung vermutet, aber in der Tat stammt es von einem Typo in den ursprünglichen BLAKE Spezifikationen", erklärt Jean-Philippe Aumasson in seinem "Crypto Dictionary". Die 64-Bit-Version (die in ChaCha nicht existiert) ist identisch, aber die Rotationsbeträge sind 32, 25, 16 bzw. 11, und die Anzahl der Runden wird auf 16 erhöht. Tweaks Während des NIST Hash-Funktionswettbewerbs dürfen die Teilnehmer ihre Algorithmen an Themen ansprechen, die entdeckt werden. Änderungen an BLAKE sind: Die Anzahl der Runden wurde von 10/14 auf 14/16 erhöht. Dies ist zu konservieren über die Sicherheit, während immer noch schnell. BLAKE-224=")( 7dc5313b1c04512a174bd6503b89607aecbee0903d40a8a569c94eed BLAKE-256=")(716f6e863f744b9c97c7b76ea5f5908bc5b267 BLAKE-512")(=a8cfbbd73726062df0c6864dda65defe58ef0cc52a5625090fa17601eecd1b628e94f396ae402a00acc9eab77b4d4c2eaaaa25a636d80af3fc7913ef5b8 Ein einzelnes Bit verändert jedes Bit in der Ausgabe mit 50 % Wahrscheinlichkeit, zeigt einen Lawineneffekt: BLAKE-512("Der schnelle braune Fuchs springt über den faulen Hund") = 1f7e26f63b6ad25a0896fd9ccf BLAKE2 BLAKE2 ist eine kryptographische Hash-Funktion basierend auf BLAKE, erstellt von Jean-Philippe Aumasson, Samuel Neves, Zooko Wilcox-O'Hearn und Christian Winnerlein. Das Design-Ziel war es, die weit verbreiteten, aber gebrochenen, MD5 und SHA-1 Algorithmen in Anwendungen zu ersetzen, die eine hohe Leistung in der Software erfordern. BLAKE2 wurde am 21. Dezember 2012 bekannt gegeben. Eine Referenz-Implementierung ist unter CC0, der OpenSSL-Lizenz und der Apache Public License 2.0 verfügbar. BLAKE2b ist schneller als MD5, SHA-1, SHA-2 und SHA-3, auf 64-Bit x86-64 und ARM-Architekturen. BLAKE2 bietet bessere Sicherheit als SHA-2 und ähnlich wie SHA-3: Immunität zur Längenverlängerung, Gleichgültigkeit von einem zufälligen Orakel, etc. BLAKE2 entfernt die Addition von Konstanten an Nachrichtenworte von BLAKE-Rundfunktion, ändert zwei Rotationskonstanten, vereinfacht die Polsterung, addiert den Parameterblock, der mit Initialisierungsvektoren XOR'ed ist, und reduziert die Anzahl der Runden von 16 auf 12 für BLAKE2b (Successor von BLAKE-512) und von 14 auf 10 für BLAKE2s (Successor von BLAKE-256). BLAKE2 unterstützt Keying, Salzung, Personalisierung und Hashbaummodi und kann Därme von 1 bis 64 Bytes für BLAKE2b oder bis zu 32 Bytes für BLAKE2s ausgeben. Es gibt auch parallele Versionen, die für eine gesteigerte Leistung auf Multicore-Prozessoren ausgelegt sind; BLAKE2bp (4-Wege parallel) und BLAKE2sp (8-Wege parallel). BLAKE2X ist eine Familie von Extensible-Output-Funktionen (XOFs). Während BLAKE2 auf 64-Byte-Verdauungen beschränkt ist, ermöglicht BLAKE2X Verdauungen von bis zu 256 GiB. BLAKE2X ist selbst kein Fall einer Hash-Funktion und muss auf einer tatsächlichen BLAKE2-Instanz beruhen. Ein Beispiel für eine BLAKE2X-Instanz könnte BLAKE2Xb16MiB sein, die eine BLAKE2X-Version auf Basis von BLAKE2b sein würde, die 16,777,216-Byte-Dauts (oder genau 16 MiB, also der Name einer solchen Instanz) produziert. BLAKE2b und BLAKE2s sind in RFC 7693 spezifiziert. Optionale Funktionen, die den Parameterblock (Salting, personalisierte Hashes, Baumhahing, et cetera) verwenden, werden nicht spezifiziert und sind somit weder für BLAKE2bp, BLAKE2sp oder BLAKE2X unterstützt. BLAKE2sp ist die BLAKE2-Version, die von 7zip-Datei-Kompressorsignatur im Kontextmenü "CRC SHA" verwendet wird. Initialisierungsvektor BLAKE2b verwendet einen Initialisierungsvektor, der dem von SHA-512 verwendeten IV entspricht. Diese Werte werden durch Aufnahme der ersten 64 Bit der fraktionierten Teile der positiven Quadratwurzeln der ersten acht Grundzahlen transparent erhalten. VORSCHRIFTEN Pseudocode für den BLAKE2b-Algorithmus. Der BLAKE2b-Algorithmus verwendet 8-byte (UInt64) Wörter und 128-byte-Chunks. Algorithm BLAKE2b Eingang: M Nachricht zu hashed cbMessageLen: Nummer, (0..2128) Länge der Nachricht in Bytes Schlüssel Optional 0..64 Byte Schlüssel cbKeyLen: Nummer, (0..64) Länge des optionalen Schlüssels in Bytes cbHashLen: Nummer, (1..64) Ausgewünschte Hashlänge in Bytes Ausgabe: Hash Hash von cbHashLen bytes Initialisieren Staatsvektor h mit IV h0.7 ← IV0..7 Mischen Sie Schlüsselgröße (cbKeyLen) und gewünschte Hashlänge (cbHashLen) in h0 h0 ← h0 xor 0x0101kkn, wo kk ist Schlüssellänge (in Bytes) nn ist Desired Hash Länge (in Bytes) Jedes Mal, wenn wir komprimieren, wie viele Bytes wurden komprimiert cBytesCompressed 0 cBytesRemaining ← cb Wenn ein Schlüssel geliefert wurde (d.h. cbKeyLen > 0) dann mit nachlaufenden Nullen, um es 128-Bytes (d.h. 16 Wörter) zu machen und es an die Nachricht M zu verhängen, wenn (cbKeyLen > 0) dann M ← Pad(Key, 128)||M cBytesRemaining ← cBytesRemaining + 128 end if Compress ganz 128-byte chunks der Nachricht, außer dem letzten chunk, während (cBytesRemaining > 128) chunken. Die tatsächliche Anzahl von Bytes im M chunk ← Pad(chunk, 128) Wenn M leer war, dann werden wir noch komprimieren ein letztes Stück von Nullen h ← Compress(h, chunk, cBytesCompressed, true) true ⇒ this is the last chunk Result ← first cbHashLen bytes of little endian statevektor hEnd Algorithm BLAKE2b Compress Die Compress-Funktion nimmt einen vollen 128-Byte-Chunk der Eingabenachricht und mischt sie in das laufende Zustandsfeld: Function Compress Input: h Persistent statevektor chunk 128-byte (16 Doppelwort) chunk of message to Komprimierung t: Number, 0..2128 Anzahl der Bytes, die in die Kompression IsLastBlock eingespeist wurden: Boolean zeigt an, wenn dies die letzte Runde der Kompression Ausgabe ist: h Aktualisiert persistent Zustand Vektor Setup lokalen Arbeitsvektor V V V0..7 ← h0.7 Erste acht Artikel werden aus persistentem Zustandsvektor h V8..15 ← IV0.7 kopiert. Bleibt acht Artikel aus dem IV Mix der 128-Bit-Zähler t in V12:V13 V12 ← V12 xor Lo(t) Lo 64-bits von UInt128 t V13 ← V13 xor Hi(t) Hi 64-bits von UInt128 t Ist dies der letzte Block, dann invertieren alle Bits in V14, wenn IsLastBlock dann V14 ← V14 xor 0x FFFFFFFFFFFFFFFFFFFFFF Behandeln Sie jede 128-byte Nachricht chunk als sechzehn 8-byte (64-bit) Wörter m0..15 ← chunk Zwölf Runden der kryptographischen Nachrichtenmischung für i von 0 bis 11 wählen Sie Nachrichten-Mischungsschema für diese Runde. BLAKE2b verwendet 12 Runden, während SIGMA nur 10 Einträge hat. S0..15 ← SIGMA[i mod 10] V[0] m[S] m[S] m[S] m[S] m[S] m[S] Die Mix-Funktion wird von der Compress-Funktion aufgerufen und mischt zwei 8-byte Wörter aus der Nachricht in den Hash-Zustand. In den meisten Implementierungen würde diese Funktion inline oder als inlined Funktion geschrieben werden. Funktion Mix Inputs: Va, Vb, Vc, Vd vier 8-byte Worteinträge aus dem Arbeitsvektor V x, y zwei 8-byte Worteinträge aus gepolsterter Nachricht m Ausgang: Va. Vb, Vc, Vd die modifizierten Versionen von Va, Vb, Vc, Vd Va + Vb + x mit Eingang Vd ← (Vd xor Va) rotright 32 Vc ← Vc + Vd kein Eingang Vb ← (Vb xor Vc) rotright 24 ← Va + Vb + y mit Eingang Vd ← Vend xor Va) rotright 16 Vc + Vd kein Eingang Vb. Hash-Werte eines leeren Strings: BLAKE2s-224")(= 1fa1291e65248b37b3433475b2a0dd63d54a11ecc4e3e034e7bc1ef4BLAKE2s-256=")( 69217a3079908094e11121d042354a7c1f55b6482ca1a51e51e BLAKE2b-384")(=b32811423377f52d7862286ee1a72ee540524380fda1724a6f25d7978c6fd3244a6caf04988173c5e05ef5825100 BLAKE2b-512")(=786a02f742015903c6c6fd852552d272912f4740e15847618a86e217f71f5419d25e1031afe585313896444934eb04b903a685b1448b755d56f701afe9be2ce Ein einzelnes Bit verändert jedes Bit in der Ausgabe mit 50 % Wahrscheinlichkeit, zeigt einen Lawineneffekt: BLAKE2b-512("The quick brown fox jumps over the lazy dog") =a8add4bdddfd93e4877d2746e62817b1163a1fa7bc148d95090bc73b3673f8240 Benutzer von BLAKE2 Argon2, der Gewinner des Password Hashing Wettbewerbs verwendet BLAKE2b Chef's Habitat Einsatzsystem verwendet BLAKE2b für Paket Signing FreeBSD Ports Paketmanagement-Tool verwendet BLAKE2b GNU Core Utilities implementiert BLAKE2b in seinem b2sum-Befehl IPFS erlaubt die Verwendung von BLAKE2b für Baum hashing librsync verwendet BLAKE2b Lärm (Kryptographisches Protokoll), das in WhatsApp verwendet wird, enthält BLAKE2 als Option. RLAh Dateiarchivformat Version 5 unterstützt eine optionale 256-Bit BLAKE2sp Dateiprüfung anstelle der Standard 32-Bit CRC32; es wurde im WinRAR v5+ 7zip implementiert kann die BLAKE2sp Signatur für jede Datei in der Explorer Shell über das Kontextmenü "CRC SHA" erzeugen und die Wahl "*" rmlint verwendet BLAKE2b für die doppelte Dateierkennung Durchführung Neben der Referenz-Implementierung bieten die folgenden Kryptographie-Bibliotheken Implementierungen von BLAKE2: Botan Bouncy Castle Crypto+ Libgcrypt libsodium OpenSSL wolfSSL BLAKE3 BLAKE3 ist eine kryptographische Hash-Funktion basierend auf Bao und BLAKE2, erstellt von Jack O'Connor, Jean-Philippe Aumasson, Samuel Neves und Zooko Wilcox-O'Hearn. Es wurde am 9. Januar 2020 in Real World Crypto angekündigt. BLAKE3 ist ein einziger Algorithmus mit vielen wünschenswerten Eigenschaften (Parallelismus, XOF, KDF, PRF und MAC), im Gegensatz zu BLAKE und BLAKE2, die Algorithmusfamilien mit mehreren Varianten sind. BLAKE3 hat eine binäre Baumstruktur, so dass es einen praktisch unbegrenzten Parallelismus (beide SIMD und Multithreading) bei ausreichender Eingabe unterstützt. Die offiziellen Rust- und C-Implementierungen sind als öffentliche Domain (CC0) und die Apache-Lizenz dual lizenziert. BLAKE3 ist so schnell wie möglich konzipiert. Es ist immer ein paar Mal schneller als BLAKE2. Die BLAKE3 Kompressionsfunktion basiert eng auf der von BLAKE2s, wobei der größte Unterschied darin besteht, dass die Anzahl der Runden von 10 auf 7 reduziert wird, was auf der Annahme beruht, dass die aktuelle Kryptographie zu konservativ ist. Neben der Parallelität bietet das Merkle-Baumformat auch verifizierte Streaming- (auf-die-fly-Prüfung) und inkrementelle Updates. Referenzen Externe Links Die BLAKE Website Die BLAKE2 Website Die BLAKE3 Website VHDL Implementierung von BLAKE, entwickelt von der Cryptographic Engineering Research Group (CERG) an der George Mason University