SHA-3 (Secure Hash Algorithm 3) ist das neueste Mitglied der Secure Hash Algorithm Familie von Standards, veröffentlicht von NIST am 5. August 2015. Obwohl ein Teil der gleichen Serien von Standards, SHA-3 ist intern anders als die MD5-ähnliche Struktur von SHA-1 und SHA-2.SHA-3 ist eine Untergruppe der breiteren kryptographischen primitiven Familie Keccak ( oder ), entworfen von Guido Bertoni, Joan Daemen, Michaël Peeters, und Gilles Van Assche, auf RadioGatún. Keccaks Autoren haben zusätzliche Verwendungen für die Funktion vorgeschlagen, nicht (noch) standardisiert von NIST, einschließlich einer Stream-Cipherie, ein authentifiziertes Verschlüsselungssystem, ein Baum-Haschsystem für schnelleres Hashing auf bestimmte Architekturen, und AEAD-Ciphers Keyak und Ketje. Keccak basiert auf einem neuartigen Ansatz namens Schwammbau. Der Schwammaufbau basiert auf einer breiten Zufallsfunktion oder einer zufälligen Permutation und ermöglicht die Eingabe (in Schwammterminologie absorbierender) beliebiger Datenmenge und Ausgabe (quetschen) beliebiger Datenmenge, während er als pseudorandom Funktion in Bezug auf alle vorherigen Eingaben fungiert. Dies führt zu großer Flexibilität. NIST plant derzeit nicht, SHA-2 zurückzuziehen oder aus dem überarbeiteten Secure Hash Standard zu entfernen. Der Zweck von SHA-3 ist, dass es bei aktuellen Anwendungen für SHA-2 direkt ersetzt werden kann und die Robustheit des gesamten Hash-Algorithmus-Toolkits von NIST deutlich verbessert werden kann. Die Schöpfer der Keccak-Algorithmen und der SHA-3-Funktionen schlagen vor, die schnellere Funktion KangarooTwelve mit angepassten Parametern und einen neuen Baum Hashing-Modus ohne extra Overhead für kleine Nachrichtengrößen zu verwenden. Geschichte Der Keccak-Algorithmus ist die Arbeit von Guido Bertoni, Joan Daemen (die auch die Rijndael-Schiff mit Vincent Rijmen,) Michael Peeters, und Gilles Van Assche. Es basiert auf früheren Hash-Funktion Designs PANAMA und RadioGatún. PANAMA wurde 1998 von Daemen und Craig Clapp entworfen. RadioGatún, ein Nachfolger von PANAMA, wurde von Daemen, Peeters und Van Assche entworfen und 2006 im NIST Hash Workshop präsentiert. Der Referenz-Implementierung Quellcode wurde der öffentlichen Domain über CC0 waiver gewidmet. Im Jahr 2006 begann NIST, den NIST Hash-Funktionswettbewerb zu organisieren, um einen neuen Hash-Standard zu schaffen, SHA-3.SHA-3 ist nicht dazu gedacht, SHA-2 zu ersetzen, da kein signifikanter Angriff auf SHA-2 nachgewiesen wurde. Aufgrund der erfolgreichen Angriffe auf MD5, SHA-0 und SHA-1 erkannte NIST einen Bedarf an einer alternativen, unähnlichen kryptographischen Hash, die SHA-3 wurde. Nach einer Setup-Phase wurden die Zulassungen bis Ende 2008 eingereicht. Keccak wurde als einer der 51 Kandidaten akzeptiert. Im Juli 2009 wurden 14 Algorithmen für die zweite Runde ausgewählt. Keccak ging im Dezember 2010 in die letzte Runde. Während des Wettbewerbs durften die Teilnehmer ihre Algorithmen an Themen ansprechen, die entdeckt wurden. Änderungen an Keccak sind: Die Anzahl der Runden wurde von 12 + l auf 12 + 2l erhöht, um konservativer über die Sicherheit zu sein. Die Message Padding wurde von einem komplexeren Schema auf das nachfolgend beschriebene einfache 10*1-Muster geändert. Die Rate r wurde auf die Sicherheitsgrenze erhöht, anstatt auf die nächste Macht von 2 abzurunden. Am 2. Oktober 2012 wurde Keccak als Gewinner des Wettbewerbs gewählt. 2014 veröffentlichte der NIST einen Entwurf FIPS 202 "SHA-3 Standard: Permutation-Based Hash und Extendable-Output Functions". FIPS 202 wurde am 5. August 2015 genehmigt. Am 5. August 2015 kündigte NIST an, dass SHA-3 ein Hashing-Standard geworden sei. Schwächende Kontroverse Anfang 2013 gab NIST bekannt, dass sie verschiedene Werte für die Kapazität, die Gesamtstärke vs Geschwindigkeitsparameter für den SHA-3 Standard im Vergleich zur Vorlage auswählen würden. Die Veränderungen verursachten einen Aufruhr. Der Hash-Funktionswettbewerb für Hash funktioniert zumindest so sicher wie die SHA-2 Instanzen. Es bedeutet, dass ein d-Bit-Ausgang d/2-Bit-Resistenz gegen Kollisionsangriffe und d-Bit-Resistenz gegen Preimageangriffe haben sollte, das für d-Bit-Ausgang maximal erreichbar ist. Der Sicherheitsnachweis von Keccak ermöglicht ein einstellbares Sicherheitsniveau auf Basis einer Kapazität c, was sowohl Kollisions- als auch Preimage-Angriffe mit c/2-Bit-Resistenz ermöglicht. Um die ursprünglichen Wettbewerbsregeln zu erfüllen, schlugen die Autoren von Keccak c=2d vor. Die angekündigte Änderung war, die gleiche d/2-Bit-Sicherheit für alle Angriffsformen zu akzeptieren und c=d zu standardisieren. Dies hätte Keccak verstopft, indem es jedem Iteration eine zusätzliche d-Bit-Eingabe zulässt. Die Hash-Funktionen wären jedoch nicht mehr mit dem gleichen Preimage-Widerstand wie SHA-2 eingespart gewesen; sie wären halbiert worden, so dass sie anfällig für Fortschritte in der Quanten-Computing, die es effektiv in der Hälfte wieder schneiden würde. Im September 2013 schlug Daniel J. Bernstein auf der Mailingliste NIST hash-forum vor, um die Sicherheit auf die 576-Bit-Kapazität zu stärken, die ursprünglich als Standard Keccak vorgeschlagen wurde, zusätzlich zu und nicht in den SHA-3 Spezifikationen enthalten. Dies hätte zumindest einen SHA3-224 und SHA3-256 mit dem gleichen Vorbildwiderstand wie ihre SHA-2 Vorgänger zur Verfügung gestellt, aber SHA3-384 und SHA3-512 hätten deutlich weniger Vorbildwiderstand als ihre SHA-2 Vorgänger gehabt. Ende September reagierte das Keccak-Team darauf, dass sie 128-Bit-Sicherheit vorgeschlagen hatten, indem sie c = 256 als Option bereits in ihrem SHA-3-Vorschlag eingestellt hatte. Obwohl die reduzierte Kapazität ihrer Meinung nach gerechtfertigt war, schlugen sie im Lichte der negativen Reaktion vor, die Kapazität auf c = 512 Bits für alle Fälle zu erhöhen. Dies wäre bis zum 256-Bit-Sicherheitsniveau ebenso wie jeder bisherige Standard, aber nicht der von SHA2-384 und SHA2-512 angebotene 384-/512-Bit-Vorbildwiderstand. Die Autoren erklärten, dass "die Forderung oder die Abhängigkeit von Sicherheitsstärken über 256 Bit bedeutungslos ist". Anfang Oktober 2013 kritisierte Bruce Schneier die Entscheidung von NIST auf der Grundlage seiner möglichen schädlichen Auswirkungen auf die Akzeptanz des Algorithmus und sagte: Es gibt zu viel Misstrauen in der Luft. NIST riskiert, einen Algorithmus zu publizieren, dem niemand vertrauen wird und niemand (außer jene, die gezwungen sind). Später zog er seine frühere Aussage zurück und sagte: Ich misspoke, als ich schrieb, dass NIST "interne Änderungen" zum Algorithmus gemacht. Das war schlampig von mir. Die Keccak Permutation bleibt unverändert. Was NIST vorgeschlagen hat, war die Kapazität der Hash-Funktion im Namen der Leistung zu reduzieren. Eines der netten Features von Keccak ist, dass es sehr abstimmbar ist. Paul Crowley, ein Kryptograph und Senior-Entwickler bei einem unabhängigen Software-Entwicklungsunternehmen, drückte seine Unterstützung der Entscheidung aus und sagte, dass Keccak abstimmbar sein soll und es gibt keinen Grund für verschiedene Sicherheitsstufen innerhalb eines Primitivs. Er fügte hinzu: Ja, es ist ein bisschen schade für den Wettbewerb, dass sie ein bestimmtes Sicherheitsniveau für Teilnehmer forderten, dann ging ein Standard mit einem anderen zu veröffentlichen. Aber es gibt nichts, was getan werden kann, um das jetzt zu beheben, außer den Wettbewerb wieder zu öffnen. Die Forderung, dass sie sich an ihren Fehler halten, verbessert die Dinge nicht für jeden. Es gab einige Verwirrung, dass interne Änderungen an Keccak vorgenommen wurden, die vom ursprünglichen Team geklärt wurden, und dass NISTs Vorschlag für SHA-3 eine Untergruppe der Keccak-Familie ist, für die man Testvektoren mit ihrem Referenzcode erzeugen kann, der dem Wettbewerb vorgelegt wurde, und dass dieser Vorschlag das Ergebnis einer Reihe von Diskussionen zwischen ihnen und dem NIST Hash-Team war. Als Reaktion auf die Kontroverse hat John Kelsey von NIST im November 2013 vorgeschlagen, auf den ursprünglichen c = 2d-Vorschlag für alle SHA-2 Drop-in-Ersatz-Instanzen zurückzukehren. Die Reversion wurde spätere Entwürfe und die endgültige Veröffentlichung bestätigt. Design SHA-3 verwendet die Schwammkonstruktion, in der Daten in den Schwamm aufgenommen werden, dann wird das Ergebnis ausgequetscht. In der absorbierenden Phase werden Nachrichtenblöcke in eine Teilmenge des Zustandes XORed, die dann insgesamt mit einer Permutationsfunktion f {\displaystyle f} transformiert wird. In der Quetschphase werden aus der gleichen Teilmenge des Zustandes Ausgangsblöcke ausgelesen, die sich mit der Zustandstransformationsfunktion f {\displaystyle f} abwechseln. Die Größe des Teils des geschriebenen und gelesenen Zustands wird als die Rate (denoted r {\displaystyle r}) bezeichnet, und die Größe des Teils, der durch Eingabe/Ausgabe unberührt ist, wird als Kapazität (denoted c {\displaystyle c} bezeichnet.) Die Kapazität bestimmt die Sicherheit des Systems. Die maximale Sicherheitsstufe ist die Hälfte der Kapazität. Bei einem Eingabebit-String N {\displaystyle N}, einer Padding-Funktion p a d {\displaystyle pad}, einer Permutationsfunktion f {\displaystyle f}, die auf Bitblöcken der Breite b {\displaystyle b}, einer Rate r {\displaystyle r} und einer Ausgabelänge d\displaystyle d} arbeitet, haben wir Kapazität c = b - r {\displaystyle c=b-r} und die Schwammkonstruktion Z = Schwamm [f, p a d, r ] (N, d ) {\text{sponge}[f,pad,r](N,d) Pi am Ende durch einen String von c Null-Bits ergibt eine der Länge b XOR, dass mit S die Blockpermutation f auf das Ergebnis aufgetragen wird, so dass ein neuer Zustand S initialisiert Z ist, um die leere String zu sein, während die Länge von Z kleiner als d ist: die ersten r Bits von S bis Z anhängen, wenn Z noch kleiner als d Bits lang ist, f auf S auftragen, was einen neuen Zustand S truncate Z auf ds ergibt Die Tatsache, dass der interne Zustand S neben dem, was an Z ausgegeben wird, c zusätzliche Bits von Informationen enthält, verhindert, dass die Längenverlängerungsangriffe, die SHA-2, SHA-1, MD5 und andere Hashen auf Basis der Merkle-Damgård-Konstruktion anfällig sind. In SHA-3 besteht der Zustand S aus einem 5 × 5 Array von w-bit Wörtern (mit w = 64,) b = 5 × 5 × w = 5 × 64 = 1600 Bit insgesamt. Keccak ist auch für kleinere Power-of-2 Wortgrößen w bis zu 1 Bit (Gesamtzustand von 25 Bit) definiert. Kleine Zustandsgrößen können verwendet werden, um kryptanalytische Angriffe zu testen, und Zwischenzustandsgrößen (von w = 8, 200 Bit bis w = 32, 800 Bit) können in praktischen, leichten Anwendungen verwendet werden. Für SHA-3-224, SHA-3-256, SHA-3-384 und SHA-3-512-Instanzen ist r größer als d, so dass keine zusätzlichen Blockpermutationen in der Quetschphase erforderlich sind; die führenden d-Bits des Zustandes sind die gewünschte Hash. SHAKE-128 und SHAKE-256 ermöglichen jedoch eine beliebige Ausgangslänge, die bei Anwendungen wie optimaler asymmetrischer Verschlüsselungsunterlage nützlich ist. Padding Damit die Nachricht gleichmäßig in r-Bit-Blöcke aufgeteilt werden kann, ist eine Polsterung erforderlich. SHA-3 verwendet das Muster 10*1 in seiner Padding-Funktion: ein 1 Bit, gefolgt von Null oder mehr 0 Bits (maximal r - 1) und ein letztes 1 Bit. Das Maximum von r - 1 Nullbits tritt auf, wenn der letzte Nachrichtenblock r - 1 Bit lang ist. Anschließend wird nach dem ersten 1 Bit ein weiterer Block hinzugefügt, der r - 1 Null Bit vor dem letzten 1 Bit enthält. Die beiden 1 Bits werden hinzugefügt, auch wenn die Länge der Nachricht bereits durch r divisierbar ist. In diesem Fall wird der Meldung ein weiterer Block hinzugefügt, der ein 1 Bit enthält, gefolgt von einem Block von r - 2 Nullbits und einem weiteren 1 Bit. Dies ist erforderlich, damit eine durch r endende Längennachricht in etwas, das wie Polsterung aussieht, nicht den gleichen Hash erzeugt, wie die Nachricht mit den entfernten Bits. Das erste 1 Bit wird benötigt, damit Nachrichten, die sich nur in wenigen weiteren 0 Bits am Ende unterscheiden, nicht denselben Hash erzeugen. Die Position des letzten 1 Bits gibt an, welche Rate r verwendet wurde (multi-rate padding), die für den Sicherheitsnachweis benötigt wird, um für verschiedene Hash-Varianten zu arbeiten. Ohne sie wären verschiedene Hash-Varianten der gleichen Kurznachricht bis zur Abkürzung gleich. Die Blockpermutation Die Blocktransformation f, die Keccak-f[1600] für SHA-3 ist eine Permutation, die XOR-, AND- und NOT-Betriebe verwendet und für eine einfache Implementierung in Software und Hardware konzipiert ist. Es ist für jede Power-of-Two Wortgröße, w = 2l Bits definiert. Die Hauptsache SHA-3 verwendet 64-Bit-Worte, l = 6.Der Zustand kann als 5 × 5 × 5 × w-Array von Bits betrachtet werden. Lassen Sie ein[i][j][k Bit (5i + j) × w + k der Eingabe, mit einem wenig-endian Bit Nummerierung Konvention und Zeilen-Major Indexierung. I.e i wählt die Zeile, j die Spalte, und k das Bit. Der Index arithmetic wird für die ersten beiden Abmessungen und für den dritten Modulo w modulo 5 durchgeführt. Die grundlegende Blockpermutationsfunktion besteht aus 12 + 2l Runden von fünf Schritten: θ (theta) Berechnen Sie die Parität jeder der 5w (320, wenn w = 64) 5-Bit-Säulen, und exklusiv-oder dass in zwei nahe gelegenen Spalten in einem regelmäßigen Muster. Genauer gesagt, a[i][j][k ← a[i][j][k ⊕ parity(a[0...4][j-1][k])) par⊕(a[0...4][j+1][k-1])ρ (rho) jede der 25 Wörter durch eine andere Dreieckszahl 0, 1, 3, 6, 10, 15, .Um genau zu sein, wird ein[0][0 nicht gedreht, und für alle 0 ≤ t < 24, a[i][j][k][i][j][k-(t+1)(t+2)/2], wobei iplay style = ( 3 2 1 0) t ( Genauer gesagt, a[i][j][k ← a[i][j][k ⊕ (€a[i][j+1][k & a[i][j+2][k][k]]). Dies ist die einzige nichtlineare Operation in SHA-3.ι (iota) Exklusive oder eine runde Konstante in ein Wort des Staates. Genau genommen wird in Runde n für 0 ≤ m ≤ l ein[0][0][2m-1 mit Bit m + 7n einer Grad-8 LFSR-Sequenz XORed. Dies bricht die Symmetrie, die durch die anderen Stufen erhalten bleibt. Geschwindigkeit Die Geschwindigkeit des SHA-3 Hashings von langen Nachrichten wird durch die Berechnung von f = Keccak-f[1600] und XORing S mit dem erweiterten Pi, einer Operation auf b = 1600 Bit, dominiert. Da die letzten c-Bits der erweiterten Pi jedoch ohnehin 0 sind und XOR mit 0 ein NOP ist, genügt es, XOR-Operationen nur für r-Bits durchzuführen (r = 1600 - 2 × 224 = 1152 Bits für SHA3-224, 1088 Bits für SHA3-256, 832 Bits für SHA3-384 und 576 Bits für SHA3-512). Die untere r64 ist (und umgekehrt die höhere c = b - r = 1600 - r), die weniger effizient, aber sicherer wird das Hashing, da weniger Bits der Nachricht in den Zustand (eine schnelle Operation) vor jeder Anwendung der rechnerisch teuren f.Die Autoren berichten die folgenden Geschwindigkeiten für Software-Implementierungen von Keccak-f[1600] plus XORing 1024 bits, die ungefähr SHA-3 wurde kritisiert, dass es langsam auf Instruktionsset-Architekturen (CPUs) ist, die keine speziell für die Berechnung von Keccak-Funktionen vorgesehenen Anweisungen haben – SHA2-512 ist mehr als doppelt so schnell wie SHA3-512, und SHA-1 ist mehr als dreimal so schnell auf einem Intel Skylake-Prozessor mit 3,2 GHz getaktet. Die Autoren haben auf diese Kritik reagiert, indem sie vorschlagen, SHAKE128 und SHAKE256 anstelle von SHA3-256 und SHA3-512 auf Kosten des Halbschneidens des Vorbildwiderstandes zu verwenden (aber unter Beibehaltung des Kollisionswiderstandes). Damit ist die Leistung mit SHA2-256 und SHA2-512 gleich. In Hardware-Implementierungen ist SHA-3 jedoch deutlich schneller als alle anderen Finalisten, und auch schneller als SHA-2 und SHA-1.ARMs ARMv8 und IBM s390x Architekturen (Stand 2018) enthalten spezielle Anweisungen, die Keccak-Algorithmen schneller ausführen können. InstanzenDer NIST-Standard definiert die folgenden Instanzen, für die Nachricht M und die Ausgangslänge d: Mit den folgenden Definitionen Keccak[c](N, d) = Schwamm[Keccak-f[1600,] pad10*1, r](N, d) Keccak-f[1600]=Keccak-p[1600, 24] c ist die Kapazität r die Rate = 1600 - cHAN ist die Input-2 SHAKE generiert so viele Bits aus seinem Schwamm wie gewünscht, genannt XOFs (Extendable Output Functions). Beispielsweise kann SHAKE128(M, 256) als Hash-Funktion mit einem 256 Zeichenbitstream mit 128-Bit Sicherheitsstärke verwendet werden. Als Pseudo-Zufallszahlengeneratoren können beliebig große Längen verwendet werden. Alternativ kann SHAKE256(M, 128) als Hash-Funktion mit einer 128-Bit-Länge und einem 128-Bit-Widerstand verwendet werden, aber im Gegensatz zu einer verkürzten Ausgabe von MD- und SHA-Familienfunktionen, einschließlich SHA-3, behält seine Sicherheitseigenschaften bei jeder gegebenen Größe. SHAKE-Funktionen erfordern, dass jedes Bit der Leistung so stark wie die letzte ist, während andere Hashes nur verlangen, dass die gesamte Hash stark ist, während eine Untermenge schwach sein kann. Alle Instanzen appendieren einige Bits an die Nachricht, deren rechter Rand die Domänentrennung Suffix darstellt. Hierdurch soll sichergestellt werden, dass es nicht möglich ist, Nachrichten zu erstellen, die für verschiedene Anwendungen der Keccak Hash-Funktion denselben Hash-Ausgang erzeugen. Es existieren folgende Domänentrennungssuffixe: Zusätzliche Instanzen Im Dezember 2016 veröffentlichte NIST ein neues Dokument, NIST SP.800-185, mit der Beschreibung zusätzlicher SHA-3 abgeleiteter Funktionen: • X ist die Haupteingangs-Bit-String. Es kann von jeder Länge sein, einschließlich Null.• L ist eine ganze Zahl, die die gewünschte Ausgabelänge in Bits darstellt.• N ist eine Funktion-Name-Bit-String, die von NIST verwendet wird, um Funktionen basierend auf cSHAKE zu definieren. Wenn keine andere Funktion als cSHAKE gewünscht wird, wird N auf den leeren String eingestellt.• S ist eine Anpassungsbit-String. Der Benutzer wählt diesen String aus, um eine Variante der Funktion zu definieren. Wenn keine Anpassung gewünscht wird, wird S auf den leeren String eingestellt.• K ist ein Schlüssel-Bit-String jeder Länge, einschließlich Null.• B die Blockgröße in Bytes für das parallele Hashing. Es kann jede ganze Zahl sein, so dass 0 < B < 22040. Spätere Entwicklungen KangarooTwelve Im Jahr 2016 führte das gleiche Team, das die SHA-3 Funktionen und den Keccak-Algorithmus schneller reduzierte Runden (reduziert auf 12 und 14 Runden, von den 24 in SHA-3) Alternativen, die die Verfügbarkeit von paralleler Ausführung aufgrund der Verwendung von Baum Hashing ausnutzen können:KangarooTwelve und MarsupilamiFourteen. Diese Funktionen unterscheiden sich von ParallelHash, der FIPS standardisierten Keccak-basierten parallelisierbaren Hash-Funktion hinsichtlich der Parallelität, indem sie für kleine Nachrichtengrößen schneller als ParallelHash sind. Die reduzierte Anzahl von Runden ist durch die riesige kryptanalytische Anstrengung auf Keccak gerechtfertigt, die keine praktischen Angriffe auf alles in der Nähe von zwölf Rund Keccak produziert. Diese höheren Geschwindigkeitsalgorithmen sind nicht Teil von SHA-3 (wie sie eine spätere Entwicklung sind), und sind somit nicht FIPS-konform; sondern weil sie dieselbe Keccak-Permutation verwenden, sind sie sicher, solange keine Angriffe auf SHA-3 auf 12 Runden reduziert sind. Kangaroo Zwölf ist eine leistungsfähige, reduzierte (von 24 bis 12 Runden) Version von Keccak, die behauptet, 128 Bit Sicherheit zu haben, während die Leistung so hoch wie 0,55 Zyklen pro Byte auf einer Skylake CPU. Dieser Algorithmus ist ein IETF RFC-Entwurf. MarsupilamiFourteen, eine leichte Variation auf KangarooTwelve, verwendet 14 Runden der Keccak Permutation und behauptet 256 Bit Sicherheit. Beachten Sie, dass 256-Bit-Sicherheit in der Praxis nicht nützlicher ist als 128-Bit-Sicherheit, sondern kann nach einigen Standards erforderlich sein. 128 Bits sind bereits ausreichend, um Angriffe auf die aktuelle Hardware zu besiegen, so dass mit 256-Bit-Sicherheit nicht den praktischen Wert addiert, es sei denn, der Benutzer ist besorgt über erhebliche Fortschritte in der Geschwindigkeit der klassischen Computer. Für den Widerstand gegen Quantenrechner siehe unten. KangarooTwelve und MarsupilamiFourteen sind Extendable-Output-Funktionen, ähnlich SHAKE, erzeugen daher eng verwandten Ausgang für eine gemeinsame Nachricht mit unterschiedlicher Ausgangslänge (die längere Ausgabe ist eine Erweiterung der kürzeren Ausgabe). Diese Eigenschaft wird nicht durch Hash-Funktionen wie SHA-3 oder ParallelHash (mit Ausnahme von XOF-Varianten) ausgestellt. Die Farfalle-Konstruktion Im Jahr 2016 veröffentlichte das Keccak-Team eine andere Konstruktion namens Farfalle-Konstruktion und Kravatte, eine Instanz von Farfalle mit der Keccak-p-Permutation, sowie zwei authentifizierte Verschlüsselungsalgorithmen Kravatte-SANE und Kravatte-SANSE Sakura-Baum hashing RawSHAKE ist die Grundlage für die Sakura Codierung für Baumhahing, die noch nicht standardisiert wurde. Sakura verwendet einen Suffix von 1111 für einzelne Knoten, äquivalent zu SHAKE, und andere generierte Suffixes abhängig von der Form des Baumes. Sicherheit gegen Quantenangriffe Es gibt ein allgemeines Ergebnis (Grovers Algorithmus), dass Quantenrechner einen strukturierten Preimage-Angriff in 2 d = 2 d / 2 {\displaystyle {\sqrt 2^{d}}=2^{d/2 ausführen können, während ein klassischer Brute-force-Angriff 2d benötigt. Ein strukturierter Preimage-Angriff impliziert einen zweiten Preimage-Angriff und damit einen Kollisions-Angriff. Ein Quantenrechner kann auch einen Geburtstagsangriff ausführen, also Kollisionswiderstand in 2 d 3 = 2 d / 3 {\displaystyle \sqrt[{3}}}}=2^{d/3 (obwohl das bestritten ist). Da die maximale Festigkeit c / 2 {\displaystyle c/2} sein kann, ergibt dies die folgenden oberen Grenzen der Quantensicherheit von SHA-3: Es hat sich gezeigt, dass die Merkle-Damgård-Konstruktion, wie sie von SHA-2 verwendet wird, kollabiert und folglich quantenkollisionsbeständig ist, aber für die Schwamm-Konstruktion, die von SHA-3 verwendet wird, geben die Autoren Beweise nur für den Fall, dass die Blockfunktion f nicht effizient invertierbar ist; Keccak-f[1600] ist jedoch effizient invertierbar, und so dass ihr Nachweis nicht gilt. Beispiele für SHA-3 Varianten Die folgenden Hashwerte stammen von NIST.gov: SHA3-224("")6b4e03423667dbb73b6e15454f0eb1abd4597f9a1b078e3f5b5a6bc7 SHA3-256(") a7ffc6f8bf1ed76651c14756a0682d662f580ff4 C 347 vom 20.12.2013, S. 1). SICHERHEIT Ein einzelnes Bit verändert jedes Bit in der Ausgabe mit 50 % Wahrscheinlichkeit, zeigt einen Lawineneffekt: SHAKE128("Der schnelle braune Fuchs springt über den faulen Hund," 256) f4202e3c5852f9182a0430fd8144f0a74b95e7417ecae17dbzyb0f8cfeed0e3e66eSHAKE1 Vergleich der SHA-Funktionen In der nachfolgenden Tabelle bedeutet der interne Zustand die Anzahl der Bits, die zum nächsten Block übernommen werden. Optimierte Implementierung mit AVX-512VL (d.h. von OpenSSL, mit Skylake-X CPUs) von SHA3-256 erreichen für große Nachrichten etwa 6,4 Zyklen pro Byte und bei Verwendung von AVX2 auf Skylake CPUs etwa 7,8 Zyklen pro Byte. Die Leistung auf anderen x86-, Power- und ARM-CPUs hängt von den verwendeten Anweisungen ab und das genaue CPU-Modell variiert von etwa 8 bis 15 Zyklen pro Byte , mit einigen älteren x86 CPUs bis zu 25–40 Zyklen pro Byte. Im Folgenden finden Sie eine Liste von Kryptographie-Bibliotheken, die SHA-3 unterstützen: Rust's sha3 Botan Bouncy Castle Crypto+ Libgcrypt Nettle OpenSSL wolfSSL MIRACL Cryptographic SDK Golang's x/crypto/sha3 libkeccak Hardwarebeschleunigung Apple A13 ARMv8 Sechskern-SoC-CPU-Kerne haben Unterstützung für die Beschleunigung von SHA-3 (und SHA-512) mit spezialisierten Anweisungen (EOR3, RAX1, XAR, BCAX) von ARMv8.2-SHA-Crypto-Erweiterungsset. Einige Softwarebibliotheken nutzen Vektorisierungsanlagen von CPUs, um die Nutzung von SHA-3 zu beschleunigen. Beispielsweise kann Crypto+ SSE2 auf x86 zur Beschleunigung von SHA3 verwenden und OpenSSL kann auch auf vielen x86 Systemen MMX, AVX-512 oder AVX-512VL verwenden. Auch POWER8 CPUs implementieren 2x64-bit Vektor rot, definiert in PowerISA 2.07, die SHA-3 Implementierungen irgendwie beschleunigen können. Die meisten Implementierungen für ARM verwenden Neon Vektor-Anweisungen nicht, da Skalar-Code schneller ist. ARM-Implementierungen können jedoch mit SVE- und SVE2-Vektoranweisungen beschleunigt werden; diese sind beispielsweise in der Fujitsu A64FX CPU verfügbar. Verwendung in Protokollen Ethereum § Ether See auch Ethash – weitere Keccak-basierte Hash Referenzen Externe Links Die Keccak Website