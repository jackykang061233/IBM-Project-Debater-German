SHA-2 (Secure Hash Algorithm 2) ist eine Reihe kryptografischer Hash-Funktionen, die von der National Security Agency (NSA) der Vereinigten Staaten entworfen und im Jahr 2001 veröffentlicht wurden. Sie werden mit der Merkle-Damgård-Konstruktion gebaut, von einer Einwegkompressionsfunktion selbst, die mit der Davies-Meyer-Struktur aus einer spezialisierten Block-Chiffre erstellt wird. SHA-2 enthält signifikante Änderungen von seinem Vorgänger SHA-1. Die SHA-2-Familie besteht aus sechs Hash-Funktionen mit Verdauungen (Hash-Werte), die 224, 256, 384 oder 512 Bit sind: SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, SHA-512/256.SHA-256 und SHA-512 sind neue Hash-Funktionen, die mit acht 32-Bit und 64-Worten berechnet werden. Sie verwenden unterschiedliche Verschiebungs- und Additivkonstanten, ihre Strukturen sind aber ansonsten praktisch identisch, nur in der Anzahl der Runden unterschiedlich. SHA-224 und SHA-384 sind verkürzte Versionen von SHA-256 bzw. SHA-512, berechnet mit unterschiedlichen Anfangswerten. SHA-512/224 und SHA-512/256 sind ebenfalls verkürzte Versionen von SHA-512, die Ausgangswerte werden jedoch nach dem in Bundesinformationsnormen (FIPS)PUB 180-4.SHA-2 beschriebenen Verfahren generiert. Die SHA-2 Algorithmenfamilie wird in US-Patent 6829355 patentiert. Die Vereinigten Staaten haben das Patent unter einer lizenzfreien Lizenz veröffentlicht. Derzeit brechen die besten öffentlichen Angriffe den Vorbildwiderstand für 52 von 64 Runden von SHA-256 oder 57 von 80 Runden von SHA-512 und den Kollisionswiderstand für 46 von 64 Runden von SHA-256. Hash-Standard Mit der Veröffentlichung von FIPS PUB 180-2 hat NIST in der Familie SHA drei zusätzliche Hashfunktionen hinzugefügt. Die Algorithmen sind gemeinsam als SHA-2 bekannt, benannt nach ihren Verdauungslängen (in Bits): SHA-256, SHA-384 und SHA-512. Die Algorithmen wurden erstmals 2001 im Entwurf FIPS PUB 180-2 veröffentlicht, zu dem die öffentliche Überprüfung und Kommentare angenommen wurden. Im August 2002 wurde FIPS PUB 180-2 zum neuen Secure Hash Standard und ersetzte FIPS PUB 180-1, das im April 1995 veröffentlicht wurde. Der aktualisierte Standard beinhaltete den ursprünglichen SHA-1 Algorithmus, mit aktualisierter technischer Notation im Einklang mit der Beschreibung der inneren Arbeiten der SHA-2 Familie. Im Februar 2004 wurde eine Änderungsbekanntmachung für die FIPS PUB 180-2 veröffentlicht, in der eine zusätzliche Variante SHA-224 definiert ist, die auf die Schlüssellänge von Zweischlüssel-Triple DES abgestimmt ist. Im Oktober 2008 wurde der Standard in der FIPS PUB 180-3, einschließlich SHA-224 aus der Änderungsbekanntmachung aktualisiert, aber ansonsten keine grundlegenden Änderungen an der Norm. Die primäre Motivation für die Aktualisierung des Standards war die Verlagerung von Sicherheitsinformationen über die Hash-Algorithmen und Empfehlungen für ihre Verwendung in Sonderveröffentlichungen 800-107 und 800-57. Detaillierte Testdaten und beispielsweise Nachrichtenverdauungen wurden ebenfalls aus dem Standard entfernt und als separate Dokumente bereitgestellt. Im Januar 2011 veröffentlichte NIST SP800-131A, die bis Ende 2013 einen Übergang von dem damals gültigen Minimum von 80-Bit-Sicherheit (vorgesehen durch SHA-1) für den Bundeseinsatz ermöglichte, auf 112-Bit-Sicherheit (vorgesehen durch SHA-2) sowohl die Mindestanforderung (ab 2014) als auch die empfohlene Sicherheitsstufe (ab dem Veröffentlichungsdatum 2011). Im März 2012 wurde der Standard in FIPS PUB 180-4 aktualisiert, die Hash-Funktionen SHA-512/224 und SHA-512/256 hinzugefügt und ein Verfahren zur Generierung von Anfangswerten für verkürzte Versionen von SHA-512 beschrieben. Zusätzlich wurde eine Einschränkung der Polsterung der Eingabedaten vor der Hash-Berechnung entfernt, wodurch Hash-Daten gleichzeitig mit der Content-Generierung, wie einem Echtzeit-Video oder Audio-Feed, berechnet werden können. Die Speicherung des endgültigen Datenblocks muss noch vor der Hashausgabe erfolgen. Im Juli 2012 überarbeitete NIST SP800-57, die Anleitung für kryptographische Schlüsselverwaltung bietet. Die Veröffentlichung hat die Erstellung digitaler Signaturen mit einer Hash-Sicherheit von weniger als 112 Bit nach 2013 deaktiviert. In der vorherigen Revision von 2007 wurde der Cutoff zum Ende 2010 festgelegt. Im August 2012 hat NIST SP800-107 in gleicher Weise überarbeitet. Der NIST Hash-Funktionswettbewerb hat 2012 eine neue Hash-Funktion SHA-3 ausgewählt. Der SHA-3 Algorithmus wird nicht von SHA-2 abgeleitet. Anwendungen Die SHA-2 Hash-Funktion wird in einigen weit verbreiteten Sicherheitsanwendungen und Protokollen implementiert, einschließlich TLS und SSL, PGP, SSH, S/MIME und IPsec.SHA-256 partakes im Prozess der Authentisierung von Debian-Softwarepaketen und in der DKIM-Nachricht unterschreiben Standard; SHA-512 ist Teil eines Systems zur Authentisierung von Archivvideo des Internationalen Strafgerichts des Rwandischen Völkermords. SHA-256 und SHA-512 werden zur Verwendung in DNSSEC vorgeschlagen. Unix- und Linux-Anbieter verwenden 256- und 512-bit SHA-2 für sicheres Passwort-Hasching. Mehrere Kryptowährungen wie Bitcoin verwenden SHA-256, um Transaktionen zu überprüfen und den Nachweis der Arbeit oder den Nachweis des Einsatzes zu berechnen. Der Anstieg der ASIC SHA-2 Beschleunigerchips hat zur Verwendung von Scrypt-basierten Beleg-of-Work-Systemen geführt. SHA-1 und SHA-2 sind die gesetzlich vorgeschriebenen Secure Hash Algorithmen, die in bestimmten US-Regierungsanwendungen, einschließlich der Verwendung in anderen kryptographischen Algorithmen und Protokollen, zum Schutz sensibler unklassifizierter Informationen benötigt werden. FIPS PUB 180-1 ermutigte auch die Übernahme und Nutzung von SHA-1 durch private und kommerzielle Organisationen. SHA-1 wird für die meisten Regierungszwecke in den Ruhestand genommen; das US National Institute of Standards and Technology sagt: "Führende Agenturen sollten aufhören, SHA-1 für...Anwendungen zu verwenden, die Kollisionsbeständigkeit erfordern, sobald es praktisch ist, und muss die SHA-2 Familie der Hash-Funktionen für diese Anwendungen nach 2010 verwenden" (Ephasis im Original). NISTs Richtlinie, dass die US-Regierungsbehörden die Verwendung von SHA-1 nach 2010 stoppen müssen, wurde gehofft, die Migration von SHA-1 zu beschleunigen. Die SHA-2-Funktionen wurden nicht schnell angenommen, trotz besserer Sicherheit als SHA-1.Reasons könnte enthalten Mangel an Unterstützung für SHA-2 auf Systemen unter Windows XP SP2 oder älter und ein Mangel an wahrgenommener Dringlichkeit, da SHA-1 Kollisionen noch nicht gefunden wurden. Das Google Chrome-Team kündigte einen Plan an, um ihren Webbrowser schrittweise aufhören zu ehren SHA-1-abhängige TLS-Zertifikate über einen Zeitraum von Ende 2014 und Anfang 2015. Ebenso kündigte Microsoft an, dass Internet Explorer und Edge ab Februar 2017 die Auszeichnung öffentlicher SHA-1-signed TLS-Zertifikate stoppen würden. Mozilla deaktivierte SHA-1 Anfang Januar 2016, musste es jedoch vorübergehend über ein Firefox-Update nach Problemen mit webbasierten Benutzeroberflächen einiger Routermodelle und Sicherheitsgeräte wieder aktivieren. Kryptanalyse und Validierung Für eine Hash-Funktion, für die L die Anzahl der Bits im Nachrichtenverdau ist, kann das Auffinden einer Nachricht, die einem gegebenen Nachrichtenverdau entspricht, immer mit einer Brute Force-Suche in 2L-Auswertungen erfolgen. Dies wird als Preimage-Angriff bezeichnet und kann je nach L und der jeweiligen Rechenumgebung praktisch sein. Das zweite Kriterium, zwei verschiedene Nachrichten zu finden, die den gleichen Nachrichtenverdau erzeugen, wie eine Kollision, erfordert im Durchschnitt nur 2L/2 Bewertungen mit einem Geburtstagsangriff. Einige der Anwendungen, die kryptographische Hashes verwenden, wie z.B. Passwortspeicherung, sind nur minimal von einem Kollisionsangriff betroffen. Die Konstruktion eines Passworts, das für ein bestimmtes Konto funktioniert, erfordert einen Preimage-Angriff sowie den Zugriff auf den Hash des ursprünglichen Passworts (typisch in der Schattendatei), der trivial sein kann oder nicht sein kann. Die Umkehr der Passwortverschlüsselung (z.B. um ein Passwort zu erhalten, um gegen ein Benutzerkonto anderswo zu versuchen) wird durch die Angriffe nicht ermöglicht. (Aber selbst ein sicheres Passwort hash kann keine brutalen Angriffe auf schwache Passwörter verhindern.) Bei der Unterzeichnung des Dokuments könnte ein Angreifer nicht einfach eine Unterschrift aus einem vorhandenen Dokument vortäuschen – der Angreifer müsste ein paar Dokumente produzieren, eine Unschuld und eine Beschädigung, und den privaten Schlüsselhalter erhalten, um das unschuldige Dokument zu unterzeichnen. Es gibt praktische Umstände, unter denen dies möglich ist; bis Ende 2008 war es möglich, geschmiedete SSL-Zertifikate mit einer MD5-Kollision zu erstellen, die von weit verbreiteten Webbrowsern akzeptiert werden würde. Das erhöhte Interesse an der kryptographischen Hash-Analyse während des SHA-3-Wettbewerbs brachte mehrere neue Angriffe auf die Familie SHA-2 hervor, deren Besten in der nachstehenden Tabelle aufgeführt sind. Nur die Kollisionsangriffe sind von praktischer Komplexität; keiner der Angriffe erstreckt sich auf die volle Runde Hash-Funktion. Auf der FSE 2012 gaben Forscher von Sony eine Präsentation, die darauf hindeutete, dass Pseudokollisionsangriffe auf 52 Runden auf SHA-256 und 57 Runden auf SHA-512 durch den Aufbau des biclique Pseudo-Preimage-Angriffs erweitert werden konnten. Offizielle Validierung Implementierungen aller FIPS-genehmigten Sicherheitsfunktionen können durch das CMVP-Programm offiziell validiert werden, das gemeinsam vom National Institute of Standards and Technology (NIST) und dem Communications Security Establishment (CSE) durchgeführt wird. Zur informellen Überprüfung wird auf der NIST-Website ein Paket zur Erzeugung einer hohen Anzahl von Testvektoren zum Download zur Verfügung gestellt; die daraus resultierende Überprüfung ersetzt jedoch nicht die formale CMVP-Validierung, die für bestimmte Anwendungen gesetzlich vorgeschrieben ist. Ab Dezember 2013 gibt es über 1300 validierte Implementierungen von SHA-256 und über 900 von SHA-512, von denen nur 5 in der Lage sind, Nachrichten mit einer Länge in Bits nicht mehr ein Vielfaches von acht zu behandeln, während beide Varianten unterstützt werden. 2. Die Mitgliedstaaten stellen fest, dass die in Artikel 2 Absatz 2 der Verordnung (EU) Nr. 575/2013 festgelegten Bedingungen erfüllt sind. SHA512/224(") 0x 6ed0dd02806fa89e25de060c19d3ac86cabb87d6a0ddddd05c333b84f4 SHA512/256(") 0x c672b8d1ef56ed28ab87c3622c5114069bd3ad7b8f97378d0c01ecef0967a Selbst eine kleine Änderung der Nachricht wird (mit überwältigender Wahrscheinlichkeit) zu einem meist anderen Hash führen, aufgrund der Lawinenwirkung. Zum Beispiel ändert sich das Hinzufügen einer Periode zum Ende des folgenden Satzes fast die Hälfte (111 von 224) der Bits in der Hash: SHA224("Der schnelle braune Fuchs springt über den faulen Hund")0x 730e109bd7a8a32b1cb9d9a09a2325d2430587dbc0c38bad911525 SHA224("Der schnelle braune Fuchs springt über den faulen Hund.")0x 619cba8e8e05826e9b8c519c0a5c68f4fb653e8a3d8aaa04bb2c8cd4c Pseudocode Pseudocode für den SHA-256 Algorithmus folgt. Beachten Sie die große Zunahme der Mischung zwischen Bits der w[16.63] Wörter im Vergleich zu SHA-1. Anmerkung 1: Alle Variablen sind 32 Bit unsigniert ganze Zahlen und Addition wird berechnet modulo 232 Anmerkung 2: Für jede Runde gibt es eine runde Konstante k[i] und ein Eintrag in der Nachrichten-Zeitplan-Array w[i,] 0 ≤ i ≤ 63 Anmerkung 3: Die Kompressionsfunktion verwendet 8 Arbeitsvariablen, a through h Note 4: Big-endian Convention wird verwendet, wenn die Konstanten in diesem Pseudocode exprimiert werden. 0x6b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x6b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x2b, 0x8b, 0x2b, 0x8b, 0x2b, 0x, Die Vorverarbeitung (Padding:) beginnt mit der Originalnachricht der Länge L Bits, die einen 1-Bit-Anhang K 0-Bits anhängen, wobei K die Mindestzahl > = 0 ist, so dass L + 1 + K + 64 ein Vielfaches von 512-Anhang L als 64-Bit-big-Endian-Inte ist, so dass die gesamte nachverarbeitete Länge ein Vielfaches von 512-Bits ist, so dass die Bits in der> L 1 00' sind. = k*512 Gesamtbits Bearbeiten Sie die Nachricht in aufeinanderfolgenden 512-Bit-Cracks: brechen Sie Nachricht in 512-Bit-Chalunks für jeden chunk erstellen Sie ein 64-Eintrags-Nachrichtplanfeld w[0..63] von 32-Bit-Worten (Die Anfangswerte in w[0.63] sind nicht wichtig, so viele Implementierungen hier Null) kopieren Sie chunk in die ersten 16 Wörter w[0.15] des Nachrichtenplanarrays Erweitern Sie die ersten 16 Wörter in die restlichen 48 Wörter w[16.63] des Nachrichtenplanarrays: für i von 16 bis 63 s0 =(:w[i-15] rechtsrotate 7)xor (w[i-15] rechtsrotate 18) xor(w[i-15] rechtsverschiebung 3) s1 := (w[i- 2] rechtsrotate 17)xor (w[i- 2] rechtsrotate 19)xor (w[i- 2] rechtsverschiebung 10) w[i] := w[i-16] + s0 + w[i-7] + s1 Initialisieren Arbeitsgrößen auf aktuellen Hash-Wert: a := h0 b =:h1 c := h2 d : h5 g =:h6 h := h7 Kompressionsfunktion Hauptschleife: für i von 0 bis 63 S1 =(:e rightrotate 6)xor (e rightrotate 11)xor (e rightrotate 25) ch =(:e und f) xor (not e) und g) temp1 := h + S1 + ch + k[i] + w[i] S0 + maj h := g := f =:e e =:d + temp1 d =:c c =:b b b = a := temp1 + temp2 Fügen Sie das komprimierte Stück zum aktuellen Hash-Wert hinzu: h0 =:h0 + a h1 := h1 + b h2 =:h2 + c h3 =:h3 + d h4 =:h4 + e h5 =:h5 + f h6 := h6 + g h7 := h7 + h Produce the final hash value (big-endian:) dig := hash := h0 append h1 append h2 append h3 append h4 append h5 append h6 append h7 Die Berechnung der ch- und maj-Werte kann so optimiert werden, wie für SHA-1 beschrieben.SHA-224 ist identisch mit SHA-256, mit der Ausnahme, dass die Anfangs-Lash-Werte h0 bis h7 unterschiedlich sind und die Ausgabe durch Ausgeben von h7.SHA-224 Anfangs-Lash-Werten (in großem Endian:) (Die zweiten 32 Bits der fraktionierten Teile der quadratischen Wurzeln der 9. bis 16. Primes 23..53)h[0.7] := 0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98 chfa7, 0xbefa4 SHA-512 initial hash value (in big-endian:) h[0.7]:= 0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53af1d36f1, 0x510e527fade682d1, 0x9b05 0x6b5c0c8c0c8c0c8c0c8c0c8c0c8c0c8c0c8c0c8c0c8c0c8c0c8c0c8c0c8c0c8c0c8c0c8c0c8c0c8c7c0c7c0c0c0c 7) s1 := (w[i-2] rechtsrotate 19)xor (w[i-2] rechtsrotate 61) xor (w[i-2] rechtsverschiebung 6) SHA-384 ist mit SHA-512 identisch, mit der Ausnahme, dass die Anfangs-Hass-Werte h0 bis h7 unterschiedlich sind (von der 9. bis 16. Grundierung aufgenommen) und die Ausgabe durch Ausgeben von h6 und h7.SHA-384 Anfangs-Hass-Werten (in Big-Endian:) h[0.7] Die SHA-512/t IV-Generationsfunktion wertet einen modifizierten SHA-512 auf dem ASCII-String SHA-512/t aus, der mit der dezimalen Darstellung von t substituiert ist. Der modifizierte SHA-512 ist mit Ausnahme der Ausgangswerte h0 bis h7 gleich SHA-512 mit der Hexadezimalkonstante 0xa5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5. Stichprobe C-Implementierung für die SHA-2 Familie der Hash-Funktionen finden Sie in RFC 6234. Vergleich der SHA-Funktionen In der nachfolgenden Tabelle bedeutet der interne Zustand die "interne Hashsumme" nach jeder Komprimierung eines Datenblocks. In der bitweise Arbeitssäule steht Rot für Drehen ohne Trage, und Shr steht für richtige logische Verschiebung. Alle diese Algorithmen verwenden in gewisser Weise modulare Addition außer SHA-3. Detailliertere Leistungsmessungen auf modernen Prozessorarchitekturen sind in der folgenden Tabelle angegeben. Die mit x86 bezeichneten Leistungszahlen wurden mit 32-Bit-Code auf 64-Bit-Prozessoren ausgeführt, während die x86-64-Nummern nativen 64-Bit-Code sind. Während SHA-256 für 32-Bit-Berechnungen ausgelegt ist, profitiert es von dem für 64-Bit-Prozessoren optimierten Code auf der x86-Architektur. 32-Bit-Implementierungen von SHA-512 sind deutlich langsamer als ihre 64-Bit-Gegenstände. Ähnlich werden Varianten beider Algorithmen mit unterschiedlichen Ausgangsgrößen ausgeführt, da die Nachrichtenausdehnungs- und Kompressionsfunktionen identisch sind und nur die Anfangs-Haschwerte und Ausgangsgrößen unterschiedlich sind.Die besten Implementierungen von MD5 und SHA-1 führen auf modernen Prozessoren zwischen 4,5 und 6 Zyklen pro Byte. Die Prüfung wurde von der University of Illinois in Chicago auf ihrem hydra8-System durchgeführt, das einen Intel Xeon E3-1275 V2 mit einer Taktgeschwindigkeit von 3,5 GHz und auf ihrem hydra9-System läuft eine AMD A10-5800K APU mit einer Taktgeschwindigkeit von 3,8 GHz. Die genannten Zyklen pro Byte-Geschwindigkeiten oben sind die mediane Leistung eines Algorithmus, der eine 4,096 Byte-Nachricht mit der SUPERCOP cryptographic Benchmarking Software verdauen. Die MiB/s-Performance wird von der CPU-Uhrgeschwindigkeit auf einem einzigen Kern extrapoliert; die reale Leistung wird durch eine Vielzahl von Faktoren variieren. Im Folgenden finden Sie eine Liste von Kryptographie-Bibliotheken, die SHA-2 unterstützen: Botan Bouncy Castle Cryptlib Crypto+ Libgcrypt Mbed TLS libnadium Nettle LibreSSL OpenSSL GnuTLS wolfSSLHardware Beschleunigung wird durch die folgenden Prozessorerweiterungen bereitgestellt: Intel SHA Erweiterungen: Erhältlich auf einigen Intel und AMD x86 Prozessoren. VIAPadLock ARMv8 Kryptographie Erweiterungen Siehe auch Vergleich der kryptographischen Hash-Funktionen Vergleich der Kryptographiebibliotheken Hash-Funktion Sicherheitszusammenfassung Hashcash HMAC International Association for Cryptologic Research (IACR)sha1sum (sha224sum, sha256sum, sha384sum und sha512sum) Befehle Trusted timestamping Referenzen Weitere Informationen Externe Links Beschreibungen von SHA-256, SHA-384 und SHA-512 von NIST SHA-2 Checker – SHAChecker, um die SSL-Kompatibilität für SHA-2 Spezifikationen für einen Secure Hash Standard (SHS) zu überprüfen – Entwurf für vorgeschlagene SHS (SHA-0)Secure Hash Standard (SHS) Testvektoren für SHA-256/384/512 aus dem NESSIE-Projekt Testvektoren für SHA-1, SHA-2 vom NIST-Standort NIST Cryptographic Hash Project – SHA-3 Wettbewerb RFC 3874: "A 224-bit One-way Hash Function: SHA-224" RFC 6234: "US Secure Hash Algorithms (SHA und SHA-basierte HMAC und HKDF)"; enthält Beispiel C Implementierung