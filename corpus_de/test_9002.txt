Bewegungsplanung, auch Wegplanung (auch bekannt als Navigationsproblem oder das Problem des Klavierbewegungers) ist ein rechnerisches Problem, um eine Sequenz gültiger Konfigurationen zu finden, die das Objekt von der Quelle zum Zielort bewegt. Der Begriff wird in Computergeometrie, Computeranimation, Robotik und Computerspielen verwendet. Betrachten Sie beispielsweise, einen mobilen Roboter innerhalb eines Gebäudes zu einem entfernten Wegpunkt zu navigieren. Es sollte diese Aufgabe ausführen, während Wände zu vermeiden und nicht unter Treppe fallen. Ein Bewegungsplanungsalgorithmus würde eine Beschreibung dieser Aufgaben als Eingabe nehmen und die an die Räder des Roboters gesendeten Geschwindigkeits- und Drehbefehle erzeugen. Bewegungsplanungsalgorithmen können Roboter mit einer größeren Anzahl von Gelenken (z.B. Industriemanipulatoren) komplexere Aufgaben (z.B. Manipulation von Objekten) unterschiedliche Zwänge (z.B. ein Auto, das nur nach vorne fahren kann) und Unsicherheit (z.B. unvollkommene Modelle der Umgebung oder Roboter) ansprechen. Motion Planning hat mehrere Robotik-Anwendungen, wie Autonomie, Automatisierung und Roboterdesign in CAD-Software, sowie Anwendungen in anderen Bereichen, wie die Animation digitaler Zeichen, Videospiel, Architekturdesign, Roboterchirurgie und die Untersuchung biologischer Moleküle. Konzepte Ein grundlegendes Bewegungsplanungsproblem besteht darin, einen kontinuierlichen Pfad zu berechnen, der eine Startkonfiguration S und eine Zielkonfiguration G verbindet, während eine Kollision mit bekannten Hindernissen vermieden wird. Die Roboter- und Hindernisgeometrie wird in einem 2D- oder 3D-Arbeitsraum beschrieben, während die Bewegung als Weg in (möglicherweise höherdimensionalem) Konfigurationsraum dargestellt ist. Konfigurationsraum Eine Konfiguration beschreibt die Pose des Roboters und der Konfigurationsraum C ist das Set aller möglichen Konfigurationen. Zum Beispiel: Wenn der Roboter ein einziger Punkt (Null-Größe) ist, der in einer 2-dimensionalen Ebene (der Arbeitsraum,) C eine Ebene und eine Konfiguration mit zwei Parametern (x, y) dargestellt werden kann. Ist der Roboter eine 2D-Form, die sich übersetzen und drehen kann, ist der Arbeitsraum noch 2-dimensional. C ist jedoch die spezielle Euclideangruppe SE(2) = R2 × {\displaystyle \times } SO(2) (wo SO(2) die spezielle orthogonale Gruppe von 2D-Drehungen ist), und eine Konfiguration kann mit 3 Parametern (x, y, θ) dargestellt werden. Wenn der Roboter eine solide 3D-Form ist, die übersetzen und drehen kann, ist der Arbeitsraum 3-dimensional, aber C ist die spezielle Euclidean Gruppe SE(3)=R3 × {\displaystyle \times } SO(3,) und eine Konfiguration erfordert 6 Parameter: (x, y, z) für die Übersetzung und Euler Winkel (α, β, γ). Ist der Roboter ein fester Basis-Manipulator mit N revolute Gelenke (und keine geschlossen-Plups,) C N-dimensional. Freier Raum Der Satz von Konfigurationen, die Kollisionen mit Hindernissen vermeiden, wird als freier Raum Cfree bezeichnet. Die Ergänzung von Cfree in C wird als Hindernis oder verbotene Region bezeichnet. Oft ist es verbietend schwierig, die Form von Cfree explizit zu berechnen. Allerdings ist die Prüfung, ob eine bestimmte Konfiguration in Cfree ist effizient. Zunächst bestimmen Vorwärtskinematik die Position der Robotergeometrie und Kollisionserkennungstests, wenn die Geometrie des Roboters mit der Geometrie der Umgebung kollidiert. Zielraum Zielraum ist ein Subraum von Freiraum, der angibt, wo wir wollen, dass sich der Roboter bewegt. In der globalen Bewegungsplanung ist der Zielraum durch die Sensoren des Roboters beobachtbar. Bei der lokalen Bewegungsplanung kann der Roboter den Zielraum in einigen Staaten jedoch nicht beobachten. Um dieses Problem zu lösen, geht der Roboter durch mehrere virtuelle Zielräume, die sich jeweils innerhalb des beobachtbaren Bereichs (um den Roboter) befinden. Ein virtueller Zielraum wird als Subgoal bezeichnet. Hindernisraum Hindernisraum ist ein Raum, zu dem sich der Roboter nicht bewegen kann. Der Freiraum ist nicht dem Freiraum gegenüber. Algorithmen Low-dimensionale Probleme können mit gitterbasierten Algorithmen gelöst werden, die ein Netz auf der Oberseite des Konfigurationsraums überlagern, oder geometrische Algorithmen, die die Form und Konnektivität von Cfree berechnen. Eine genaue Bewegungsplanung für hochdimensionale Systeme unter komplexen Zwängen ist rechnerisch unbrauchbar. Potentialfeldalgorithmen sind effizient, aber fallen prey auf lokale Minima (eine Ausnahme ist die harmonischen Potentialfelder.) Sampling-basierte Algorithmen vermeiden das Problem der lokalen Minima, und lösen viele Probleme ziemlich schnell. Sie können nicht feststellen, dass kein Pfad existiert, aber sie haben eine Wahrscheinlichkeit des Ausfalls, der auf Null abnimmt, wenn mehr Zeit ausgegeben wird. Sampling-basierte Algorithmen gelten derzeit als modernste für die Bewegungsplanung in hochdimensionalen Räumen und wurden auf Probleme angewendet, die Dutzende oder sogar Hunderte von Dimensionen haben (robotische Manipulatoren, biologische Moleküle, animierte digitale Zeichen und legierte Roboter). Es gibt den Bewegungsplanungsparallelalgorithmus (A1-A2) zur Objektmanipulation (zum Einfangen des fliegenden Objekts). Grid-basierte Suche Grid-basierte Ansätze überlagern ein Raster auf Konfigurationsraum und nehmen an, dass jede Konfiguration mit einem Rasterpunkt identifiziert wird. An jedem Rasterpunkt lässt sich der Roboter an benachbarte Rasterpunkte bewegen, solange die Linie zwischen ihnen vollständig in Cfree enthalten ist (dies wird mit Kollisionserkennung getestet). Dadurch wird der Satz von Aktionen aufgelöst und Suchalgorithmen (wie A*) werden verwendet, um einen Pfad von Anfang bis Ziel zu finden. Diese Ansätze erfordern eine Gitterauflösung. Die Suche ist schneller mit gröberen Gittern, aber der Algorithmus wird keine Pfade durch schmale Abschnitte von Cfree finden. Weiterhin wächst die Anzahl der Punkte am Raster exponentiell in der Konfigurationsraumdimension, was sie für hochdimensionale Probleme unangebracht macht. Traditionelle gitterbasierte Ansätze erzeugen Wege, deren Überschriftenänderungen auf Vielfache eines bestimmten Grundwinkels beschränkt sind, was oft zu suboptimalen Pfaden führt. Jeder Winkelweg-Planungsansätze finden kürzere Wege, indem er Informationen entlang der Rasterkanten (um schnell zu suchen) ausbreitet, ohne die Pfade zu Rasterkanten (um kurze Pfade zu finden). Grid-basierte Ansätze müssen oft wiederholt gesucht werden, beispielsweise wenn sich das Wissen des Roboters um den Konfigurationsraum ändert oder sich der Konfigurationsraum selbst während des folgenden Pfades ändert. Inkrementelle heuristische Suchalgorithmen replanen schnell durch Erfahrung mit den vorherigen ähnlichen Pfad-Planing-Problemen, um ihre Suche nach dem aktuellen zu beschleunigen. Intervalbasierte Suche Diese Ansätze sind ähnlich zu gitterbasierten Suchansätzen, mit der Ausnahme, dass sie eine Paving-Bedeckung vollständig den Konfigurationsraum anstelle eines Rasters erzeugen. Das Pflaster wird in zwei Teilspeicher zerlegt X-,X+ mit Boxen so hergestellt, dass X- ∈ Cfree ⊕ X+. Charakterisierung Cfree löst ein Set Inversion Problem. Die Intervalanalyse könnte somit genutzt werden, wenn Cfree nicht durch lineare Ungleichheiten beschrieben werden kann, um eine garantierte Einfassung zu haben. Der Roboter lässt sich somit frei in X- bewegen und kann nicht außerhalb von X+ gehen. Zu beiden Subpavings wird ein Nachbardiagramm erstellt und Pfade können mit Algorithmen wie Dijkstra oder A* gefunden werden. Ist in X- ein Pfad durchführbar, ist es auch in Cfree denkbar. Wenn in X+ kein Pfad von einer ersten Konfiguration zum Ziel besteht, haben wir die Garantie, dass in Cfree kein möglicher Pfad existiert. Was den gitterbasierten Ansatz betrifft, ist der Intervallansatz für hochdimensionale Probleme unangemessen, da die Anzahl der zu erzeugenden Boxen exponentiell bezüglich der Dimension des Konfigurationsraums wächst. Eine Darstellung ergibt sich aus den drei Figuren rechts, wo sich ein Haken mit zwei Freiheitsgraden von links nach rechts bewegen muss, wodurch zwei horizontale kleine Segmente vermieden werden. Durch die Zersetzung mit Subpavings mittels Intervallanalyse ist es auch möglich, die Topologie von Cfree zu charakterisieren, z.B. die Anzahl der angeschlossenen Komponenten zu zählen. Geometrische Algorithmen Spitzenroboter unter polygonalen Hindernisse Sichtbarkeitsdiagramm ZellzerlegungÜbertragen von Objekten unter Hindernissen Minkowski sumFinden Sie den Weg aus einem Gebäude am weitesten ray traceGiven ein Bündel von Strahlen um die aktuelle Position, die mit ihrer Länge auf eine Wand zugeschrieben wird, bewegt sich der Roboter in Richtung des längsten Strahls, es sei denn, eine Tür ist identifiziert. Ein solcher Algorithmus wurde zur Modellierung des Notausstiegs von Gebäuden verwendet. Künstliche Potentialfelder Ein Ansatz ist es, die Konfiguration des Roboters als Punkt in einem potenziellen Feld zu behandeln, das Attraktion zum Ziel kombiniert, und Ausstoß aus Hindernissen. Die resultierende Trajektorie wird als Pfad ausgegeben. Dieser Ansatz hat Vorteile darin, dass die Trajektorie mit wenig Berechnung hergestellt wird. Sie können jedoch im lokalen Minima des Potentialfeldes gefangen werden und keinen Pfad finden oder einen nicht optimalen Pfad finden. Die künstlichen Potentialfelder können als Kontinuumgleichungen ähnlich elektrostatischen Potentialfeldern behandelt werden (den Roboter wie eine Punktladung behandeln), oder die Bewegung durch das Feld kann mittels einer Reihe von sprachlichen Regeln diskretiert werden. Eine Navigationsfunktion oder eine probabilistische Navigationsfunktion sind Arten von künstlichen Potentialfunktionen, die die Qualität von nicht minimalen Punkten außer dem Zielpunkt haben. Sampling-basierte Algorithmen Sampling-basierte Algorithmen stellen den Konfigurationsraum mit einer Roadmap von abgetasteten Konfigurationen dar. Ein grundlegender Algorithmus Proben N-Konfigurationen in C und behält die in Cfree als Meilensteine zu verwenden. Dann wird eine Roadmap erstellt, die zwei Meilensteine P und Q verbindet, wenn das Liniensegment PQ vollständig in Cfree ist. Auch hier wird die Kollisionserkennung zur Prüfung der Inklusion in Cfree verwendet. Um einen Pfad zu finden, der S und G verbindet, werden sie zur Roadmap hinzugefügt. Wenn ein Pfad in der Roadmap S und G verbindet, gelingt der Planer und kehrt diesen Pfad zurück. Wenn nicht, der Grund ist nicht endgültig: entweder gibt es keinen Pfad in Cfree, oder der Planer hat nicht genug Meilensteine. Diese Algorithmen arbeiten gut für hochdimensionale Konfigurationsräume, da ihre Laufzeit im Gegensatz zu kombinatorischen Algorithmen nicht exponentiell von der Dimension C abhängig ist. Sie sind (in der Regel) auch wesentlich einfacher umzusetzen. Sie sind probabilistisch vollständig, d.h. die Wahrscheinlichkeit, dass sie eine Lösungsansätze 1 erzeugen, da mehr Zeit ausgegeben wird. Sie können jedoch nicht bestimmen, ob keine Lösung vorliegt. Bei grundlegenden Sichtbedingungen auf Cfree hat sich gezeigt, dass als Anzahl der Konfigurationen N wächst höher, die Wahrscheinlichkeit, dass der obige Algorithmus eine Lösung nähert 1 exponentiell. Die Sichtbarkeit ist nicht explizit von der Dimension von C abhängig; es ist möglich, einen hochdimensionalen Raum mit guter Sicht oder einen geringen Raum mit schlechter Sicht zu haben. Der experimentelle Erfolg von stichprobenbasierten Methoden deutet darauf hin, dass am häufigsten gesehene Räume eine gute Sichtbarkeit aufweisen. Es gibt viele Varianten dieses Grundschemas: Es ist in der Regel viel schneller, nur Testsegmente zwischen nahe gelegenen Paaren von Meilensteinen, anstatt alle Paare. Uneinheitliche Stichprobenverteilungen versuchen, mehr Meilensteine in Bereichen zu platzieren, die die Anbindung der Roadmap verbessern. Quasirandom-Proben produzieren in der Regel eine bessere Abdeckung von Konfigurationsraum als pseudorandom, obwohl einige jüngste Arbeiten argumentieren, dass die Wirkung der Zufallsquelle minimal ist als die Wirkung der Probenahmeverteilung. Mitarbeiter lokale Probenahme durch eine Richtung Markov Kette Monte Carlo zufälligen Spaziergang mit einigen lokalen Vorschlag Verteilung. Es ist möglich, die Anzahl der Meilensteine, die für die Lösung eines bestimmten Problems benötigt werden, wesentlich zu reduzieren, indem es gekrümmte Augensichter ermöglicht (z.B. durch das Aufkrippen auf die Hindernisse, die den Weg zwischen zwei Meilensteinen blockieren). Wenn nur eine oder wenige Planungsabfragen benötigt werden, ist es nicht immer erforderlich, eine Fahrkarte des gesamten Raumes zu erstellen. Tree wachsende Varianten sind in der Regel schneller für diesen Fall (Ein-Quer-Planung.) Roadmaps sind immer noch nützlich, wenn viele Abfragen auf demselben Raum erfolgen sollen (Multi-Query-Planung) Liste der bemerkenswerten Algorithmen A* D* Rapidly-exploring random tree Probabilistic roadmap Vollständigkeit und Leistung Ein Bewegungsplaner soll abgeschlossen sein, wenn der Planer in endlicher Zeit entweder eine Lösung produziert oder korrekt berichtet, dass es keine gibt. Die meisten vollständigen Algorithmen sind geometriebasiert. Die Leistung eines kompletten Planers wird durch seine rechnerische Komplexität beurteilt. Wenn man diese Eigenschaft mathematisch beweist, muss man sicherstellen, dass es in endlicher Zeit und nicht nur in der asymptotischen Grenze passiert. Dies ist besonders problematisch, wenn während einer bestimmten Proving-Technik unendliche Sequenzen (die nur im Grenzfall konvergieren) auftreten, da dann theoretisch der Algorithmus nie aufhört. Intuitive Tricks (oft auf Induktionsbasis) werden typischerweise irrtümlich daran gedacht, zu konvergieren, was sie nur für die unendliche Grenze tun. Mit anderen Worten, die Lösung existiert, aber der Planer wird es nie melden. Diese Eigenschaft steht daher im Zusammenhang mit der Turing-Vollständigkeit und dient in den meisten Fällen als theoretische Unter- / Führung. Planer auf Basis eines brutalen Kraftansatzes sind immer vollständig, sind aber nur für endliche und diskrete Setups realisierbar. In der Praxis kann die Beendigung des Algorithmus immer durch einen Zähler gewährleistet werden, der nur eine maximale Anzahl von Iterationen erlaubt und dann immer mit oder ohne Lösung anhält. Für Echtzeit-Systeme wird dies typischerweise durch den Einsatz eines Watchdog-Timers erreicht, der den Prozess einfach umbringt. Der Watchdog muss unabhängig von allen Prozessen sein (typischerweise durch Low Level Interrupt-Routinen realisiert). Der im vorhergehenden Absatz beschriebene asymmetrische Fall wird auf diese Weise jedoch nicht erreicht. Es wird den besten Bericht erstatten, den er bisher gefunden hat (was besser ist als nichts), aber es kann nicht richtig berichten, dass es keine gibt. Alle Realisierungen einschließlich eines Watchdogs sind immer unvollständig (außer alle Fälle können in endlicher Zeit ausgewertet werden.) Vollständigkeit kann nur durch einen sehr strengen mathematischen Korrektheitsnachweis (oft durch Werkzeuge und graphische Methoden unterstützt) bereitgestellt werden und sollte nur von spezialisierten Experten durchgeführt werden, wenn die Anwendung Sicherheitsinhalte umfasst. Auf der anderen Seite ist die Verbesserung der Vollständigkeit einfach, da man nur eine unendliche Schleife oder ein falsches Ergebnis zurückfinden muss. Die formale Verifizierung/Korrektheit von Algorithmen ist ein Forschungsfeld auf eigene Faust. Die korrekte Einrichtung dieser Testfälle ist eine hochentwickelte Aufgabe. Die Vollständigkeit der Auflösung ist die Eigenschaft, dass der Planer garantiert ist, einen Pfad zu finden, wenn die Auflösung eines zugrunde liegenden Rasters gut genug ist. Die meisten aufgelösten Planer sind gitter- oder intervallbasiert. Die rechnerische Komplexität von Auflösungs-Komplettplanern ist abhängig von der Anzahl der Punkte im zugrunde liegenden Raster, das ist O(1/hd), wobei h die Auflösung (die Länge einer Seite einer Gitterzelle) und d die Konfigurationsraumdimension ist. Probabilistische Vollständigkeit ist die Eigenschaft, dass, wenn mehr Arbeit durchgeführt wird, die Wahrscheinlichkeit, dass der Planer nicht einen Weg zu finden, wenn man existiert, asymptotisch nähert sich Null. Mehrere probenbasierte Methoden sind probabilistisch vollständig. Die Leistung eines probabilistisch vollständigen Planers wird durch die Konvergenzrate gemessen. Für praktische Anwendungen verwendet man diese Eigenschaft in der Regel, da sie die Aufstellung der Time-out für den Watchdog basierend auf einer durchschnittlichen Konvergenzzeit ermöglicht. Unvollständige Planer produzieren nicht immer einen machbaren Weg, wenn man existiert (siehe erster Absatz). Manchmal arbeiten unvollständige Planer in der Praxis gut, da sie immer nach einer guarantiierten Zeit stoppen und andere Routinen übernehmen können. Problemvarianten Viele Algorithmen wurden entwickelt, um Varianten dieses Grundproblems zu behandeln. Unterschiedliche Zwänge Holonomic Manipulatorarm (mit Dynamik)Nonholonomic Drones Cars Unicycles Planes Beschleunigung gebundene Systeme Bewegliche Hindernisse (Zeit kann nicht rückwärts gehen)Bevel-Tip lenkbare Nadel Differential Drive Robots Optimality Zwänge Hybrid-Systeme sind solche, die diskretes und kontinuierliches Verhalten mischen. Beispiele für solche Systeme sind: Robotermanipulation Mechanische Montage Legged Roboter Lokomotion Rekonfigurierbare Roboter Unsicher Bewegungsunsicherheit Fehlende Informationen Aktive Sensorlose Planung Anwendungen Roboternnavigation AutomatisierungDer fahrerlose Auto Robotic Chirurgie Digitale Charakteranimation Proteinfaltung Sicherheit und Zugänglichkeit im computergestützten Architekturdesign Siehe auch Gimbal Schloss – ähnliches traditionelles Problem im Maschinenbau Kinodynamische Planung Bergsteigen Problem OMPL -Die Open Motion Planning LibraryPathfinding Pebble Bewegungsprobleme – Multi-Roboter Bewegungsplanung kürzestes Wegeproblem Velocity Hindernis ReferenzenWeiterlesen Latombe, Jean-Claude (2012). Robot Motion Planning. Springer Science & Business Media.ISBN 978-1-4615-4022-9.Planing Algorithms, Steven M. LaValle, 2006, Cambridge University Presse, ISBN 0-521-86205-1.Principles of Robot Motion: Theory, Algorithms, and Implementation, H. Choset, W. Burgard, S. Hutchinson, G. Kantor, L. E. Kavraki, K. Lynch und S. Thrun, MIT Presse, April 2005. Mark de Berg; Marc van Kreveld; Mark Overmars & Otfried Schwarzkopf (2000). Computational Geometry (2. revidiert ed.).Springer-Verlag.ISBN 978-3-540-65620-3.Kapitel 13: Robot Motion Planning: pp.267–290 Externe Links "Open Robotics Automation Virtual Environment", http://openrave.org Jean-Claude Latombe spricht über seine Arbeit mit Robotern und Bewegungsplanung, 5. April 2000 "Open Motion Planning Library (OMPL), http://ompl.kavrakilab.org "Motion Strategy Library" http://msl.cs.uiuc.edu/msl "Motion Planning Kit", https://ai.stanford.edu/~mitul/mpk Simox, http://simox.sourceforge.net "Robot Motion Planning and Control", http://www.laas.fr/%7Ejpl/book.html