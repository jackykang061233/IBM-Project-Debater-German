Secure Shell (SSH) ist ein kryptographisches Netzwerkprotokoll zum sicheren Betrieb von Netzwerkdiensten über ein ungesichertes Netzwerk. Typische Anwendungen umfassen Remote-Befehlszeile, Login und Remote-Befehlsausführung, aber jeder Netzwerkservice kann mit SSH gesichert werden. SSH bietet einen sicheren Kanal über ein ungesichertes Netzwerk, indem eine Client-Server-Architektur verwendet wird und eine SSH-Client-Anwendung mit einem SSH-Server verbindet. Die Protokollspezifikation unterscheidet zwischen zwei großen Versionen, die als SSH-1 und SSH-2 bezeichnet werden. Der Standard-TCP-Port für SSH ist 22. SSH wird in der Regel verwendet, um Unix-ähnliche Betriebssysteme zugreifen, aber es kann auch unter Microsoft Windows verwendet werden. Windows 10 verwendet OpenSSH als Standard-SSH-Client und SSH-Server. SSH wurde als Ersatz für Telnet und für ungesicherte Remote Shell-Protokolle wie die Berkeley rsh und die zugehörigen Rlogin- und Rexec-Protokolle konzipiert. Diese Protokolle senden sensible Informationen, insbesondere Passwörter, im Klartext, die sie durch Paketanalyse anfällig für Abhör und Offenlegung. Die von SSH verwendete Verschlüsselung soll Vertraulichkeit und Integrität von Daten über ein ungesichertes Netzwerk, wie das Internet, bereitstellen. Definition SSH verwendet die Public-key-Kryptographie, um den Remote-Computer zu authentifizieren und den Benutzer gegebenenfalls zu authentifizieren. Es gibt verschiedene Möglichkeiten, SSH zu verwenden; man soll automatisch generierte öffentlich-private Schlüsselpaare verwenden, um einfach eine Netzwerkverbindung zu verschlüsseln und dann die Passwort-Authentifizierung verwenden, um sich anzumelden. Ein anderes ist die Verwendung eines manuell generierten öffentlich-privaten Schlüsselpaars, um die Authentifizierung durchzuführen, so dass sich Benutzer oder Programme einloggen, ohne ein Passwort angeben zu müssen. In diesem Szenario kann jeder ein passendes Paar verschiedener Schlüssel (öffentlich und privat) produzieren. Der öffentliche Schlüssel wird auf allen Computern platziert, die den Zugang zum Besitzer des passenden privaten Schlüssels ermöglichen müssen (der Besitzer hält das private Schlüsselgeheimnis). Während die Authentifizierung auf dem privaten Schlüssel basiert, wird der Schlüssel selbst während der Authentifizierung niemals über das Netzwerk übertragen. Die SSH überprüft nur, ob dieselbe Person, die den öffentlichen Schlüssel anbietet, auch den passenden privaten Schlüssel besitzt. In allen Versionen von SSH ist es wichtig, unbekannte öffentliche Schlüssel zu überprüfen, d.h. die öffentlichen Schlüssel mit Identitäten zu verknüpfen, bevor sie als gültig anerkannt werden. Die Akzeptanz des öffentlichen Schlüssels eines Angreifers ohne Validierung wird einen nicht autorisierten Angreifer als gültiger Benutzer autorisieren. Authentication: OpenSSH Key Management Auf Unix-ähnlichen Systemen wird die Liste der autorisierten öffentlichen Schlüssel typischerweise im Home-Verzeichnis des Benutzers gespeichert, der in der Datei ~ssh/autorized_keys remote einloggen darf. Diese Datei wird nur von SSH respektiert, wenn sie von nichts außer dem Besitzer und der Wurzel schreibbar ist. Wenn der öffentliche Schlüssel am entfernten Ende vorhanden ist und der passende private Schlüssel am lokalen Ende vorhanden ist, ist die Eingabe im Passwort nicht mehr erforderlich. Für zusätzliche Sicherheit kann der private Schlüssel selbst jedoch mit einer Passphrase verriegelt werden. Der private Schlüssel kann auch an Standardplätzen gesucht werden und sein voller Pfad kann als Befehlszeileneinstellung (Option -i für ssh) angegeben werden. Das ssh-keygen Dienstprogramm produziert die öffentlichen und privaten Schlüssel, immer paarweise. SSH unterstützt auch die passwortbasierte Authentifizierung, die durch automatisch generierte Schlüssel verschlüsselt wird. In diesem Fall könnte der Angreifer die legitime Serverseite nachahmen, nach dem Passwort fragen und erhalten (man-in-the-middle attack). Dies ist jedoch nur möglich, wenn die beiden Seiten noch nie authentifiziert sind, da sich SSH an den Schlüssel erinnert, den die zuvor verwendete Serverseite verwendet hat. Der SSH-Client erhebt eine Warnung, bevor er den Schlüssel eines neuen, bisher unbekannten Servers akzeptiert. Die Passwort-Authentifizierung kann von der Serverseite aus deaktiviert werden. Die Verwendung SSH wird typischerweise verwendet, um in eine Remote-Maschine einzuloggen und Befehle auszuführen, unterstützt aber auch Tunneling, Weiterleitung von TCP-Ports und X11-Verbindungen; sie kann Dateien mit dem zugehörigen SSH-Dateitransfer (SFTP) oder Secure Copy (SCP)-Protokollen übertragen. SSH nutzt das Client-Server-Modell. Ein SSH-Client-Programm wird typischerweise verwendet, um Verbindungen zu einem SSH-Daemon herzustellen, das Remote-Verbindungen akzeptiert. Beide sind häufig auf den meisten modernen Betriebssystemen vorhanden, darunter macOS, die meisten Distributionen von Linux, OpenBSD, FreeBSD, NetBSD, Solaris und OpenVMS. Insbesondere, Versionen von Windows vor Windows 10 Version 1709 enthalten nicht SSH standardmäßig. Es existieren proprietäre, Freeware und Open Source (z.B. PuTTY, und die Version von OpenSSH, die Teil von Cygwin ist) Versionen verschiedener Komplexität und Vollständigkeit. Dateimanager für UNIX-ähnliche Systeme (z.B. Konqueror) können mit dem FISH-Protokoll eine Split-Paare-GUI mit Drag-and-Drop bereitstellen. Das Open-Source-Windows-Programm WinSCP bietet ähnliche Dateiverwaltung (Synchronisierung, Kopie, Remote-S delete-Fähigkeit mit PuTTY als Back-End. Sowohl WinSCP als auch PuTTY stehen zur Verfügung, um direkt von einem USB-Laufwerk abzulaufen, ohne dass eine Installation auf dem Client-Computer erforderlich ist. Die Einrichtung eines SSH-Servers in Windows beinhaltet in der Regel die Aktivierung einer Funktion in der App Einstellungen. In Windows 10 Version 1709 ist ein offizieller Win32 Port von OpenSSH verfügbar. SSH ist wichtig in der Cloud-Computing, um Konnektivitätsprobleme zu lösen, um die Sicherheitsprobleme zu vermeiden, eine Cloud-basierte virtuelle Maschine direkt im Internet auszusetzen. Ein SSH-Tunnel kann einen sicheren Weg über das Internet, über eine Firewall zu einer virtuellen Maschine bereitstellen. Die IANA hat TCP-Port 22, UDP-Port 22 und SCTP-Port 22 für dieses Protokoll zugewiesen. IANA hatte bereits 2001 den Standard-TCP-Port 22 für SSH-Server als einer der bekannten Ports aufgelistet. SSH kann auch mit SCTP statt TCP als verbindungsorientiertes Transportschichtprotokoll betrieben werden. Geschichte und Entwicklung Version 1.xIn 1995, Tatu Ylönen, ein Forscher an der Technischen Universität Helsinki, Finnland, entwarf die erste Version des Protokolls (jetzt SSH-1) durch einen passwortschonenden Angriff an seinem Universitätsnetzwerk. Ziel der SSH war es, die früheren Rlogin-, TELNET-, FTP- und rsh-Protokolle zu ersetzen, die keine starke Authentifizierung und keine Gewähr für Vertraulichkeit bieten. Ylönen veröffentlichte seine Implementierung als Freeware im Juli 1995, und das Tool schnell in der Popularität gewonnen. Ende 1995 war die SSH-Benutzerbasis in fünfzig Ländern auf 20.000 Nutzer angewachsen. Im Dezember 1995 gründete Ylönen SSH Communications Security, um SSH zu vermarkten und zu entwickeln. Die ursprüngliche Version der SSH-Software verwendet verschiedene Stücke freier Software, wie GNU libgmp, aber spätere Versionen, die von SSH Communications Security veröffentlicht wurden, entwickelten sich zu einer zunehmend proprietären Software. Es wurde geschätzt, dass die Zahl der Nutzer bis zum Jahr 2000 auf 2 Millionen gewachsen war. Version 2.x Secsh war der offizielle Internet Engineering Task Force (IETF) Name für die IETF Arbeitsgruppe, die für die Version 2 des SSH-Protokolls verantwortlich ist. 2006 wurde eine überarbeitete Version des Protokolls SSH-2 als Standard angenommen. Diese Version ist mit SSH-1.SSH-2 unvereinbar und bietet sowohl Sicherheit als auch Verbesserungen gegenüber SSH-1. Bessere Sicherheit beispielsweise durch Diffie-Hellman-Schlüsselaustausch und eine starke Integritätsprüfung über Nachrichtenauthentifizierungscodes. Neue Features von SSH-2 beinhalten die Möglichkeit, eine beliebige Anzahl von Shell-Sitzungen über eine einzige SSH-Verbindung auszuführen. Aufgrund der Überlegenheit und Popularität von SSH-2 über SSH-1, einige Implementierungen wie libssh (v0.8.0,+) Lsh und Dropbear unterstützen nur das SSH-2 Protokoll. Version 1.99Im Januar 2006, gut nach Version 2.1 wurde festgelegt, RFC 4253 spezifiziert, dass ein SSH-Server, der sowohl 2.0 als auch vorherige Versionen von SSH unterstützt, seine Protoversion als 1.99 identifizieren sollte. Dies ist keine eigentliche Version, sondern eine Methode, um Rückwärtskompatibilität zu identifizieren. OpenSSH und OSSHIn 1999, Entwickler, die eine kostenlose Softwareversion zur Verfügung stellen möchten, gingen zurück zur älteren Version 1.2.12 des ursprünglichen SSH-Programms, das zuletzt unter einer Open Source-Lizenz veröffentlicht wurde. Björn Grönvalls OSSH wurde anschließend aus dieser Codebase entwickelt. Kurz darauf gaben OpenBSD-Entwickler Grönvalls Code und arbeiteten intensiv daran, OpenSSH zu schaffen, die mit der 2,6-Veröffentlichung von OpenBSD ausgeliefert wurde. Von dieser Version wurde ein Portabilitätszweig gebildet, um OpenSSH zu anderen Betriebssystemen zu portieren. Seit 2005 war OpenSSH die einzige populärste SSH-Implementierung, die standardmäßig in einer Vielzahl von Betriebssystemen vorkommt. OSSH ist inzwischen veraltet geworden. OpenSSH wird weiterhin gepflegt und unterstützt das SSH-2 Protokoll, das SSH-1-Support aus der Codebase mit dem OpenSSH 7.6 Release ausgeweitet hat. SSH ist ein Protokoll, das für viele Anwendungen auf vielen Plattformen verwendet werden kann, einschließlich der meisten Unix-Varianten (Linux, die BSDs einschließlich Apples macOS und Solaris), sowie Microsoft Windows. Einige der folgenden Anwendungen können Funktionen erfordern, die nur verfügbar sind oder mit bestimmten SSH-Clients oder -Servern kompatibel sind. Beispielsweise ist die Verwendung des SSH-Protokolls zur Implementierung eines VPN möglich, aber derzeit nur mit der OpenSSH-Server- und Client-Implementierung. Für die Anmeldung an eine Shell auf einem Remote-Host (Replacing Telnet und rlogin) Für die Ausführung eines einzigen Befehls auf einem Remote-Host (Replacing rsh) Für die Einrichtung automatischer (passwortloser) Anmeldung an einen Remote-Server (z.B. mit OpenSSH)In Kombination mit rsync, um Dateien effizient und sicher zu sichern, zu kopieren und zu spiegeln Für die Weiterleitung eines Ports For tunneling (nicht zu verwechseln mit einem VPN, das Pakete zwischen verschiedenen Netzwerken führt, oder zwei Broadcast-Domains inrückt). Für die Verwendung als vollwertiges verschlüsseltes VPN. Beachten Sie, dass nur OpenSSH Server und Client diese Funktion unterstützt. Für die Weiterleitung von X von einem Remote-Host (möglich durch mehrere Zwischen-Hosts) Um das Web über eine verschlüsselte Proxyverbindung mit SSH-Clients zu durchsuchen, die das SOCKS-Protokoll unterstützen. Zur sicheren Montage eines Verzeichnisses auf einem Remoteserver als Dateisystem auf einem lokalen Computer mit SSHFS. Zur automatisierten Fernüberwachung und Verwaltung von Servern über einen oder mehrere der oben diskutierten Mechanismen. Zur Entwicklung auf einem mobilen oder eingebetteten Gerät, das SSH unterstützt. Zur Sicherung von Dateiübertragungsprotokollen. Dateiübertragungsprotokolle Die Secure Shell-Protokolle werden in mehreren Dateiübertragungsmechanismen verwendet. Sichere Kopie (SCP), die aus RCP-Protokoll über SSH rsync entwickelt wurde, soll effizienter als SCP sein. Im Allgemeinen läuft über eine SSH-Verbindung. SSH File Transfer Protocol (SFTP,) eine sichere Alternative zu FTP (nicht zu verwechseln mit FTP über SSH oder FTPS)Files übertragen über Shell-Protokoll (a.k.a FISH,) veröffentlicht im Jahr 1998, die von Unix Shell Befehle über SSH Fast and Secure Protocol (FASP,) aka Aspera, verwendet SSH für Steuerungs- und UDP-Ports für die Datenübertragung. Architektur Das SSH-2 Protokoll verfügt über eine interne Architektur (definiert in RFC 4251) mit gut getrennten Schichten, nämlich: Die Transportschicht (RFC 4253), die typischerweise über TCP/IP läuft. Diese Schicht behandelt den ersten Schlüsselaustausch sowie die Serverauthentifizierung und stellt die Verschlüsselung, Kompression und Integritätsprüfung fest. Es stellt der oberen Schicht eine Schnittstelle zum Senden und Empfangen von Klartextpaketen mit Größen von jeweils bis zu 32.768 Bytes (mehr kann durch die Implementierung erlaubt werden). Die Transportschicht sorgt auch für einen Schlüsselumtausch, üblicherweise nach einer Übertragung von 1 GB Daten oder nach einer Stunde, je nachdem, was zuerst geschieht. Die Benutzerauthentifizierungsschicht (RFC 4252). Diese Schicht behandelt die Client-Authentifizierung und bietet eine Reihe von Authentifizierungsverfahren. Authentication ist client-driven: Wenn man für ein Passwort aufgefordert wird, kann es der SSH-Client sein, der aufgefordert wird, nicht der Server. Der Server reagiert lediglich auf die Authentifizierungsanforderungen des Clients. Zu den weit verbreiteten Benutzer-Authentifizierungsmethoden gehören folgendes: Passwort: eine Methode zur einfachen Passwort-Authentifizierung, einschließlich einer Einrichtung, die ein Passwort geändert werden kann. Nicht alle Programme implementieren diese Methode. publickey: ein Verfahren zur öffentlich-keybasierten Authentifizierung, das in der Regel mindestens DSA-, ECDSA- oder RSA-Schlüsselpaare unterstützt, wobei andere Implementierungen auch X.509-Zertifikate unterstützen. keyboard-interactive (RFC 4256): ein vielseitiges Verfahren, bei dem der Server eine oder mehrere Aufforderungen zum Eingeben von Informationen sendet und der Client diese anzeigt und von dem Benutzer eingetastete Rückmeldungen sendet. Verwendet, um eine einmalige Passwort-Authentifizierung wie S/Key oder SecurID zur Verfügung zu stellen. Wird von einigen OpenSSH-Konfigurationen verwendet, wenn PAM der zugrunde liegende Host-Authentifizierungs-Anbieter ist, um die Passwort-Authentifizierung effektiv bereitzustellen, manchmal führt zu einer Unfähigkeit, sich mit einem Client zu anmelden, der nur die einfache Passwort-Authentifizierungsmethode unterstützt. GSSAPI-Authentifizierungsmethoden, die ein erweitertes System zur Durchführung der SSH-Authentifizierung mit externen Mechanismen wie Kerberos 5 oder NTLM bereitstellen, die SSH-Sitzungen mit einer einzigen Sign-on-Fähigkeit ermöglichen. Diese Methoden werden in der Regel von kommerziellen SSH-Implementierungen für den Einsatz in Organisationen umgesetzt, obwohl OpenSSH eine funktionierende GSSAPI-Implementierung hat. Die Verbindungsschicht (RFC 4254). Diese Schicht definiert das Konzept von Kanälen, Kanalanfragen und globalen Anfragen, mit denen SSH-Dienste bereitgestellt werden. Eine einzige SSH-Verbindung kann mehrere Kanäle gleichzeitig hosten, jede Übertragung von Daten in beide Richtungen. Kanalanfragen werden verwendet, um aus Bandkanalspezifische Daten, wie die geänderte Größe eines Terminalfensters oder der Ausgangscode eines serverseitigen Prozesses, weiterzuleiten. Zusätzlich führt jeder Kanal mit der Empfangsfenstergröße eine eigene Durchflussregelung durch. Der SSH-Client fordert einen serverseitigen Port auf, der über eine globale Anfrage weitergeleitet wird. Standard-Kanaltypen umfassen: Shell für Terminal-Shells, SFTP- und Exec-Anfragen (einschließlich SCP-Transfers) Direkt-Tcpip für Client-to-Server-weitergeleitete Verbindungen weitergeleitet-tcpip für Server-zu-Client-weitere Verbindungen Der SSHFP DNS-Record (RFC 4255) bietet die öffentlichen Host-Schlüssel Fingerabdrücke, um bei der Überprüfung der Echtheit des Hosts zu helfen. Diese offene Architektur bietet eine erhebliche Flexibilität und ermöglicht die Verwendung von SSH für eine Vielzahl von Zwecken jenseits einer sicheren Hülle. Die Funktionalität der Transportschicht allein ist mit Transport Layer Security (TLS) vergleichbar; die Benutzer-Authentifizierungsschicht ist mit benutzerdefinierten Authentisierungsmethoden sehr erweiterbar; und die Verbindungsschicht bietet die Möglichkeit, viele Sekundärsitzungen in eine einzige SSH-Verbindung zu multiplexen, eine mit BEEP vergleichbare und in TLS nicht verfügbare Funktion. Trotz beliebter Missverständnisse ist SSH keine Implementierung von Telnet mit Kryptographie der Secure Sockets Layer (SSL.) Algorithmen EdDSA, ECDSA, RSA und DSA für Public-key-Kryptographie. ECDH und Diffie–Hellman für Schlüsselaustausch. HMAC, AEAD und UMAC für MAC.AES (und deprecated RC4, 3DES, DES) für symmetrische Verschlüsselung. AES-GCM und ChaCha20-Poly1305 für AEAD-Verschlüsselung. SHA (und deprecated MD5) für Tastendruck. Sicherheitslücken SSH-1In 1998 wurde in SSH 1.5 eine Schwachstelle beschrieben, die das unbefugte Einfügen von Inhalten in einen verschlüsselten SSH-Stream aufgrund eines unzureichenden Datenschutzes von CRC-32 in dieser Version des Protokolls erlaubte. Ein Fix namens SSH Compensation Attack Detector wurde in die meisten Implementierungen eingeführt. Viele dieser aktualisierten Implementierungen enthielten eine neue Ganzzahl-Überlauf-Verwundbarkeit, die Angreifern erlaubt, beliebigen Code mit den Privilegien des SSH-Daemon, typischerweise root auszuführen. Im Januar 2001 wurde eine Schwachstelle entdeckt, die Angreifern erlaubt, den letzten Block einer IDEA-verschlüsselten Sitzung zu ändern. Im selben Monat wurde eine weitere Schwachstelle entdeckt, die es einem bösartigen Server ermöglichte, eine Client-Authentifizierung an einen anderen Server weiterzuleiten. Da SSH-1 inhärente Konstruktionsfehler aufweist, die es verletzlich machen, wird es jetzt allgemein als obsolet betrachtet und sollte durch explizites Abschalten von Fallback zu SSH-1 vermieden werden. Die meisten modernen Server und Clients unterstützen SSH-2. CBC Klartext Erholung Im November 2008 wurde für alle Versionen von SSH eine theoretische Schwachstelle entdeckt, die die Wiederherstellung von bis zu 32 Bit Klartext aus einem Block von Chiffretext ermöglichte, der mit dem Standard-Standard-Verschlüsselungsmodus CBC verschlüsselt wurde. Die einfachste Lösung ist die Verwendung von CTR, Zählermodus, anstatt CBC-Modus, da dies SSH resistent gegen den Angriff macht. Mögliche Schwachstellen Am 28. Dezember 2014 veröffentlichte der Spiegel geheime Informationen von Whistleblower Edward Snowden, die darauf hindeuten, dass die National Security Agency in der Lage sein kann, einige SSH-Verkehr zu entschlüsseln. Die mit einem solchen Verfahren verbundenen technischen Einzelheiten wurden nicht offenbart. Eine Analyse im Jahr 2017 der Hacking-Tools BothanSpy & Gyrfalcon schlug vor, dass das SSH-Protokoll selbst nicht beeinträchtigt wurde. Dokumentation der Normen Die folgenden RFC-Veröffentlichungen des IETF secsh-Arbeitsgruppendokuments SSH-2 als vorgeschlagener Internetstandard. RFC 4250 – The Secure Shell (SSH)Protocol Assigned Numbers RFC 4251 – The Secure Shell (SSH) Protocol Architecture RFC 4252 – The Secure Shell (SSH)Authentication Protocol RFC 4253 – The Secure Shell (SSH) Transport Layer Protocol RFC 4254 – The Secure Shell (SSH) Connection Protocol RFC 4255 – Verwendung von DNS zur sicheren Veröffentlichung von Secure Shells 4344 – Die Secure Shell (SSH) Transport Layer Encryption Modes RFC 4345 –Verbesserte Arcfour-Modi für das Secure Shell (SSH) Transport Layer Protocol Sie wurde später durch folgende Veröffentlichungen geändert und erweitert. RFC 4419 – Diffie-Hellman Group Exchange für das Secure Shell (SSH) Transport Layer Protocol (März 2006) RFC 4432 – RSA Schlüsselaustausch für das Secure Shell (SSH) Transport Layer Protocol (März 2006) RFC 4462 – Generisches Sicherheitsdienst Application Program Interface (GSS-API) Authentifizierung und Schlüsselaustausch für das Secure Shell (SSH) Protokoll (Mai 2006)RFC 4716 – Die Secure Shell (SSH) Öffentliche Key File Format (November 2006) RFC 4819 – Sicher Shell Public Key Subsystem (März 2007)RFC 5647 – AES Galois Counter Mode für das Secure Shell Transport Layer Protocol (August 2009)RFC 5656 – Elliptic Curve Algorithm Integration in die Secure Shell Transport Layer (Dezember 2009) RFC 6187 – X.509v3 Zertifikate für Secure Shell Authentication (März 2011) RFC 6239 – Suite B Cryptographic Suiten für Secure Shell (SSH) (Mai 2011) RFC 6594 – Verwendung des SHA-256 Algorithmus mit RSA, Digital Signature Algorithm (DSA,) und Elliptic Curve DSA (ECDSA) in SSHFP Resource Records (April 2012) RFC 6668 – SHA-2 Datenintegrity Verification for the Secure Shell (SSH) Transport Layer Protocol (Juli 2012) RFC 7479 – Ed25519 SSHFP Resource Records (März 2015) RFC 5592 – Secure Shell Transport Modell für das Simple Network Management Protocol SNMP (Juni 2009)RFC 6242 – Mit dem NETCONF-Protokoll über Secure Shell SSH (Juni 2011) Draft-gerhards-syslog-transport-ssh-00 – SSH-Transport-Mapping für SYSLOG (Juli 2006) Draft-ietf-secsh-filexfer-13 – SSH File Transfer Protocol (Juli 2006) Darüber hinaus umfasst das OpenSSH-Projekt mehrere Herstellerprotokollspezifikationen/Erweiterungen: OpenSSH PROTOCOL Übersicht OpenSSH-Zertifikat/Keyübersicht Draft-miller-ssh-agent-04 - SSH Agent Protocol (Dezember 2019) Siehe auch Brute-force Angriff Vergleich der SSH-Clients Vergleich der SSH-Server Corkscrew Ident OpenSSH Secure Shell Tunneling Web-basierte SSH Referenzen Weiter lesen Barrett, Daniel J.; Silverman, Richard E.; Byrnes, Robert G. (2005). SSH: Die Secure Shell (The Definitive Guide) (2. ed.). O'Reilly.ISBN 0-596-00895-3.Stahnke, Michael (2005). Pro OpenSSH.Apress.ISBN 1-59059-476-2.Tatu Ylönen (12. Juli 1995)." Ankündigung: Ssh (Secure Shell)Remote Login Program".comp.security.unix.Originale Ankündigung von Ssh Dwivedi, Himanshu (2003). Ausführung SSH. Wiley. ISBN 978-0-471-45880-7. Externe Links SSH-Protokolle M. Joseph; J. Susoy (November 2013). P6R's Secure Shell Public Schlüsselsubsystem.doi:10.17487/RFC7076.RFC 7076.