Ein Echtzeit-Betriebssystem (RTOS) ist ein Betriebssystem (OS), das Echtzeit-Anwendungen bedienen soll, die Daten verarbeiten, wie es kommt, typischerweise ohne Pufferverzögerungen. Die Prozesszeitanforderungen (einschließlich etwaiger OS-Verzögerung) werden in Zehnteln von Sekunden oder kürzeren Zeitstufen gemessen. Ein Echtzeit-System ist ein zeitgebundenes System, das definierte, feste Zeitzwänge aufweist. Die Verarbeitung muss innerhalb der definierten Zwänge erfolgen oder das System scheitert. Sie sind entweder ereignisgesteuert oder zeitsparend. Eventgesteuerte Systeme schalten zwischen Aufgaben auf Basis ihrer Prioritäten um, während Zeit-Sharing-Systeme die Aufgabe basierend auf Taktunterbrechungen schalten. Die meisten RTOSs verwenden einen voremptiven Schieduling-Algorithmus. Merkmale Ein Schlüsselmerkmal eines RTOS ist das Niveau seiner Konsistenz in Bezug auf die Zeit, die es braucht, um die Aufgabe einer Anwendung zu übernehmen und zu vervollständigen; die Variabilität ist jitter'.Ein hartes Echtzeit-Betriebssystem (Hard RTOS) hat weniger Jitter als ein weiches Echtzeit-Betriebssystem (Soft RTOS). Die späte Antwort ist eine falsche Antwort in einem harten RTOS, während eine späte Antwort in einem weichen RTOS akzeptabel ist. Das Haupt-Design-Ziel ist nicht hohe Durchsatz, sondern eine Garantie für eine weiche oder harte Leistungsklasse. Ein RTOS, das in der Regel oder allgemein eine Frist erfüllen kann, ist ein weiches Echtzeit-Betriebssystem, aber wenn es eine Frist deterministisch erfüllen kann, ist es eine harte EchtzeitOS. Ein RTOS hat einen fortgeschrittenen Algorithmus zum Schieduling. Die Scheduler-Flexibilität ermöglicht eine breitere, computergestützte Orchestrierung von Prozessprioritäten, aber ein Echtzeit-Betriebssystem ist häufiger einer engen Reihe von Anwendungen gewidmet. Schlüsselfaktoren in einem Echtzeit-Betriebssystem sind minimale Interrupt-Latenz und minimale Thread-Schaltlatenz; ein Echtzeit-Betriebssystem wird mehr geschätzt, wie schnell oder wie vorhersehbar es reagieren kann als für die Menge der Arbeit, die es in einer bestimmten Zeit durchführen kann. Siehe den Vergleich von Echtzeit-Betriebssystemen für eine umfassende Liste. Siehe auch die Liste der Betriebssysteme für alle Arten von Betriebssystemen. Design Philosophie Ein RTOS ist ein Betriebssystem, bei dem die Zeit zur Verarbeitung eines Eingangsstimulus geringer ist als die Zeit bis zum nächsten Eingangsstimulus desselben Typs verstrichen ist. Die häufigsten Designs sind: Event-getrieben – schaltet Aufgaben nur dann, wenn ein Ereignis höherer Priorität Service benötigt; genannt preemptive Priorität, oder Prioritätsplanung. Zeit-Sharing – schaltet Aufgaben auf einen regelmäßigen getakteten Interrupt und auf Ereignissen; genannt Runden Robin. Zeit-Sharing-Designs schalten Aufgaben häufiger als unbedingt erforderlich, aber geben Sie glatter Multitasking, so dass die Illusion, dass ein Prozess oder Benutzer alleinige Verwendung einer Maschine hat. Frühe CPU-Designs brauchten viele Zyklen, um Aufgaben zu wechseln, während denen die CPU nichts anderes nützlich machen konnte. Weil das Schalten so lange dauerte, versuchten die frühen Betriebssysteme, die CPU-Zeit zu minimieren, indem sie unnötige Aufgabenvermittlung vermeiden. Regelung In typischen Designs hat eine Aufgabe drei Zustände: Laufen (Ausführen auf der CPU); Bereiten (bereits ausgeführt werden;) Blockiert (z.B. für ein Ereignis, I/O). Die meisten Aufgaben sind blockiert oder bereit, da in der Regel nur eine Aufgabe zu einer Zeit pro CPU laufen kann. Die Anzahl der Elemente in der fertigen Warteschlange kann stark variieren, je nach Anzahl der Aufgaben, die das System ausführen muss, und der Art des Schedulers, den das System verwendet. Bei einfacheren nicht-präempiven, aber immer noch multitasking-Systemen muss eine Aufgabe ihre Zeit auf der CPU anderen Aufgaben aufgeben, die dazu führen kann, dass die fertige Warteschlange eine größere Anzahl von Gesamtaufgaben im fertig ausgeführten Zustand hat (Ressource starvation). Üblicherweise ist die Datenstruktur der Fertigliste im Scheduler so ausgelegt, dass die im kritischen Abschnitt des Schedulers verbrachte schlimmste Zeitdauer minimiert wird, während der die Präemption gehemmt wird, und in einigen Fällen werden alle Interrupts deaktiviert, aber die Wahl der Datenstruktur hängt auch von der maximalen Anzahl der Aufgaben ab, die auf der Fertigliste liegen können. Wenn es nie mehr als ein paar Aufgaben auf der Fertigliste gibt, dann ist eine doppelt verknüpfte Liste von Fertigaufgaben wahrscheinlich optimal. Wenn die fertige Liste in der Regel nur wenige Aufgaben enthält, aber gelegentlich mehr enthält, dann sollte die Liste nach Priorität sortiert werden. Auf diese Weise ist es nicht erforderlich, die höchste Prioritätsaufgabe zu finden, durch die gesamte Liste zu laufen. Das Einfügen einer Aufgabe erfordert dann das Gehen der Fertigliste bis zum Erreichen entweder des Endes der Liste, oder eine Aufgabe von niedrigerer Priorität als die des Einfügens der Aufgabe. Bei dieser Suche muss darauf geachtet werden, die Präemption nicht zu hemmen. Längere kritische Abschnitte sollten in kleine Stücke unterteilt werden. Wenn ein Interrupt auftritt, der eine hohe Prioritätsaufgabe während des Einsetzens einer niedrigen Prioritätsaufgabe bereitstellt, kann eine hohe Prioritätsaufgabe unmittelbar vor dem Einsetzen der niederen Prioritätsaufgabe eingefügt und ausgeführt werden.Die kritische Reaktionszeit, manchmal die Flyback-Zeit genannt, ist die Zeit, die es braucht, um eine neue Bereitschaftsaufgabe zu löschen und den Zustand der höchsten Prioritätsaufgabe zum Laufen wiederherzustellen. In einem gut gestalteten RTOS wird die Bereitstellung einer neuen Aufgabe 3 bis 20 Anweisungen pro Vorwahl-Eintrag und die Wiederherstellung der höchstprioritätsbereiten Aufgabe wird 5 bis 30 Anweisungen. In fortschrittlicheren Systemen teilen Echtzeit-Aufgaben Rechenressourcen mit vielen nicht Echtzeit-Aufgaben und die Fertigliste kann beliebig lang sein. In solchen Systemen wäre eine als verknüpfte Liste implementierte Scheduler-Installation unzureichend. AlgorithmsEine häufig verwendete RTOS-Scheduling-Algorithmen sind: Genossenschaft scheduling Preemptive Schieduling Rate-monotonic scheduling Round-robin scheduling Fixed Priority Pre-emptive Schieduling, eine Implementierung von präemptive Zeit slicing Fixed-Priority Scheduling wie Deferred Preemption Fixed Der Scheduler hat höchste Priorität für Arbeitsplätze mit der niedrigsten Nachfrage auf dem Computer, so dass es keine Möglichkeit gibt, sicherzustellen, dass ein zeitkritischer Job Zugang zu genügend Ressourcen haben wird. Multitasking-Systeme müssen das Teilen von Daten und Hardware-Ressourcen unter mehreren Aufgaben verwalten. Es ist in der Regel unsicher, dass zwei Aufgaben gleichzeitig auf die gleichen spezifischen Daten oder Hardwareressourcen zugreifen. Es gibt drei gemeinsame Ansätze, dieses Problem zu lösen: Vorübergehende Maskierung/Deaktivierung unterbricht Allgemeine Betriebssysteme erlauben normalerweise keine Benutzerprogramme, Unterbrechungen zu maskieren (deaktivieren), da das Benutzerprogramm die CPU so lange steuern könnte, wie es wünscht. Einige moderne CPUs erlauben keinen Benutzer-Modus-Code zu deaktivieren Unterbrechungen, da eine solche Steuerung als eine Schlüssel-Betriebssystem-Ressource betrachtet wird. Viele eingebettete Systeme und RTOSs erlauben es jedoch, dass die Anwendung selbst im Kernel-Modus für eine höhere Systemaufrufeffizienz läuft und die Anwendung auch eine größere Kontrolle der Betriebsumgebung ermöglicht, ohne dass ein OS-Eingriff erforderlich ist. Bei Einprozessorsystemen ist eine Anwendung, die im Kernel-Modus läuft und Unterbrechungen maskiert, das niedrigste Overhead-Verfahren, um einen gleichzeitigen Zugriff auf eine gemeinsame Ressource zu verhindern. Während Unterbrechungen maskiert sind und die aktuelle Aufgabe keinen blockierenden OS-Call macht, hat die aktuelle Aufgabe ausschließlich die CPU, da keine andere Aufgabe oder Unterbrechung die Steuerung übernehmen kann, so dass der kritische Abschnitt geschützt ist. Wenn die Aufgabe ihren kritischen Abschnitt verlässt, muss sie unmask unterbrechen; anstehende Unterbrechungen, wenn überhaupt, wird dann ausführen. Vorübergehende Maskierungsunterbrechungen sollten nur dann erfolgen, wenn der längste Weg durch den kritischen Abschnitt kürzer ist als die gewünschte maximale Unterbrechungslatte. Typischerweise wird diese Schutzart nur dann verwendet, wenn der kritische Abschnitt nur wenige Anweisungen enthält und keine Schleifen enthält. Dieses Verfahren ist ideal zum Schutz von Hardware-Bit-mapped-Registern, wenn die Bits durch verschiedene Aufgaben gesteuert werden. Mutexes Wenn die gemeinsame Ressource reserviert werden muss, ohne alle anderen Aufgaben zu blockieren (z.B. auf Flash-Speicher zu warten, um geschrieben zu werden), ist es besser, Mechanismen zu verwenden, die auch auf allgemeinen Betriebssystemen zur Verfügung stehen, wie z.B. eine mutex und OS-supervised interprocess messaging. Solche Mechanismen beinhalten Systemanrufe und rufen in der Regel den Dispater-Code des Betriebssystems am Ausgang an, so dass sie typischerweise Hunderte von CPU-Anweisungen ausführen, während Maskierung Unterbrechungen können so wenig wie eine Anweisung auf einigen Prozessoren. Eine (nicht-rekursive) Mutex wird entweder gesperrt oder entriegelt. Wenn eine Aufgabe den Mutex gesperrt hat, müssen alle anderen Aufgaben darauf warten, dass der Mutex von seinem Besitzer entriegelt wird - der ursprüngliche Faden. Eine Aufgabe kann einen Timeout auf seinem Warten auf einen Mutex setzen. Es gibt mehrere bekannte Probleme mit Mutex-basierten Designs wie Prioritätsinversion und Totschläge. In der Prioritätsinversion wartet eine hohe Prioritätsaufgabe, weil eine niedrige Prioritätsaufgabe einen Mutex hat, aber die untere Prioritätsaufgabe wird nicht CPU-Zeit gegeben, um seine Arbeit zu beenden. Eine typische Lösung ist die Aufgabe zu haben, die einen Mutex besitzt, der die Priorität der höchsten Warteaufgabe erbt. Aber diese einfache Herangehensweise wird komplexer, wenn es mehrere Ebenen des Wartens gibt: Aufgabe A wartet auf einen Mutex, der von Aufgabe B gesperrt wird, der auf einen Mutex wartet, der von Aufgabe C gesperrt ist.In einem Totlock sperren zwei oder mehr Aufgaben Mutex ohne Timeouts und warten dann für immer auf die Mutex der anderen Aufgabe und schaffen eine zyklische Abhängigkeit. Das einfachste Totlock-Szenario tritt auf, wenn zwei Aufgaben abwechselnd zwei Mutex, aber in der entgegengesetzten Reihenfolge blockieren. Deadlock wird durch sorgfältiges Design verhindert. Nachrichtenübermittlung Der andere Ansatz zur Ressourcenteilung ist für Aufgaben, Nachrichten in einem organisierten Nachrichtenübermittlungsprogramm zu senden. In diesem Paradigma wird die Ressource direkt von nur einer Aufgabe verwaltet. Wenn eine andere Aufgabe die Ressource abfragen oder manipulieren möchte, sendet sie eine Nachricht an die Verwaltungsaufgabe. Obwohl ihr Echtzeit-Verhalten weniger scharf ist als Semaphore-Systeme, einfache Nachrichten-basierte Systeme vermeiden die meisten Protokoll-Totlock-Gefahren, und sind im Allgemeinen besser verhalten als Semaphore-Systeme. Probleme wie solche von Semaphoren sind jedoch möglich. Vorrangige Inversion kann auftreten, wenn eine Aufgabe an einer niederprioritären Nachricht arbeitet und eine höherprioritätsbezogene Nachricht (oder eine indirekt von einer hohen Prioritätsaufgabe stammende Nachricht) in ihrer eingehenden Nachrichtenwarte ignoriert. Protokoll-Totlocks können auftreten, wenn zwei oder mehr Aufgaben aufeinander warten, um Antwortnachrichten zu senden. Interrupt-Handler und Scheduler Da ein Interrupt-Handler die höchste Prioritätsaufgabe vom Laufen blockiert, und da Echtzeit-Betriebssysteme ausgelegt sind, um die Fadenlattenz auf ein Minimum zu halten, werden Interrupt-Handler typischerweise so kurz wie möglich gehalten. Der Interrupt-Handler deferiert alle Interaktion mit der Hardware, wenn möglich; typischerweise ist alles, was notwendig ist, um den Interrupt zu erkennen oder zu deaktivieren (so dass es nicht wieder auftritt, wenn der Interrupt-Handler zurückkehrt) und eine Aufgabe, die Arbeit muss getan werden. Dies kann geschehen, indem man eine Treiberaufgabe entsperrt, indem man eine Semaphore freigibt, eine Flagge setzt oder eine Nachricht sendet. Ein Scheduler bietet oft die Möglichkeit, eine Aufgabe aus dem Interrupt-Handler-Kontext zu entsperren. Ein OS hält Kataloge von Objekten, die es verwaltet, wie Threads, Mutexes, Speicher und so weiter. Aktualisierungen dieses Katalogs müssen streng kontrolliert werden. Aus diesem Grund kann es problematisch sein, wenn ein Interrupt-Handler eine OS-Funktion anruft, während die Anwendung in der Tat auch dies tut. Die von einem Interrupt-Handler aufgerufene OS-Funktion könnte aufgrund des Updates der Applikation die Objektdatenbank in einem inkonsistenten Zustand finden. Es gibt zwei große Ansätze, sich mit diesem Problem zu beschäftigen: die einheitliche Architektur und die segmentierte Architektur. RTOSs, die die einheitliche Architektur implementieren, lösen das Problem, indem sie Unterbrechungen einfach deaktivieren, während der interne Katalog aktualisiert wird. Der Nachteil davon ist, dass die Unterbrechung der Latenz zunimmt und möglicherweise Unterbrechungen zu verlieren. Die segmentierte Architektur macht keine direkten OS-Anrufe, sondern delegiert die OS-bezogene Arbeit an einem separaten Handler. Dieser Griff läuft mit einer höheren Priorität als jedes Gewinde, aber niedriger als die Interrupt-Handler. Der Vorteil dieser Architektur ist, dass es sehr wenige Zyklen zur Unterbrechung der Latenz hinzufügt. Dadurch sind Betriebssysteme, die die segmentierte Architektur implementieren, vorhersehbarer und können sich mit höheren Interruptraten im Vergleich zur einheitlichen Architektur auseinandersetzen. Ebenso kann der Systemmanagement-Modus auf x86 kompatiblen Hardware viel Zeit einnehmen, bevor er die Kontrolle auf das Betriebssystem zurückgibt. Die Speicherzuordnung Speicherzuweisung ist in einem Echtzeit-Betriebssystem kritischer als in anderen Betriebssystemen. Erstens kann es für die Stabilität keine Speicherlecks geben (Memory, die zugewiesen, aber nicht nach Gebrauch freigegeben wird). Das Gerät sollte unbestimmt arbeiten, ohne jemals einen Neustart benötigen. Aus diesem Grund wird die dynamische Speicherzuordnung auf eingeschaltet. Wann immer es möglich ist, wird alle erforderlichen Speicherzuordnungen statisch zu kompilieren Zeit vorgegeben. Ein weiterer Grund zur Vermeidung einer dynamischen Speicherzuordnung ist die Speicherfragmentierung. Bei häufiger Zuordnung und Freigabe kleiner Speicherblöcke kann es zu einer Situation kommen, in der verfügbarer Speicher in mehrere Abschnitte unterteilt ist und das RTOS nicht in der Lage ist, einen großen, zusammenhängenden Speicherblock zuzuordnen, obwohl es genügend Speicher gibt. Zweitens ist die Geschwindigkeit der Zuweisung wichtig. Ein Standardspeicherzuordnungsschema scannt eine verknüpfte Längenliste, um einen geeigneten freien Speicherblock zu finden, der in einem RTOS nicht akzeptabel ist, da die Speicherzuordnung innerhalb einer bestimmten Zeit erfolgen muss. Da mechanische Festplatten viel länger und unvorhersehbare Ansprechzeiten haben, wird das Swapping auf Festplattendateien nicht aus den gleichen Gründen wie die oben diskutierte RAM-Zuordnung verwendet. Der einfache Fest-Größe-Block-Algorithmus funktioniert für einfache eingebettete Systeme wegen seiner niedrigen Kopf.Siehe auch == Referenzen =Abortion Doping bezieht sich auf die gerüchte Praxis der gezielten Induktion der Schwangerschaft für sportliche Leistungssteigerung Vorteile, dann abbrechen die Schwangerschaft. Während in Bezug auf die Praxis Vorwürfe gemacht wurden, gibt es keinen Beweis, dass es jemals getan wurde. Potenzielle körperliche Vorteile Hormonelle und andere Veränderungen der Schwangerschaft beeinflussen die körperliche Leistung. In den ersten drei Monaten ist bekannt, dass der Körper einer Frau einen natürlichen Überschuss von roten Blutkörperchen produziert, die gut mit sauerstofftragenden Hämoglobin versorgt werden, um den wachsenden Fötus zu unterstützen. Andere potenzielle Vorteile ergeben sich aus dem Anstieg der Hormone, die Schwangerschaft induziert, überwiegend Progesteron und Östrogen, aber auch Testosteron, die Muskelkraft erhöhen könnte. Erhöhungen von Hormonen wie Relaxin, die die Hüftgelenke lockert, um sich auf die Geburt vorzubereiten, kann eine leistungssteigernde Wirkung auf die gemeinsame Mobilität haben. Es wird jedoch auch argumentiert, dass die Vorteile durch die Nachteile der Morgenkrankheit und Müdigkeit überwiegen würden, die beide in der frühen Schwangerschaft häufig sind. Anschuldigungen westliche Mediengeschäfte begannen, die sowjetischen Abtreibungsländer bereits in den Olympischen Sommerspielen 1956 zu beschuldigen, und Anschuldigungen wurden bei den Olympischen Spielen 1964 wieder erhoben. Die Gerüchte der Abtreibung Doping blieben in den 1970er und 1980er Jahren, vor allem auf ostdeutsche Athleten ausgerichtet. 1988 unterstützte Prinz Alexandre de Merode, dann Vizepräsident des Internationalen Olympischen Komitees (IOC), Geschichten, dass osteuropäische Athleten künstlich inseminiert wurden, um die sportliche Leistung zu steigern und dann zwei bis drei Monate später abzubrechen. Merode sagte, er kannte einen Schweizer Arzt, der das Verfahren durchführte; es war jedoch nie bewiesen. Im Jahr 1988 sagte der finnische Arzt Risto Erkola dem Sonntagsspiegel: "Jetzt, dass Drogentests Routine sind, wird die Schwangerschaft die bevorzugte Weise, einen Rand auf den Wettbewerb zu bekommen." Erkolas Kommentar wird häufig in Diskussionen über Abtreibung Doping zitiert. Laut der Fact-Checking-Website Snopes.com, Medienberichte nach dieser Behauptung waren skeptisch davon, und es gab keine Beweise, dass Erkola hatte eine erste Kenntnis der Praxis. Dr. Peter Larkins, damals ein Beamter der Australian Sports Medicine Association, forderte auch den Anspruch, obwohl Greg Whyte, Professor für angewandte Sport- und Übungswissenschaft an der Liverpool John Moores University, sagte, dass die ostdeutschen Behauptungen plausibel seien. Im Jahr 1994 wurde Olga Karasyova, der bei den Olympischen Sommerspielen 1968 eine Goldmedaille in Gymnastik gewann, berichtet, ein Interview mit dem deutschen Fernsehsender RTL Television sowie einer russischen Zeitung gegeben zu haben. Die Interviews zitierten sie als Hinweis, dass Abtreibung Doping unter sowjetischen Athleten in den 1970er Jahren weit verbreitet war, und dass Mädchen wie 14 wurden gezwungen, Sex mit ihren Trainern zu haben. Karasyova sagte aber später, dass die Person, die die Interviews gegeben hatte, ein Imposter sei, und sie erfolgreich die russische Zeitung für die Verleumdung verklagt. Trotz ihres Rechtssieges werden die Originalinterviews, die ihr zugeschrieben wurden, von einigen Dritten weiterhin als Fakten gemeldet. Ein 2017 Artikel von Snopes.com categorises abortion doping as unproven, zu dem Schluss, dass die Praxis nur durch das zweifelhafte Interview mit Karasyova bestätigt wird, ist "abgefragt von spekulativer Wissenschaft, und werden in den letzten Jahren von Antiaborationsgruppen weitgehend verstärkt". Snopes beschuldigen Anti-Abtreibungsgruppen der selektiven Berichterstattung und die Verwendung schlecht abgeleiteter Argumente beim Schreiben von Artikeln über das Thema. Mehrere Quellen haben geschlossen, es gibt keinen Beweis, dass Abtreibung Doping jemals tatsächlich getan wurde. Recht Während Abtreibung Doping offiziell unter den Olympischen Regeln der Vereinigten Staaten verboten ist, gibt es kein Verbot, schwanger zu werden. Wenn ein Athlet der Abtreibung Doping beschuldigt wurde, könnte sie einfach argumentieren, dass die Schwangerschaft nicht für die vorübergehenden physiologischen Vorteile induziert wurde. Das Verfahren wurde nicht vom IOC verboten. Siehe auch Blut Doping == Referenzen ==