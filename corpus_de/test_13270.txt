Bei der Berechnung ist eine virtuelle Maschine (VM) die Virtualisierung/Emulation eines Computersystems. Virtuelle Maschinen basieren auf Computerarchitekturen und bieten Funktionalität eines physischen Computers. Ihre Implementierungen können spezialisierte Hardware, Software oder eine Kombination umfassen. Virtuelle Maschinen unterscheiden sich und werden von ihrer Funktion organisiert, hier gezeigt: System virtuelle Maschinen (auch als Vollvirtualisierung VMs bezeichnet) bieten einen Ersatz für eine reale Maschine. Sie bieten Funktionen, die zur Ausführung von gesamten Betriebssystemen benötigt werden. Ein Hypervisor verwendet native Ausführung, um Hardware zu teilen und zu verwalten, so dass mehrere Umgebungen, die voneinander isoliert sind, aber auf der gleichen physischen Maschine existieren. Moderne Hypervisors verwenden hardwaregestützte Virtualisierung, virtualisierungsspezifische Hardware, vor allem aus den Host-CPUs. Prozessvirtuelle Maschinen sind dazu ausgelegt, Computerprogramme in einer plattformunabhängigen Umgebung auszuführen. Einige virtuelle Computer-Emulatoren, wie QEMU und Videospiel-Konsolen-Emulatoren, sind entworfen, um auch (oder "virtually imitate") verschiedene Systemarchitekturen zu emulieren, so dass die Ausführung von Software-Anwendungen und Betriebssystemen für eine andere CPU oder Architektur geschrieben. Die Virtualisierung auf Betriebssystemebene ermöglicht die Aufteilung der Ressourcen eines Computers über den Kernel. Die Begriffe sind nicht universell austauschbar. Definitionen System virtuelle Maschinen Eine "virtuelle Maschine" wurde ursprünglich von Popek und Goldberg als "ein effizientes, isoliertes Duplikat einer realen Computermaschine" definiert. Die aktuelle Nutzung umfasst virtuelle Maschinen, die keine direkte Korrespondenz zu jeder realen Hardware haben. Die physische, reale Hardware mit dem VM wird im Allgemeinen als Host bezeichnet, und die auf dieser Maschine emulierte virtuelle Maschine wird im Allgemeinen als Gast bezeichnet.Ein Host kann mehrere Gäste emulieren, von denen jeder verschiedene Betriebssysteme und Hardwareplattformen emulieren kann. Der Wunsch, mehrere Betriebssysteme zu betreiben, war das erste Motiv für virtuelle Maschinen, um eine zeitliche Aufteilung unter mehreren Eintasking-Betriebssystemen zu ermöglichen. In gewisser Hinsicht kann eine System-Virtual-Maschine als eine Verallgemeinerung des Konzepts des virtuellen Speichers angesehen werden, das ihm historisch voranging. IBMs CP/CMS, die ersten Systeme, um eine vollständige Virtualisierung zu ermöglichen, implementierte Zeitfreigabe, indem jedem Benutzer ein einzelnes Betriebssystem, das Conversational Monitor System (CMS) zur Verfügung gestellt wird. Im Gegensatz zu virtuellem Speicher, ein System virtuelle Maschine berechtigt, den Benutzer zu schreiben privilegierte Anweisungen in ihrem Code. Dieser Ansatz hatte gewisse Vorteile, wie z.B. das Hinzufügen von Ein-/Ausgabegeräten, die vom Standardsystem nicht zugelassen sind. Da die Technologie virtuelle Speicher für Zwecke der Virtualisierung entwickelt, können neue Systeme der Speicherüberkommitment verwendet werden, um Speicherfreigabe unter mehreren virtuellen Maschinen auf einem Computer-Betriebssystem zu verwalten. Es kann möglich sein, Speicherseiten zu teilen, die identische Inhalte unter mehreren virtuellen Maschinen haben, die auf der gleichen physischen Maschine laufen, was dazu führen kann, dass sie auf die gleiche physische Seite durch eine Technik namens Kernel gleichseitiges Merging (KSM) abgebildet werden. Dies ist insbesondere für nur lesbare Seiten, wie z.B. solche, die Codesegmente halten, nützlich, was für mehrere virtuelle Maschinen mit gleicher oder ähnlicher Software, Softwarebibliotheken, Webserver, Middleware-Komponenten etc. der Fall ist. Die Gast-Betriebssysteme müssen nicht mit der Host-Hardware konform sein, so dass es möglich ist, verschiedene Betriebssysteme auf demselben Computer (z.B. Windows, Linux oder vorherige Versionen eines Betriebssystems) auszuführen, um zukünftige Software zu unterstützen. Die Verwendung von virtuellen Maschinen zur Unterstützung separater Gastbetriebssysteme ist in Bezug auf eingebettete Systeme beliebt. Eine typische Verwendung wäre, ein Echtzeit-Betriebssystem gleichzeitig mit einem bevorzugten komplexen Betriebssystem wie Linux oder Windows zu betreiben. Eine weitere Verwendung wäre für neue und nicht bewährte Software noch in der Entwicklungsphase, so dass es innerhalb einer Sandbox läuft. Virtuelle Maschinen haben andere Vorteile für die Betriebssystementwicklung und können einen verbesserten Debugging-Zugang und schnellere Neustarts beinhalten. Mehrere VMs, die ein eigenes Gast-Betriebssystem betreiben, werden häufig für die Serverkonsolidierung engagiert. Prozess virtuelle Maschinen Ein Prozess VM, manchmal als Anwendung virtuelle Maschine oder Managed Runtime Environment (MRE,) läuft als normale Anwendung in einem Host-Betriebssystem und unterstützt einen einzigen Prozess. Es wird erstellt, wenn dieser Prozess gestartet und zerstört wird, wenn er austritt. Ziel ist es, eine plattformunabhängige Programmierumgebung bereitzustellen, die Details der zugrunde liegenden Hardware oder Betriebssysteme abstrahiert und ein Programm auf jeder Plattform in gleicher Weise ausführen lässt. Ein Prozess VM liefert eine hochrangige Abstraktion – die einer hochrangigen Programmiersprache (im Vergleich zur niedrigrangigen ISA-Abstraktion des Systems VM). Prozess-VMs werden mit einem Dolmetscher implementiert; Leistung vergleichbar mit kompilierten Programmiersprachen kann durch die Verwendung von Just-in-time-Compilation erreicht werden. Diese Art von VM ist mit der Java-Programmiersprache populär geworden, die mit der Java-Virtual-Maschine implementiert wird. Weitere Beispiele sind die virtuelle Maschine Parrot und das .NET Framework, das auf einem VM namens Common Language Runtime läuft. Alle können als Abstraktionsschicht für jede Computersprache dienen. Ein besonderer Fall von Prozess-VMs sind Systeme, die über die Kommunikationsmechanismen eines (potentiell heterogenen) Computer-Clusters abstrahieren. Ein solcher VM besteht nicht aus einem einzigen Prozess, sondern aus einem Prozess pro physikalischer Maschine im Cluster. Sie sind darauf ausgelegt, die Aufgabe zu erleichtern, gleichzeitige Anwendungen zu programmieren, indem der Programmierer sich auf Algorithmen anstatt auf die Kommunikationsmechanismen, die durch die Verbindung und das Betriebssystem bereitgestellt werden, konzentrieren lässt. Sie verbergen nicht die Tatsache, dass die Kommunikation stattfindet, und versuchen als solche nicht, den Cluster als eine einzige Maschine darzustellen. Im Gegensatz zu anderen Prozess-VMs bieten diese Systeme keine spezifische Programmiersprache, sondern sind in eine bestehende Sprache eingebettet; typischerweise bietet ein solches System Bindungen für mehrere Sprachen (z.B. C und Fortran). Beispiele sind Parallel Virtual Machine (PVM) und Message Passing Interface (MPI). Sie sind nicht streng virtuelle Maschinen, da die oben laufenden Anwendungen immer noch Zugriff auf alle OS-Dienste haben und daher nicht auf das Systemmodell beschränkt sind. Geschichte Beide System virtuelle Maschinen und Prozess virtuelle Maschinen Datum bis in die 1960er Jahre und weiterhin Bereiche der aktiven Entwicklung sein. Systemvirtuelle Maschinen wuchsen aus der Zeitverteilung, wie insbesondere im kompatiblen Time-Sharing System (CTSS) implementiert. Zeit-Sharing erlaubte mehreren Benutzern gleichzeitig einen Computer zu verwenden: Jedes Programm schien vollen Zugriff auf die Maschine, aber nur ein Programm wurde zur Zeit ausgeführt, mit dem System schalten zwischen Programmen in Zeitscheiben, speichern und Wiederherstellen Zustand jedes Mal. Dies entwickelte sich zu virtuellen Maschinen, insbesondere über IBM-Forschungssysteme: die M44/44X, die eine partielle Virtualisierung verwendet, und die CP-40 und SIMMON, die eine vollständige Virtualisierung nutzten, und waren frühe Beispiele für Hypervisoren. Die erste weit verbreitete virtuelle Maschinenarchitektur war das CP-67/CMS (siehe Geschichte von CP/CMS für Details). Eine wichtige Unterscheidung war, wie in M44/44X und CP-40 mehrere virtuelle Maschinen auf einem Host-System zur Zeitverteilung zu verwenden, und eine virtuelle Maschine auf einem Host-System zum Prototyping zu verwenden, wie in SIMMON. Emulatoren, mit Hardware-Emulation früherer Systeme für Kompatibilität, gehen 1963 auf das IBM System/360 zurück, während die Software-Emulation (then-genannte Simulation) es vorschreibt. Prozessvirtuelle Maschinen entstanden ursprünglich als abstrakte Plattformen für eine Zwischensprache, die als Zwischendarstellung eines Programms von einem Compiler verwendet wird; frühe Beispiele reichen bis etwa 1966 aus. Ein frühes 1966 Beispiel war die O-Code-Maschine, eine virtuelle Maschine, die O-Code (Objektcode) ausführt, die vom vorderen Ende des BCPL-Compilers ausgegeben wird. Diese Abstraktion erlaubte es dem Compiler, leicht zu einer neuen Architektur zu portieren, indem er ein neues Back-Ende implementierte, das den bestehenden O-Code nahm und ihn zum Maschinencode für die zugrunde liegende physikalische Maschine kompilierte. Die Euler-Sprache verwendet ein ähnliches Design, mit der Zwischensprache namens P (portable). Dies wurde um 1970 von Pascal, insbesondere im Pascal-P-System (1973) und Pascal-S-Compiler (1975) populär, in dem es als p-Code und die resultierende Maschine als p-Code-Maschine bezeichnet wurde. Dies ist einflussreich und virtuelle Maschinen in diesem Sinne wurden oft als p-Code-Maschinen bezeichnet. Neben einer Zwischensprache wurde Pascal p-Code auch direkt von einem Dolmetscher ausgeführt, der die virtuelle Maschine implementiert, insbesondere in UCSD Pascal (1978); dies beeinflusste spätere Interpreten, insbesondere die Java virtuelle Maschine (JVM). Ein weiteres frühes Beispiel war SNOBOL4 (1967), das in der SNOBOL Implementation Language (SIL) eine Montagesprache für eine virtuelle Maschine geschrieben wurde, die dann auf physische Maschinen ausgerichtet war, indem sie über einen Makro-Assembler in ihren nativen Assembler transpiliert wurde. Macros sind seitdem aus Gefallen, so dass dieser Ansatz weniger einflussreich war. Prozessvirtuelle Maschinen waren ein beliebter Ansatz zur Implementierung von frühen Mikrocomputer-Software, einschließlich Tiny BASIC und Adventure-Spiele, von einmaligen Implementierungen wie Pyramid 2000 bis zu einer Universal-Engine wie Infocom z-Maschine, die Graham Nelson argumentiert, ist "möglicherweise die tragbareste virtuelle Maschine jemals geschaffen". Wesentliche Fortschritte bei der Umsetzung von Smalltalk-80, insbesondere der Deutsch/Schiffmann-Implementierung, die die just-in-time (JIT)-Compilation als Implementierungsansatz vorangetrieben hat, der die virtuelle Prozessmaschine nutzt. Später bemerkenswerte Smalltalk VMs waren VisualWorks, die Squeak Virtual Machine und Strongtalk. Eine verwandte Sprache, die eine Menge virtuelle Maschineninnovation produzierte, war die Selbstprogrammiersprache, die eine adaptive Optimierung und Generationen Müllsammlung voranbrachte. Diese Techniken erwiesen sich 1999 im HotSpot Java Virtual Machine als kommerziell erfolgreich. Andere Neuerungen umfassen eine auf Register basierende virtuelle Maschine, um besser auf die zugrunde liegende Hardware zu passen, anstatt eine stapelbasierte virtuelle Maschine, die eine nähere Übereinstimmung mit der Programmiersprache ist; 1995 wurde dies von der virtuellen Maschine Dis für die Limbo Sprache Pionier. OpenJ9 ist eine Alternative für HotSpot JVM in OpenJDK und ist ein Open Source-Eclipse-Projekt, das ein besseres Startup und weniger Ressourcenverbrauch im Vergleich zu HotSpot fordert. Volle Virtualisierung In der vollen Virtualisierung simuliert die virtuelle Maschine genügend Hardware, um ein unmodifiziertes Gäste-Betriebssystem (eines für denselben Befehlssatz ausgelegt) isoliert laufen zu lassen. Dieser Ansatz wurde 1966 mit den IBM CP-40 und CP-67, Vorgängern der VM-Familie, vorangetrieben. Beispiele außerhalb des Mainframe-Feldes sind Parallels Workstation, Parallels Desktop for Mac, VirtualBox, Virtual Iron, Oracle VM, Virtual PC, Virtual Server, Hyper-V, VMware Workstation, VMware Server (discontinued, früher GSX Server genannt), VMware ESXi, QEMU, Adeos, Mac-on-Linux, Win4BSD, Win4Lin Pro und EV Technologie. Hardwaregestützte Virtualisierung In der hardwaregestützten Virtualisierung bietet die Hardware einen architektonischen Support, der den Aufbau eines virtuellen Maschinenmonitors erleichtert und den Gast OSes in Isolation ermöglicht. Hardwaregestützte Virtualisierung wurde 1972 erstmals auf dem IBM System/370 vorgestellt, für den Einsatz mit VM/370, dem ersten virtuellen Maschinenbetriebssystem von IBM als offizielles Produkt. In den Jahren 2005 und 2006 lieferten Intel und AMD zusätzliche Hardware zur Unterstützung der Virtualisierung. Sun Microsystems (jetzt Oracle Corporation) fügte 2005 ähnliche Features in ihren UltraSPARC T-Serie Prozessoren hinzu. Beispiele für an diese Hardware angepasste Virtualisierungsplattformen sind KVM, VMware Workstation, VMware Fusion, Hyper-V, Windows Virtual PC, Xen, Parallels Desktop for Mac, Oracle VM Server for SPARC, VirtualBox und Parallels Workstation. Im Jahr 2006 wurde die Hardware-Unterstützung der ersten Generation 32- und 64-Bit x86 kaum Leistungsvorteile gegenüber der Softwarevirtualisierung bieten. Virtualisierung auf Betriebssystemebene Bei der Virtualisierung auf Betriebssystemebene wird ein physischer Server auf der Ebene des Betriebssystems virtualisiert, wodurch mehrere isolierte und sichere virtualisierte Server auf einem einzigen physischen Server ausgeführt werden können. Die Gast-Betriebssystemumgebungen teilen die gleiche laufende Instanz des Betriebssystems wie das Host-System. So wird auch derselbe Betriebssystemkern zur Umsetzung der Gastumgebungen verwendet, und Anwendungen, die in einer bestimmten Gastumgebung laufen, sehen es als eigenständiges System an. Die Pionier-Implementierung war FreeBSD Gefängnisse; andere Beispiele sind Docker, Solaris Containers, OpenVZ, Linux-VServer, LXC, AIX Workload Partitions, Parallels Virtuozzo Containers und iCore Virtual Accounts. Weiter lesen James E. Smith, Ravi Nair, Virtuelle Maschinen: Vielseitige Plattformen für Systeme und Prozesse, Morgan Kaufmann, Mai 2005, ISBN 1-55860-910-5, 656 Seiten (entdeckt sowohl Prozess- als auch Systemvirtuelle Maschinen) Craig, Iain D. Virtuelle Maschinen. Springer, 2006, ISBN 1-85233-969-1, 269 Seiten (verdeckt nur virtuelle Maschinen) Externe Links Mendel Rosenblum (2004-08-31). "Die Reinkarnation von virtuellen Maschinen". ACM Queue. Vol.2 Nr. 5.Sandia National Laboratories führt 1 Million Linux Kernels als virtuelle Maschinen Das Design der Inferno virtuelle Maschine von Phil Winterbottom und Rob Pike