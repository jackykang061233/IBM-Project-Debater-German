Softwarebau ist eine Software-Engineering-Disziplin. Es ist die detaillierte Erstellung von aussagekräftiger Software durch eine Kombination von Codierung, Verifikation, Einheitstests, Integrationstests und Debugging. Es ist mit allen anderen Software-Engineering-Disziplinen verbunden, am stärksten mit Software-Design und Software-Tests. Grundlagen des Softwarebaus Minimierung der Komplexität Die Notwendigkeit, die Komplexität zu reduzieren, wird hauptsächlich durch begrenzte Fähigkeit der meisten Menschen, komplexe Strukturen und Informationen in ihren Arbeitsspeichern zu halten angetrieben. Verringerte Komplexität wird durch die Betonung der Erstellung von Code erreicht, der einfach und lesbar anstatt clever ist. Die Minimierung der Komplexität erfolgt durch den Einsatz von Standards und durch zahlreiche spezifische Techniken in der Codierung. Es wird auch durch die konstruktionsorientierten Qualitätstechniken unterstützt. Anticipating change Anticipating change hilft Software-Ingenieuren, extensible Software aufzubauen, was bedeutet, dass sie ein Software-Produkt verbessern können, ohne die zugrunde liegende Struktur zu stören. Die Forschung über 25 Jahre ergab, dass die Kosten für die Nacharbeit 10 bis 100 mal (5 bis 10 mal für kleinere Projekte) teurer sein können als die Anforderungen zum ersten Mal richtig zu bekommen. Angesichts der Tatsache, dass sich 25 % der Anforderungen während der Entwicklung im durchschnittlichen Projekt ändern, besteht die Notwendigkeit, die Kosten für die Arbeit zu reduzieren, um die Notwendigkeit einer vorausschauenden Veränderung zu vermeiden. Konstrukt für die Überprüfung Die Konstruktion für die Verifikation bedeutet, Software so zu bauen, dass Fehler von den Software-Ingenieuren, die die Software schreiben, sowie bei unabhängigen Tests und operativen Aktivitäten leicht ausgetragen werden können. Spezifische Techniken, die das Konstrukt für die Überprüfung unterstützen, umfassen folgende Kodierungsstandards, um Code-Reviews zu unterstützen, Code zu organisieren, um automatisierte Tests zu unterstützen, und die eingeschränkte Verwendung komplexer oder schwer zu verstehender Sprachstrukturen, unter anderem. Reuse Systematic Wiederverwendung kann erhebliche Software Produktivität, Qualität und Kostenverbesserungen ermöglichen. Reuse hat zwei eng verwandte Facetten: Bau für Wiederverwendung: Erstellen Sie wiederverwendbare Software-Assets. Bau mit Wiederverwendung: Wiederverwenden von Software-Assets beim Bau einer neuen Lösung. Standards in Konstruktionsstandards, ob extern (von internationalen Organisationen erstellt) oder intern (auf Unternehmensebene erstellt), die sich direkt auf Baufragen auswirken, umfassen: Kommunikationsmethoden: Wie Standards für Dokumentformate und Inhalte. Programmiersprachen Kodierungsstandards Plattformen Tools: Wie schematische Standards für Notationen wie UML. Konstruktionsmodell verwalten Zahlreiche Modelle wurden entwickelt, um Software zu entwickeln, von denen einige den Bau mehr als andere betonen. Einige Modelle sind linearer aus der Konstruktion, wie die Wasserfall- und Inszenierung Lebenszyklusmodelle. Diese Modelle behandeln den Bau als eine Tätigkeit, die erst nach der Fertigstellung der wesentlichen Voraussetzungen erfolgt – einschließlich detaillierter Anforderungen, umfangreicher Designarbeit und detaillierter Planung. Andere Modelle sind iterativ, wie evolutionäre Prototyping, Extreme Programming und Scrum. Diese Ansätze neigen dazu, die Konstruktion als Aktivität zu behandeln, die gleichzeitig mit anderen Software-Entwicklungsaktivitäten auftritt, einschließlich Anforderungen, Design und Planung oder Überschneidungen. Bauplanung Die Wahl des Bauverfahrens ist ein wesentlicher Aspekt der Bauplanungstätigkeit. Die Wahl der Konstruktionsmethode beeinflusst das Ausmaß, in dem Konstruktionsvoraussetzungen (z.B. Anforderungsanalyse, Software-Design,... etc.) durchgeführt werden, die Reihenfolge, in der sie ausgeführt werden, und den Grad, in dem sie erwartet werden, vor der Bauarbeiten abgeschlossen werden. Die Bauplanung definiert auch die Reihenfolge, in der Komponenten erstellt und integriert werden, die Software-Qualitätsmanagementprozesse, die Zuordnung von Aufgabenzuweisungen zu bestimmten Software-Ingenieuren und die anderen Aufgaben nach dem gewählten Verfahren. Konstruktionsmessung Zahlreiche Bauaktivitäten und Artefakte können gemessen werden, einschließlich Code entwickelt, Code geändert, Code wiederverwendet, Code zerstört, Code-Komplexität, Code-Inspektionsstatistik, Fehler- und Fehlersuche-Raten, Aufwand und Terminierung. Diese Messungen können nützlich sein, um Konstruktion zu verwalten, Qualität während des Baus zu gewährleisten, den Bauprozess zu verbessern sowie aus anderen Gründen. Praktische Überlegungen Der Softwarebau wird von vielen praktischen Überlegungen angetrieben: Baugewerbe Um den unvorhergesehenen Lücken im Softwaredesign Rechnung zu tragen, müssen bei der Software-Konstruktion einige Design-Modifikationen in kleinerem oder größerem Maßstab vorgenommen werden, um Details des Software-Designs auszuschließen. Low Fan-out ist eine der Design-Charakteristiken, die von Forschern als nützlich erachtet werden. Informationsverbergung erwies sich als nützliche Design-Technik in großen Programmen, die sie einfacher zu modifizieren um den Faktor 4. Bausprachen Bausprachen umfassen alle Kommunikationsformen, mit denen ein Mensch eine ausführbare Problemlösung an einen Computer angeben kann. Dazu gehören Konfigurationssprachen, Toolkitsprachen und Programmiersprachen: Konfigurationssprachen sind Sprachen, in denen Software-Ingenieure aus einem begrenzten Satz von vordefinierten Optionen wählen, um neue oder benutzerdefinierte Software-Installationen zu erstellen. Toolkit-Sprachen werden verwendet, um Anwendungen aus Toolkits zu erstellen und sind komplexer als Konfigurationssprachen. Scripting-Sprachen sind Arten von Anwendung Programmiersprachen, die Skripte unterstützt, die oft interpretiert werden, anstatt kompiliert. Programmiersprachen sind die flexibelsten Bausprachen, die drei allgemeine Arten von Notation verwenden: Linguistische Notationen, die sich insbesondere durch die Verwendung von wortartigen Textsträngen auszeichnen, um komplexe Software-Konstruktionen darzustellen, und die Kombination solcher wortähnlichen Strings zu Mustern, die eine satzartige Syntax aufweisen. Formale Notationen, die weniger auf intuitive, alltägliche Bedeutungen von Wörtern und Textstrings und mehr auf Definitionen stützen, die durch präzise, eindeutige und formale (oder mathematische) Definitionen unterstützt werden. Visuelle Notationen, die weniger auf die textorientierten Begriffe des sprachlichen und formalen Aufbaus angewiesen sind, sondern auf die direkte visuelle Interpretation und Platzierung von visuellen Wesen, die die zugrunde liegende Software repräsentieren. Programmierer arbeiten in einer Sprache, die sie seit drei Jahren oder mehr verwendet haben, sind etwa 30 Prozent produktiver als Programmierer mit gleichwertiger Erfahrung, die neu auf eine Sprache sind. Hochrangige Sprachen wie C,+ Java, Smalltalk und Visual Basic Ertrag 5 bis 15 mal bessere Produktivität, Zuverlässigkeit, Einfachheit und Verständlichkeit als Low-Level-Sprachen wie Montage und C. Equivalent-Code wurde gezeigt, dass weniger Zeilen in High-Level-Sprachen implementiert werden müssen als in niedrigeren Sprachen. Kodierung Für die Software-Baucodierungsaktivität gelten folgende Überlegungen: Techniken zur Erstellung verständlicher Quellcodes, einschließlich Namens- und Quellcode-Layout. Eine Studie zeigte, dass der Aufwand für die Debug eines Programms minimiert wird, wenn die Variablen Namen zwischen 10 und 16 Zeichen sind. Verwendung von Klassen, aufgezählten Typen, Variablen, benannten Konstanten und anderen ähnlichen Einheiten: Eine von der NASA durchgeführte Studie zeigte, dass das Setzen des Codes in gut bewertete Klassen die Wiederverwendbarkeit des Codes im Vergleich zu dem Code, der mit funktionalem Design entwickelt wurde, verdoppeln kann. Ein Experiment zeigte, dass Designs, die auf Arrays sequentiell zugreifen, anstatt zufällig, weniger Variablen und weniger variable Referenzen ergeben. Verwendung von Kontrollstrukturen: Ein Experiment fand heraus, dass Schleifen-mit-Ausgang verständlicher sind als andere Arten von Schleifen. In Bezug auf das Nistniveau in Schlingen und Conditionals haben Studien gezeigt, dass Programmierer Schwierigkeiten haben, mehr als drei Ebenen der Nistung zu erfassen. Die Komplexität des Steuerflusses wurde gezeigt, um mit geringer Zuverlässigkeit und häufigen Fehlern zu korrelieren. Umgang mit Fehlerbedingungen – ebenso wie geplante Fehler und Ausnahmen (Eingabe von schlechten Daten zum Beispiel) Vermeidung von Code-Level-Sicherheitsverletzungen (Puffer-Überläufe oder Array-Index-Überläufe, zum Beispiel) Ressourcennutzung durch Nutzung von Ausschlussmechanismen und Disziplin beim Zugriff auf seriell wiederverwendbare Ressourcen (einschließlich Threads oder Datenbankschlösser) Quelle Code Organisation (in Aussagen und Routinen): Hochkohäsive Routinen erwiesen sich als weniger Fehler anfällig als Routinen mit geringerer Kohäsion. Eine Studie von 450 Routinen ergab, dass 50 Prozent der hochkohäsiven Routinen fehlerfrei waren im Vergleich zu nur 18 Prozent der Routinen mit geringem Zusammenhalt. Eine weitere Studie von verschiedenen 450 Routinen ergab, dass Routinen mit den höchsten Koppel-Kohäsion-Verhältnissen 7 mal so viele Fehler wie jene mit den niedrigsten Koppel-Kohäsion-Verhältnissen und waren 20 mal so teuer zu fixieren. Obwohl Studien unschlüssige Ergebnisse hinsichtlich der Korrelation zwischen Routinegrößen und der Fehlerrate in ihnen zeigten, fand eine Studie, dass Routinen mit weniger als 143 Zeilen Code 2,4 mal weniger teuer waren, um zu beheben als größere Routinen. Eine weitere Studie ergab, dass der Code, der am wenigsten geändert werden musste, wenn Routinen durchschnittlich 100 bis 150 Zeilen Code. Eine weitere Studie ergab, dass strukturelle Komplexität und Datenmenge in einer Routine mit Fehlern unabhängig von ihrer Größe korreliert wurden. Schnittstellen zwischen Routinen sind einige der fehleranfälligsten Bereiche eines Programms. Eine Studie ergab, dass 39 Prozent aller Fehler Fehler in der Kommunikation zwischen Routinen waren. Ungenutzte Parameter werden mit einer erhöhten Fehlerrate korreliert. In einer Studie hatten nur 17 bis 29 Prozent der Routinen mit mehr als einer unreferenzierten Variablen keine Fehler, verglichen mit 46 Prozent in Routinen ohne ungenutzte Variablen. Die Anzahl der Parameter einer Routine sollte maximal 7 sein, da die Forschung festgestellt hat, dass die Menschen in der Regel nicht mehr als etwa sieben Informationsblöcke auf einmal verfolgen können. Quelle Code Organisation (in Klassen, Pakete oder andere Strukturen.) Bei der Prüfung der Eindämmung sollte die maximale Anzahl der Datenmitglieder in einer Klasse 7±2 nicht überschreiten. Die Forschung hat gezeigt, dass diese Zahl die Anzahl der diskreten Gegenstände ist, an die sich eine Person bei der Durchführung anderer Aufgaben erinnern kann. Bei der Betrachtung der Erbschaft sollte die Anzahl der Ebenen im Erbschaftsbaum begrenzt werden. Die tiefen Erbschaftsbäume haben sich als wesentlich mit erhöhten Fehlerquoten verbunden erwiesen. Bei der Betrachtung der Anzahl der Routinen in einer Klasse sollte es so klein wie möglich gehalten werden. Eine Studie über C+-Programme hat eine Assoziation zwischen der Anzahl der Routinen und der Anzahl der Fehler gefunden. Codedokumentation Code Tuning Bauprüfung Zweck der Konstruktionsprüfung ist es, den Abstand zwischen dem Zeitpunkt, zu dem Fehler in den Code eingefügt werden, und dem Zeitpunkt, zu dem diese Fehler erkannt werden, zu verringern. In einigen Fällen wird die Konstruktionsprüfung nach der Erstellung des Codes durchgeführt. In der Test-First-Programmierung werden Testfälle erstellt, bevor Code geschrieben wird. Der Bau umfasst zwei Testformen, die oft von dem Software-Ingenieur ausgeführt werden, der den Code geschrieben hat: Integrationstests Wiederverwendung von Implementierungssoftware erfordert mehr als die Erstellung und Nutzung von Bibliotheken von Vermögenswerten. Es erfordert die Formalisierung der Praxis der Wiederverwendung durch Integration von Wiederverwendungsprozessen und Aktivitäten in den Softwarelebenszyklus. Die Aufgaben im Zusammenhang mit der Wiederverwendung im Softwarebau bei der Codierung und Prüfung sind: Die Auswahl der wiederverwendbaren Einheiten, Datenbanken, Testverfahren oder Testdaten. Die Bewertung der Code- oder Test-Re-Usability. Die Meldung von Wiederverwendungsinformationen über neue Code-, Test- oder Testdaten. Bauqualität Die wichtigsten Techniken, die verwendet werden, um die Qualität des Codes zu gewährleisten, wie es gebaut wird, umfassen: Gerätetests und Integrationstests. Eine Studie ergab, dass die durchschnittlichen Defekt-Erkennungsraten der Einheitstests und Integrationstests 30% bzw. 35% betragen. Erste Entwicklung Verwendung von Behauptungen und defensive Programmierung Debugging Inspections. Eine Studie ergab, dass die durchschnittliche Fehlererkennungsrate von formalen Codeinspektionen 60% beträgt. In Bezug auf die Kosten der Fehlersuche ergab eine Studie, dass die Codelesung 80% mehr Fehler pro Stunde als die Prüfung erkannte. Eine weitere Studie ergab, dass sie sechsmal mehr kostet, um Konstruktionsfehler durch Testen zu erkennen als durch Inspektionen. Eine Studie von IBM zeigte, dass nur 3,5 Stunden, wo ein Defekt durch Code-Inspektionen über 15–25 Stunden durch Tests gefunden werden musste. Microsoft hat festgestellt, dass es 3 Stunden dauert, um einen Defekt zu finden und zu beheben, indem Code-Inspektionen und 12 Stunden, um einen Defekt durch Testen zu finden und zu beheben. In einem 700mila Linien-Programm wurde berichtet, dass Code-Rezensionen mehrere Male so kostengünstig wie Tests waren. Untersuchungen ergaben, dass Inspektionen zu 20% führen - 30% weniger Fehler pro 1000 Codezeilen als weniger formale Überprüfungspraktiken und dass sie die Produktivität um etwa 20 % erhöhen Formale Inspektionen werden in der Regel 10% - 15% des Projektbudgets nehmen und die Gesamtprojektkosten senken. Forscher fanden heraus, dass mit mehr als 2 - 3 Prüfern auf einer formalen Inspektion die Anzahl der festgestellten Mängel nicht erhöht, obwohl die Ergebnisse je nach Art des untersuchten Materials variieren scheinen. Technische Bewertungen. Eine Studie ergab, dass die durchschnittlichen Defekt-Erkennungsraten von informellen Code-Bewertungen und Schreibtisch-Überprüfungen 25% bzw. 40% betragen. Durchgänge wurden gefunden, dass eine Defekt-Erkennungsrate von 20% - 40,%, aber wurden auch als teuer, besonders wenn Projektdrucke erhöhen. Die Codelesung wurde von der NASA gefunden, um 3,3 Defekte pro Stunde der Anstrengung gegenüber 1,8 Defekten pro Stunde zu prüfen. Es findet auch 20% - 60% mehr Fehler über die Lebensdauer des Projekts als verschiedene Arten von Tests. Eine Studie von 13 Überprüfungen über Überprüfungssitzungen ergab, dass 90 % der Mängel in Vorbereitung auf die Überprüfungssitzung gefunden wurden, während während der Sitzung nur rund 10 % gefunden wurden. Statische Analyse (IEEE1028)Studien haben gezeigt, dass eine Kombination dieser Techniken verwendet werden muss, um eine hohe Defekterkennungsrate zu erreichen. Andere Studien zeigten, dass verschiedene Menschen neigen, verschiedene Mängel zu finden. Eine Studie ergab, dass die Extreme Programming-Praktiken von Paarprogrammierung, Schreibtischkontrolle, Einheitstests, Integrationstests und Regressionstests eine 90%ige Fehlererkennungsrate erreichen können. Ein Experiment mit erfahrenen Programmierern fand heraus, dass sie im Durchschnitt 5 Fehler (9 bestenfalls) aus 15 Fehlern durch Tests finden konnten. 80% der Fehler sind in 20% der Klassen und Routinen des Projekts konzentriert. 50% der Fehler finden sich in 5% der Projektklassen. IBM war in der Lage, den Kunden gemeldete Mängel um einen Faktor von zehn auf einen zu reduzieren und ihre Wartungsbudget um 45 % in seinem IMS-System durch Reparatur oder Neubestellung nur 31 von 425 Klassen zu reduzieren. Rund 20% der Projektroutinen tragen zu 80% der Entwicklungskosten bei. Eine klassische Studie von IBM ergab, dass wenige fehleranfällige Routinen von OS/360 die teuersten Einheiten waren. Sie hatten rund 50 Defekte pro 1000 Codezeilen und sie zu fixieren Kosten 10 mal, was es brauchte, um das gesamte System zu entwickeln. Integration Eine wesentliche Aktivität während des Baus ist die Integration von separat aufgebauten Routinen, Klassen, Komponenten und Subsystemen. Darüber hinaus muss ein bestimmtes Softwaresystem mit anderen Software- oder Hardwaresystemen integriert werden. Zu den Fragen der Bauintegration gehören die Planung der Reihenfolge, in der Komponenten integriert werden, die Erstellung von Gerüsten zur Unterstützung von Zwischenversionen der Software, die Bestimmung des Grades der Prüfung und Qualität der Arbeiten an Komponenten vor ihrer Integration, und die Festlegung von Punkten in dem Projekt, an dem Zwischenversionen der Software getestet werden. Bautechnologien Objektorientierte Laufzeitfragen Objektorientierte Sprachen unterstützen eine Reihe von Laufzeitmechanismen, die die Flexibilität und Anpassungsfähigkeit der Programme wie Datenabstraktion, Verkapselung, Modularität, Erbschaft, Polymorphismus und Reflexion erhöhen. Datenabstraktion ist der Prozess, durch den Daten und Programme mit einer Darstellung ähnlich ihrer Bedeutung definiert werden, während die Implementierungsdetails versteckt werden. Die wissenschaftliche Forschung zeigte, dass die Datenabstraktion die Programme um 30% einfacher zu verstehen macht als funktionelle Programme. Assertions, Design by Contract und defensive Programmierung Assertions sind ausführbare Prädikate, die in einem Programm platziert werden, das Laufzeitprüfungen des Programms erlaubt. Design by Contract ist ein Entwicklungsansatz, bei dem für jede Routine Vor- und Nachbedingungen berücksichtigt werden. Defensive Programmierung ist der Schutz einer Routine durch ungültige Eingaben gebrochen werden. Fehlerhandling, Ausnahmehandling und Fehlertoleranz Die Fehlerhandling bezieht sich auf die Programmierpraxis der Antizipierung und Codierung für Fehlerbedingungen, die bei Ablauf des Programms auftreten können. Ausnahme-Handling ist ein Programmier-Sprach-Konstrukt oder Hardware-Mechanismus, um das Auftreten von Ausnahmen zu bewältigen, spezielle Bedingungen, die den normalen Ablauf der Programmausführung ändern. Fehlertoleranz ist eine Sammlung von Techniken, die die Software-Verlässlichkeit erhöhen, indem Fehler erkannt werden und sich dann von ihnen, wenn möglich, oder ihre Effekte enthalten, wenn eine Wiederherstellung nicht möglich ist. State-based und table-driven Konstruktionstechniken State-based Programmierung ist eine Programmiertechnologie mit endlichen State-Maschinen, um Programmverhalten zu beschreiben. Eine tabellengesteuerte Methode ist ein Schema, das Tabellen verwendet, um Informationen zu suchen, anstatt logische Aussagen zu verwenden (z.B. wenn und Fall). Runtime-Konfiguration und Internationalisierung Runtime-Konfiguration ist eine Technik, die bei laufendem Programm variable Werte und Programmeinstellungen bindet, in der Regel durch Aktualisierung und Lesen von Konfigurationsdateien in einem just-in-time-Modus. Internationalisierung ist die technische Aktivität der Vorbereitung eines Programms, in der Regel interaktive Software, mehrere Lokale zu unterstützen. Die entsprechende Aktivität, Lokalisierung, ist die Aktivität, ein Programm zur Unterstützung einer bestimmten lokalen Sprache zu modifizieren. Siehe auch Software-Engineering-Software-Entwicklung Hinweise Referenzen Externe Links Anleitung zum Software-Engineering-Körper des Wissens - 2004 Version Von IEEE Computer Society Guide to the Software Engineering Body of Knowledge, Version 3.0, IEEE Computer Society, 2014