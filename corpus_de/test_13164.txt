Bei der Computerprogrammierung arbeitet ein bitweiser Betrieb auf einem Bit-String, einem Bit-Array oder einer binären Ziffer (beide als Bit-String) auf Höhe seiner einzelnen Bits. Es ist eine schnelle und einfache Aktion, grundlegend für die höheren Level-Arithmetic-Operationen und direkt vom Prozessor unterstützt. Die meisten bitweise Operationen werden als Zwei-Operand-Anweisungen dargestellt, in denen das Ergebnis einen der Eingangsoperanden ersetzt. Bei einfachen kostengünstigen Prozessoren sind in der Regel bitweise Operationen wesentlich schneller als Division, mehrmals schneller als Multiplikation und manchmal deutlich schneller als Addition. Während moderne Prozessoren in der Regel Ergänzung und Multiplikation genauso schnell wie bitweise Operationen aufgrund ihrer längeren Instruktion Pipelines und andere Architektur-Design-Auswahlen durchführen, bitweise Operationen verwenden häufig weniger Strom wegen der reduzierten Nutzung von Ressourcen. Bitweise Operatoren In den nachfolgenden Erläuterungen wird jeder Hinweis auf die Position eines Bits von der rechten (bedeutendsten) Seite gezählt, nach links vorgeschoben. Beispielsweise hat der Binärwert 0001 (dezimal 1) bei jeder Position Nullen, aber die erste (d.h. die rechte) eine. HINWEIS Das bitweise NICHT oder Komplement ist eine unary Operation, die logische Negation auf jedem Bit durchführt, wobei dies die Ergänzung des vorgegebenen Binärwertes bildet. Bits, die 0 sind, werden 1, und diejenigen, die 1 sind, werden 0. Zum Beispiel: NICHT 0111 (dezimal 7) = 1000 (dezimal 8) NICHT 10101011 (dezimal 171) =01010100 (dezimal 84) Die bitweise Ergänzung ist gleich der beiden Ergänzung des Wertes minus eins. Wird zweis Komplement-Arithmetic verwendet, dann NICHT x = -x - 1.Für unsignierte ganze Zahlen ist das bitweise Komplement einer Zahl die "Spiegelreflexion" der Zahl über den halben Punkt des unsignierten Ganzzahlbereichs. Beispielsweise für 8-Bit unbezeichnete ganze Zahlen, NOT x = 255 - x, die auf einem Diagramm als Abwärtslinie visualisiert werden kann, die effektiv einen zunehmenden Bereich von 0 bis 255 umkippt, in einen abnehmenden Bereich von 255 bis 0. Ein einfaches, aber illustratives Beispiel ist die Invertierung eines Grauwertbildes, bei dem jedes Pixel als unbezeichnete ganze Zahl gespeichert wird. UND Ein bitweises UND ist eine binäre Operation, die zwei gleichlange Binärdarstellungen nimmt und die logische UND-Verknüpfung an jedem Paar der entsprechenden Bits durchführt, was einer Multiplikation gleich ist. Wenn also beide Bits in der Vergleichsposition 1 sind, beträgt das Bit in der resultierenden binären Darstellung 1 (1 × 1 = 1); andernfalls ergibt sich 0 (1 × 0 = 0 und 0 × 0 = 0). Zum Beispiel: 0101 (dezimal 5) UND 0011 (dezimal 3) = 0001(dezimal 5) 1) Die Operation kann verwendet werden, um festzustellen, ob ein bestimmtes Bit (1) oder klar (0) gesetzt wird. Bei einem Bitmuster 0011 (dezimal 3,) wird z.B. festgestellt, ob das zweite Bit eingestellt ist, verwenden wir ein Bitwise UND mit einem Bitmuster, das 1 nur im zweiten Bit enthält: 0011 (dezimal 3) UND 0010 (dezimal 2) = 0010(dezimal) 2) Da das Ergebnis 0010 nicht-Null ist, wissen wir, dass das zweite Bit im ursprünglichen Muster gesetzt wurde. Dies wird oft Bit Maskierung genannt. ( Analog ist die Verwendung von Abdeckbandabdeckungen oder Masken, nicht zu ändernde oder nicht interessierende Abschnitte. In diesem Fall maskieren die 0 Werte die nicht interessierenden Bits.) Der bitweise UND kann verwendet werden, um ausgewählte Bits (oder Fahnen) eines Registers zu löschen, in dem jedes Bit einen einzelnen Booleschen Zustand darstellt. Diese Technik ist eine effiziente Möglichkeit, eine Reihe von Boolean-Werten mit so wenig Speicher wie möglich zu speichern. Beispielsweise kann 0110 (dezimal 6) als eine Reihe von vier Fahnen betrachtet werden, wobei die erste und vierte Fahnen klar sind (0,) und die zweite und dritte Fahnen gesetzt sind (1). Die dritte Fahne kann durch die Verwendung eines bitweise UND mit dem Muster, das nur im dritten Bit Null hat: 0110 (dezimal 6) UND 1011 (dezimal 11) = 0010(dezimal 2) Aufgrund dieser Eigenschaft wird es leicht, die Parität einer Binärzahl zu überprüfen, indem der Wert des niedrigsten Wertbits überprüft wird. Verwendung Beispiel oben: 0110 (dezimal 6) UND 0001 (dezimal 1) = 0000(dezimal 0) Da 6 UND 1 Null ist, ist 6 durch zwei und damit sogar divisierbar. OR Ein Bitwise OR ist eine binäre Operation, die zwei Bitmuster gleicher Länge einnimmt und die logische inklusive ODER Operation auf jedem Paar entsprechender Bits durchführt. Das Ergebnis in jeder Position ist 0, wenn beide Bits 0 sind, während ansonsten das Ergebnis 1 ist. Zum Beispiel: 0101 (dezimal 5) OR 0011 (dezimal 3) = 0111(dezimal 5) 7) Mit dem Bitwise OR können die ausgewählten Bits des oben beschriebenen Registers auf 1 eingestellt werden. Beispielsweise kann das vierte Bit von 0010 (dezimal 2) eingestellt werden, indem ein Bitwise OR mit dem Muster mit nur dem vierten Bitsatz durchgeführt wird: 0010 (dezimal 2) OR 1000 (dezimal 8) = 1010 (dezimal 10) XOR Ein bitweises XOR ist eine binäre Operation, die zwei Bitmuster gleicher Länge nimmt und die logische Exklusiv-ODER-Operation auf jedem Paar entsprechender Bits durchführt. Das Ergebnis in jeder Position ist 1 wenn nur einer der Bits 1 ist, wird aber 0 sein, wenn beide 0 oder beide 1 sind. Dabei führen wir den Vergleich von zwei Bits, wobei 1 ist, wenn die beiden Bits unterschiedlich sind, und 0 wenn sie gleich sind. Zum Beispiel: 0101 (dezimal 5) XOR 0011 (dezimal 3) =0110(dezimal 5) 6) Der bitweise XOR kann verwendet werden, um ausgewählte Bits in einem Register invertieren (auch Kippen oder Flip genannt). Jedes Bit kann durch XORing es mit 1 angeheftet werden. Beispielsweise können bei dem Bitmuster 0010 (dezimal 2) die zweiten und vierten Bits durch ein bitweises XOR mit einem Bitmuster mit 1 in der zweiten und vierten Position geschleppt werden: 0010 (dezimal 2) XOR 1010 (dezimal 10) = 1000 (dezimal 8) Diese Technik kann verwendet werden, um Bitmuster zu manipulieren, die Sätze von Booleschen Zuständen repräsentieren. Montage Sprachprogrammierer und Optimierung von Compilern verwenden manchmal XOR als Kurzschnitt, um den Wert eines Registers auf Null zu setzen. Durchführen von XOR auf einem Wert gegen sich ergibt sich immer Null, und bei vielen Architekturen benötigt dieser Vorgang weniger Taktzyklen und Speicher als das Laden eines Nullwertes und Speichern in das Register. Wird der Satz von Bitfolgen fester Länge n (d.h. Maschinenworte) als n-dimensionaler Vektorraum F 2 n {\displaystyle {\bf F}_{2}{n über dem Feld F 2\displaystyle {\bf F}_{2  gedacht, so entspricht die Vektoraddition dem bitweise XOR. Mathematische Äquivalente Unter Annahme x ≥ y {\displaystyle x\geq y} können für die nicht-negativen Zahlen die bitweise Operationen wie folgt geschrieben werden: HINWEIS x = Σ n = 0 ⌊ log 2 ‡ ( x ⁡) ⌋ 2 n [ ⌊ +1}-1-x\x\operatorname {AND} y&=\sum ^^{\lfloor \log {_2}(x)\rfloor 2^^{n}\left(\left\lfloor {\frac x}{2^{n}}}\right\rfloor {\bmod {\2}\right\lfloor}\left(\left\lfloor {\frac y}}{2{\c}}}}}}}}}}\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c}}}}}}}}}}}}\c\c\c\c\c\c\c\c\c\c\c\c\c\c\c (OR) y&=\sum ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * Wahrheitstabelle für alle binären logischen Operatoren Es gibt 16 mögliche Wahrheitsfunktionen von zwei binären Variablen; dies definiert eine Wahrheitstabelle.Hier sind die bitweise äquivalenten Operationen von zwei Bits P und Q: Bitverschiebungen Die Bitverschiebungen werden manchmal als bitweise Operationen betrachtet, weil sie einen Wert als eine Bitreihe anstatt als numerische Größe behandeln. Bei diesen Operationen werden die Ziffern nach links oder rechts bewegt oder verschoben. Register in einem Computerprozessor haben eine feste Breite, so dass einige Bits an einem Ende aus dem Register "verschoben" werden, während die gleiche Anzahl von Bits vom anderen Ende "verschoben" werden; die Unterschiede zwischen Bitverschiebungsoperatoren liegen darin, wie sie die Werte der eingeschobenen Bits bestimmen. Bit Adressierung Ist die Breite des Registers (in der Regel 32 oder sogar 64) größer als die Anzahl der Bits (in der Regel 8) der kleinsten adressierbaren Einheit (Atomelement), die häufig Byte genannt werden, so führen die Verschiebungsvorgänge von den Bytes zu den Bits ein Adressierungsschema an. Dabei werden die Orientierungen links und rechts aus der Standardschrift von Zahlen in einer Ortswert-Notation genommen, so dass eine linke Verschiebung zunimmt und eine rechte Verschiebung den Wert der Zahl abnimmt - wenn die linken Ziffern zuerst gelesen werden, ergibt sich eine groß-endische Orientierung. Unter Berücksichtigung der Grenzeffekte an beiden Enden des Registers verhalten sich arithmetische und logische Verschiebungsvorgänge gleich, und eine Verschiebung um 8 Bitpositionen transportiert das Bitmuster um 1 Byte-Position in folgender Weise: Arithmetische Verschiebung Bei einer arithmetischen Verschiebung werden die Bits, die aus beiden Enden verschoben werden, verworfen. In einer linken arithmetischen Verschiebung werden die Nullen rechts eingeschoben; in einer rechten arithmetischen Verschiebung wird das Vorzeichenbit (das MSB in zweier Ergänzung) links eingeschoben und so das Vorzeichen des Operanden erhalten. Dieses Beispiel verwendet ein 8-Bit-Register, interpretiert als zweier Ergänzungen: 00010111 (dezimal +23) LEFT-SHIFT = 00101110 (dezimal +46) 10010111 (dezimal -105) RIGHT-SHIFT = 11001011 (dezimal -53) Im ersten Fall wurde die linkeste Ziffer am Ende des Registers vorbei verschoben und eine neue 0 in die rechteste Position verschoben. Im zweiten Fall wurde das rechte 1 ausgeschaltet (perhaps in die Carrier-Flagge), und ein neues 1 wurde in die linkeste Position kopiert und das Vorzeichen der Nummer bewahrt. Mehrere Verschiebungen werden manchmal um einige Ziffern auf eine einzige Verschiebung verkürzt. Zum Beispiel: 00010111 (dezimal +23) LEFT-SHIFT-BY-TWO = 01011100 (dezimal +92) Eine linke arithmetische Verschiebung um n entspricht der Multiplizierung um 2n (vorausgesetzt, der Wert nicht überläuft), während eine rechte arithmetische Verschiebung um n eines zweier Komplementwerts entspricht, um den Unterteilungsboden um 2n zu nehmen. Wird die Binärzahl als eine Ergänzung behandelt, so ergibt sich bei gleichem Rechtsschaltvorgang eine Aufteilung um 2n und eine Abrundung auf Null. Logische Verschiebung In einer logischen Verschiebung werden Nullen eingeschaltet, um die verworfenen Bits zu ersetzen. Daher sind die logischen und arithmetischen Linksverschiebungen genau gleich. Da jedoch der logische Rechtsschaltwert 0 Bit in das bedeutendste Bit eingibt, ist er anstatt das Vorzeichenbit zu kopieren, ideal für unsignierte Binärzahlen, während die arithmetische Rechtsschaltung ideal für signierte Zweierkomplementärzahlen ist. Kreiswechsel Eine andere Form der Verschiebung ist die Kreisverschiebung, bitweise Drehung oder Bitdrehung. Rotieren Bei diesem Vorgang werden die Bits manchmal als "rot" bezeichnet, als wären die linken und rechten Enden des Registers verbunden. Der Wert, der während einer Linksschaltung nach rechts verschoben wird, ist, wie der Wert nach links verschoben wurde, und umgekehrt für einen Rechtsschaltvorgang. Dies ist nützlich, wenn es notwendig ist, alle vorhandenen Bits zu behalten und häufig in der digitalen Kryptographie verwendet wird. Drehen durch tragen Drehen durch Tragen ist eine Variante des Drehvorgangs, wobei das eingeschobene Bit (an beiden Enden) der alte Wert der Tragfahne ist und das ausgeschaltete Bit (am anderen Ende) der neue Wert der Tragfahne wird. Ein einziger Durchgang kann eine logische oder arithmetische Verschiebung einer Position simulieren, indem zuvor die Übertragerfahne eingerichtet wird. Wenn z.B. die Übertragsfahne 0 enthält, dann x RECHT-ROTATE-THROUGH-CARRY-BY-ONE eine logische Rechtsverschiebung ist, und wenn die Übertragsfahne eine Kopie des Vorzeichenbits enthält, dann ist x RECHT-ROTATE-THROUGH-CARRY-BY-ONE eine arithmetische Rechtsverschiebung. Aus diesem Grund haben einige Mikrocontroller, wie z.B. Low-End-PICs einfach durch den Transport gedreht und rotiert, und stören nicht mit arithmetischen oder logischen Schaltbefehlen. Das Drehen durch das Tragen ist besonders nützlich bei der Durchführung von Verschiebungen auf Zahlen größer als die native Wortgröße des Prozessors, weil bei einer großen Anzahl in zwei Registern das Bit, das von einem Ende des ersten Registers verschoben wird, am anderen Ende des zweiten eintreffen muss. Bei Drehdurchführung wird dieses Bit während der ersten Verschiebung in der Tragfahne gespeichert, während der zweiten Verschiebung ohne zusätzliche Vorbereitung einschaltbar. In hochrangigen Sprachen C-Familie In C-Familiensprachen sind die logischen Schichtbetreiber "<" für Linksverschiebung und ">>" für Rechtsverschiebung. Die Anzahl der zu verschiebenden Stellen wird dem Betreiber als zweites Argument angegeben. Beispielsweise wird x das Ergebnis der Verschiebung y nach links um zwei Bits zugeteilt, was einer Multiplikation um vier entspricht. Verschiebungen können zu implementierungsdefiniertem Verhalten oder undefiniertem Verhalten führen, so dass bei der Verwendung darauf geachtet werden muss. Das Ergebnis einer Verschiebung um einen Bitwert größer oder gleich der Größe des Wortes ist undefiniertes Verhalten in C und C++. Eine Rechtsverschiebung eines negativen Wertes wird durch eine gute Codierungspraxis implementiert und nicht empfohlen; das Ergebnis einer Linksschaltung eines signierten Wertes ist undefiniert, wenn das Ergebnis im Ergebnistyp nicht dargestellt werden kann. In C ist die Rechtsverschiebung eine arithmetische Verschiebung, wenn der erste Operand ein Int oder lang ist. Ist der erste Operand vom Typ uint oder ulong, so ist die Rechtsverschiebung eine logische Verschiebung. Kreiswechsel Die C-Familie der Sprachen fehlt an einem rotierenden Operator (obgleich C++20 liefert std::rotl und std::rotr), aber man kann von den Schichtbetreibern synthetisiert werden. Es ist darauf zu achten, dass die Aussage gut gebildet wird, um undefinierte Verhaltens- und Timingangriffe in Software mit Sicherheitsanforderungen zu vermeiden. Beispielsweise ist eine naive Implementierung, die links einen 32-Bit unbezeichneten Wert x um n Positionen dreht, einfach: Eine Verschiebung um 0 Bit führt jedoch zu einem undefinierten Verhalten im rechten Ausdruck (x > (32 - n), da 32 - 0 32 und 32 außerhalb des Bereichs [0 - 31] einschließlich liegen. Ein zweiter Versuch könnte dazu führen: wo der Schaltbetrag getestet wird, um sicherzustellen, dass er nicht undefiniertes Verhalten einführt. Der Zweig fügt jedoch einen zusätzlichen Codepfad hinzu und bietet eine Möglichkeit zur Timing-Analyse und -Angriff, die oft in High-Integrity-Software nicht akzeptabel ist. Darüber hinaus kompiliert der Code mehrere Maschinenanweisungen, die oft weniger effizient sind als die native Anweisung des Prozessors. Um das undefinierte Verhalten und die Zweige unter GCC und Clang zu vermeiden, wird Folgendes empfohlen. Das Muster wird von vielen Compilern erkannt und der Compiler sendet eine einzige rotierende Anweisung aus: Es gibt auch kompilerspezifische Intrinsics, die kreisförmige Verschiebungen implementieren, wie _rotl8, _rotl16, _rotr8, _rotr16 in Microsoft Visual C++. Clang bietet einige rotierende Intrinsics für Microsoft-Kompatibilität, die die oben genannten Probleme leidet. GCC bietet keine rotierende Intrinsik an. Intel bietet auch x86 Intrinsics. JavaIn Java werden alle Ganzzahltypen unterschrieben, so dass die "<" und ">>" Operatoren arithmetische Verschiebungen ausführen. Java fügt den Operator ">>>" hinzu, um logische Rechtsverschiebungen durchzuführen, aber da die logischen und arithmetischen Linksschaltungen für signierte ganze Zahlen identisch sind, gibt es in Java keinen "<<"-Operator. Weitere Details von Java Shift Operatoren: Die Betreiber << (linke Schicht) >> (unterzeichnete rechte Verschiebung) und >> (unsignierte rechte Verschiebung) werden als Schichtbetreiber bezeichnet. Die Art des Schaltausdrucks ist die beförderte Art des linken Operanden. Zum Beispiel aByte >> 2 entspricht (int) aByte) >> 2. Ist die beförderte Art des linken Operanden int, so werden nur die fünf niedrigsten Ordnungsbits des rechten Operandens als Schaltstrecke verwendet. Es ist, als ob der rechte Operand einem bitweise logischen UND-Operator & mit dem Maskenwert 0x1f (0b111) unterzogen wurde. Der tatsächlich verwendete Schaltabstand liegt also stets im Bereich 0 bis 31, inklusive. Ist die geförderte Art des linken Operanden lang, so werden nur die sechs niedrigsten Ordnungsbits des rechten Operanden als Verschiebeweg verwendet. Es ist, als ob der rechte Operand einem bitweise logischen UND-Operator & mit dem Maskenwert 0x3f (0b11111111) unterzogen wurde. Der tatsächlich verwendete Schaltabstand liegt also stets im Bereich 0 bis 63, inklusive. Der Wert von n >>> s ist n rechtsversetzte Bitpositionen mit Null-Ausdehnung. Bei Bit- und Schaltvorgängen wird der Typbyte implizit in Int umgewandelt. Ist der Bytewert negativ, so ist das höchste Bit eins, so werden die Extrabytes im Int ausgefüllt. So Byte b1 =-5; int i = b1 | 0x0200; wird zu i= -5 führen. JavaScript JavaScript verwendet bitweise Operationen, um jede von zwei oder mehr Einheiten Platz zu 1 oder 0 auszuwerten. PascalIn Pascal sowie in allen seinen Dialekten (wie Object Pascal und Standard Pascal) sind die logischen linken und rechten Schaltoperatoren shl bzw. shr. Auch für signierte ganze Zahlen verhalten sich shr wie eine logische Verschiebung und kopiert nicht das Zeichenbit. Als zweites Argument wird die Anzahl der Schichtplätze angegeben. Beispielsweise weist die folgende x das Ergebnis der Verschiebung y nach links um zwei Bits zu: Anderer Popcount, der in Kryptographiezähler führende Nullen verwendet wird Anwendungen Bitwise Operationen sind insbesondere bei der Programmierung auf niedriger Ebene, wie Gerätetreiber, Grafiken auf niedriger Ebene, Kommunikationsprotokollpaket-Montage und Decodierung notwendig. Obwohl Maschinen oft effiziente Einbauanleitungen für die Durchführung von arithmetischen und logischen Operationen haben, können alle diese Operationen durch die Kombination der bitweise Bediener und der Nulltest auf verschiedene Weise durchgeführt werden. Hier ist beispielsweise eine Pseudocode-Implementierung der alten ägyptischen Multiplikation, die zeigt, wie man zwei beliebige Zahlen a und b (a größer als b) mit nur Bitverschiebungen und Addition multipliziert: Ein weiteres Beispiel ist eine Pseudocode-Implementierung der Addition, die zeigt, wie man eine Summe von zwei Integern a und b mit bitweisen Operatoren und Null-Testing berechnet: Boolean algebraSometimes ist es nützlich, komplexe Ausdrücke aus bitweisem Betrieb zu vereinfachen. Zum Beispiel beim Schreiben von Compilern. Ziel eines Compilers ist es, eine hochgradige Programmiersprache in den effizientesten Maschinencode zu übersetzen. Boolean Algebra wird verwendet, um komplexe bitweise Ausdrücke zu vereinfachen. = (x & y) = (x & y) = (x & y) & z x & 0xFF = x & 0 = 0x & x = x OR x ) y =y x x x | x | (y | z) = (x | y) x | x ) x ) x ) x x ^ x = 0 x ^ 0xFFFF = *x XOR kann auch mit den 3 Grundoperationen (AND, OR, NOT) a ^ b = (a < b) & (~a | ~b) a ^ b = (a & ~b) | (~a & b) Andere x | (x & y) = x & (x | y) = x (~x | y=) Es kann schwierig sein, für Variablen in boolean Algebra zu lösen, weil im Gegensatz zu regelmäßigen Algebra, mehrere Operationen haben keine Inversen. Operationen ohne Inversen verlieren einige der ursprünglichen Datenbits, wenn sie durchgeführt werden, und es ist nicht möglich, diese fehlenden Informationen wiederherzustellen. Hat InverseNOT XOR Links RotateRight Nein Inverse und ODER Linke Schaltrechte Ordnung der Operationen Operationen an der Spitze dieser Liste werden zuerst ausgeführt. Siehe den Hauptartikel für eine vollständigere Liste. ( ) ~ - * / % + - < >> & ^ | Siehe auch Referenzen Externe Links Online Bitwise Calculator unterstützt Bitwise AND, OR und XOR Division mit Bitshifts "Bitwise Operations Mod N" von Enrique Zeleny, Wolfram Demonstrations Project. "Plots of Compositions Of Bitwise Operations" von Enrique Zeleny, The Wolfram Demonstrations Project.