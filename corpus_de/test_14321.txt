In der künstlichen Intelligenz ist die genetische Programmierung (GP) eine Technik der Entwicklung von Programmen, ausgehend von einer Population von untauglichen (normalerweise zufälligen) Programmen, für eine bestimmte Aufgabe geeignet, indem Operationen analog zu natürlichen genetischen Prozessen auf die Bevölkerung von Programmen angewendet werden. Es handelt sich im Wesentlichen um eine heuristische Suchtechnik, die oft als "Halbsteigen" bezeichnet wird, d.h. um ein optimales oder zumindest geeignetes Programm unter dem Raum aller Programme zu suchen. Die Operationen sind: Auswahl der Fittest-Programme für die Reproduktion (Crossover) und Mutation nach einem vorgegebenen Fitness-Maßstab, in der Regel an der gewünschten Aufgabe. Die Crossover-Operation beinhaltet das Überspringen von zufälligen Teilen ausgewählter Paare (Eltern), um neue und verschiedene Nachkommen zu produzieren, die Teil der neuen Generation von Programmen werden. Mutation beinhaltet die Substitution eines zufälligen Teils eines Programms mit einem anderen zufälligen Teil eines Programms. Einige Programme, die nicht für die Reproduktion ausgewählt werden, werden von der aktuellen Generation zur neuen Generation kopiert. Dann werden die Auswahl und andere Operationen wieder auf die neue Generation von Programmen angewendet. Typischerweise sind Mitglieder jeder neuen Generation im Durchschnitt mehr fit als die Mitglieder der vorherigen Generation, und das Best-of-Generation-Programm ist oft besser als die Best-of-Generation-Programme der vorherigen Generationen. Die Beendigung der Rekursion ist, wenn ein einzelnes Programm einen vordefinierten Leistungs- oder Fitnesslevel erreicht. Es kann und oft passieren, dass ein bestimmter Ablauf des Algorithmus zu einer vorzeitigen Konvergenz zu einem bestimmten lokalen Maximum führt, was keine global optimale oder sogar gute Lösung ist. Mehrere Abläufe (Dolzen zu Hunderten) sind in der Regel notwendig, um ein sehr gutes Ergebnis zu erzeugen. Es kann auch notwendig sein, die Ausgangspopulation Größe und Variabilität der Individuen zu erhöhen, um Pathologien zu vermeiden. Geschichte Die erste Aufzeichnung des Vorschlags, Programme zu entwickeln, ist wahrscheinlich die von Alan Turing im Jahr 1950. Es gab eine Lücke von 25 Jahren vor der Veröffentlichung von John Hollands "Adaptation in Natural and Artificial Systems" die theoretischen und empirischen Grundlagen der Wissenschaft. Im Jahre 1981 zeigte Richard Forsyth die erfolgreiche Entwicklung kleiner Programme, die als Bäume dargestellt wurden, um die Klassifikation von Tatortennachweisen für das britische Home Office durchzuführen. Obwohl die Idee, Programme zu entwickeln, zunächst in der Computersprache Lisp, war unter John Holland Studenten, es war nicht, bis sie die erste Genetische Algorithms (GA) Konferenz in Pittsburgh, dass Nichael Cramer veröffentlichte entwickelte Programme in zwei speziell gestalteten Sprachen, die die erste Aussage der modernen baumbasierten Genetischen Programmierung (d.h. Verfahrenssprachen in baumbasierten Strukturen organisiert und von entsprechend definierten GA betrieben). 1988 patentierte John Koza (auch Doktorand von John Holland) seine Erfindung eines GA für die Programmentwicklung. Anschließend wurde in der Internationalen Gemeinsamen Konferenz über Künstliche Intelligenz IJCAI-89 veröffentlicht. Koza folgte diesem mit 205 Publikationen zu „Genetic Programming“ (GP), dem Namen David Goldberg, ebenfalls Doktorand von John Holland. Es ist jedoch die Serie von 4 Büchern von Koza, beginnend im Jahr 1992 mit begleitenden Videos, die wirklich etabliert GP. Anschließend gab es eine enorme Erweiterung der Zahl der Publikationen mit der Genetischen Programming Bibliographie, die 10.000 Einträge übertraf. Im Jahr 2010, Koza aufgelistet 77 Ergebnisse, wo Genetic Programming war menschliche Konkurrenz. Im Jahr 1996 begann Koza die jährliche Genetic Programming-Konferenz, die 1998 von der jährlichen EuroGP-Konferenz gefolgt wurde, und das erste Buch in einer GP-Serie, die von Koza bearbeitet wurde. GP blühte weiter, was zum ersten Fachjournal GP führte und drei Jahre später (2003) wurde der jährliche Workshop für Genetische Programmierungstheorie und Praxis (GPTP) von Rick Riolo gegründet. Genetische Programmpapiere werden weiterhin auf einer Vielzahl von Konferenzen und dazugehörigen Zeitschriften veröffentlicht. Heute gibt es neunzehn GP-Bücher, darunter mehrere für Studenten. Grundlagenarbeit in GP Frühe Arbeiten, die die Bühne für aktuelle Forschungsthemen und Anwendungen der genetischen Programmierung setzen, sind vielfältig und beinhalten Softwaresynthese und Reparatur, prädiktive Modellierung, Datenabbau, Finanzmodellierung, Soft-Sensoren, Design und Bildverarbeitung. Anwendungen in einigen Bereichen, wie Design, nutzen oft Zwischendarstellungen, wie Fred Gruaus zelluläre Kodierung. Die industrielle Aufnahme war in mehreren Bereichen wie Finanzen, Chemieindustrie, Bioinformatik und Stahlindustrie von Bedeutung. Methoden Programmdarstellung GP entwickelt Computerprogramme, die traditionell als Baumstrukturen im Speicher dargestellt werden. Bäume lassen sich auf wiederkehrende Weise leicht auswerten. Jeder Baumknoten hat eine Bedienfunktion und jeder Terminalknoten hat einen Operanden, wodurch mathematische Ausdrücke einfach zu entwickeln und auszuwerten. So begünstigt GP traditionell die Verwendung von Programmiersprachen, die natürlich Baumstrukturen (z.B. Lisp; andere funktionelle Programmiersprachen sind auch geeignet). Nicht-tree Repräsentationen wurden vorgeschlagen und erfolgreich umgesetzt, wie z.B. lineare genetische Programmierung, die den traditionellen Imperativsprachen entspricht [siehe z.B. Banzhaf et al.(1998)]. Die kommerzielle GP-Software Discipulus nutzt die automatische Induktion von binären Maschinencode (AIM) um eine bessere Leistung zu erreichen.μ GP verwendet gezielte Multigraphen, um Programme zu generieren, die die Syntax einer bestimmten Montagesprache voll ausnutzen. Andere Programmdarstellungen, auf denen signifikante Forschung und Entwicklung durchgeführt wurden, sind Programme für stapelbasierte virtuelle Maschinen und Sequenzen von Ganzzahlen, die über Grammatik auf beliebige Programmiersprachen abgebildet werden. Die kartesische genetische Programmierung ist eine andere Form von GP, die anstelle der üblichen baumbasierten Darstellung eine graphische Darstellung verwendet, um Computerprogramme zu kodieren. Die meisten Darstellungen haben strukturellen nicht-effektiven Code (Intronen). Solche nicht codierenden Gene scheinen nutzlos zu sein, weil sie keine Wirkung auf die Leistung eines einzelnen haben. Sie verändern jedoch die Wahrscheinlichkeiten, unter den Variationsoperatoren unterschiedliche Nachkommen zu erzeugen, und verändern so die Variationseigenschaften des Individuums. Experimente scheinen schnellere Konvergenz bei der Verwendung von Programmdarstellungen zu zeigen, die solche nicht-kodierenden Gene erlauben, im Vergleich zu Programmdarstellungen, die keine nicht-kodierenden Gene aufweisen. Auswahl ist ein Prozess, bei dem bestimmte Personen aus der aktuellen Generation ausgewählt werden, die als Eltern für die nächste Generation dienen würde. Die Individuen werden probabilistisch so ausgewählt, dass die besser performenden Individuen eine höhere Chance haben, ausgewählt zu werden. Die am häufigsten verwendete Auswahlmethode in GP ist Turnierauswahl, obwohl andere Methoden wie Fitness-Proportionat-Auswahl, Lexicase-Auswahl, und andere wurden gezeigt, um besser für viele GP-Probleme zu erfüllen. Elitismus, der die nächste Generation mit dem besten Individuum (oder besten n Individuen) aus der aktuellen Generation samieren, ist eine Technik, die manchmal verwendet wird, um Regression zu vermeiden. Crossover In Genetic Programmierung zwei fit Individuen werden aus der Bevölkerung ausgewählt, um Eltern für ein oder zwei Kinder zu sein. In der baumgenetischen Programmierung sind diese Eltern als invertierte Lisp wie Bäume, mit ihren Wurzelknoten oben dargestellt. Bei Subtree Crossover in jedem Elternteil wird ein Subtree zufällig gewählt.(Höher mit Gelb in der Animation.) In der Wurzelspendende Eltern (in der Animation auf der linken Seite) wird der ausgewählte Unterbaum entfernt und durch eine Kopie des zufällig ausgewählten Unterbaums aus dem anderen Elternteil ersetzt, um einen neuen Kinderbaum zu geben. Manchmal wird zwei Kinderüberkreuzungen verwendet, wobei der entfernte Subtree (in der Animation auf der linken Seite) nicht einfach gelöscht wird, sondern auf eine Kopie des zweiten Elternteils (hier auf der rechten Seite) kopiert wird, der sein zufällig gewähltes Subtree ersetzt (in der Kopie). Diese Art von Subtree Crossover nimmt also zwei fit Bäume und erzeugt zwei Kinderbäume. Mut Es gibt viele Arten von Mutation in der genetischen Programmierung. Sie beginnen von einem fit syntaktisch korrekten Elternteil und wollen zufällig ein syntaktisch korrektes Kind erstellen. In der Animation wird ein Subtree zufällig gewählt (geleuchtet von gelb). Es wird entfernt und durch einen zufällig erzeugten Unterbaum ersetzt. Andere Mutationsoperatoren wählen ein Blatt (externer Knoten) des Baumes und ersetzen es durch ein zufällig gewähltes Blatt. Eine weitere Mutation ist es, eine Funktion (interner Knoten) zufällig auszuwählen und durch eine andere Funktion mit der gleichen Arität (Anzahl der Eingänge) zu ersetzen. Die Hoist-Mutation wählt zufällig einen Unterbaum und ersetzt ihn durch einen Unterbaum in sich. So wird eine Hebemutung garantiert, um das Kind kleiner zu machen. Blatt und gleiche Arity-Funktionsersatz sorgen dafür, dass das Kind die gleiche Größe wie der Eltern hat. Während Subtree-Mutation (in der Animation) je nach Funktion und Terminal-Sets eine Vorspannung haben kann, um entweder die Baumgröße zu erhöhen oder zu verringern. Andere subtree-basierte Mutationen versuchen, die Größe des Ersatz-Subtrees und damit die Größe des Kinderbaums sorgfältig zu kontrollieren. Ebenso gibt es viele Arten von linearen genetischen Programmiermutationen, von denen jede versucht, sicherzustellen, dass das mutierte Kind noch syntaktisch korrekt ist. Die Anwendungen GP wurden erfolgreich als automatisches Programmierwerkzeug, als Werkzeuglernwerkzeug und als automatische Problemlösemaschine eingesetzt. GP ist besonders in den Bereichen nützlich, in denen die genaue Form der Lösung nicht vorab bekannt ist oder eine ungefähre Lösung akzeptabel ist (möglicherweise weil die Suche nach der genauen Lösung sehr schwierig ist). Einige der Anwendungen von GP sind Kurvenbeschlag, Datenmodellierung, symbolische Regression, Merkmalsauswahl, Klassifizierung, etc. John R. Koza erwähnt 76 Fälle, in denen Genetic Programming in der Lage war, Ergebnisse zu produzieren, die mit humanproduzierten Ergebnissen wettbewerbsfähig sind (sogenannte human-kompetitive Ergebnisse). Seit 2004 hält die jährliche Genetische und evolutionäre Computation Conference (GECCO) den Wettbewerb Human Competitive Awards (genannte Humies), in dem Geldpreise auf human-kompetitive Ergebnisse aus jeder Form genetischer und evolutionärer Berechnungen verliehen werden. GP hat viele Auszeichnungen in diesem Wettbewerb im Laufe der Jahre gewonnen. Meta-genetische Programmierung Meta-genetische Programmierung ist die vorgeschlagene Meta-Learning-Technik zur Entwicklung eines genetischen Programmiersystems mit der genetischen Programmierung selbst. Es deutet darauf hin, dass Chromosomen, Crossover und Mutation selbst entwickelt wurden, daher sollte wie ihre realen Lebensgegenden auf eigene Faust ändern dürfen, anstatt von einem menschlichen Programmierer bestimmt zu werden. Meta-GP wurde 1987 von Jürgen Schmidhuber offiziell vorgeschlagen. Doug Lenat's Eurisko ist eine frühere Anstrengung, die die gleiche Technik sein kann. Es ist ein wiederkehrender, aber endender Algorithmus, so dass es unendliche Rekursion zu vermeiden. In der "autokonstruktiven Evolution"-Annäherung zur meta-genetischen Programmierung werden die Methoden für die Produktion und Variation von Nachkommen in den sich entwickelnden Programmen selbst kodiert und Programme zur Erstellung neuer Programme, die der Bevölkerung hinzugefügt werden, durchgeführt. Kritiken dieser Idee sagen oft, dass dieser Ansatz im Umfang zu weit ist. Es könnte jedoch möglich sein, das Fitness-Kriterium auf eine allgemeine Klasse von Ergebnissen zu beschränken, und so einen weiterentwickelten GP zu erhalten, der Ergebnisse für Unterklassen effizienter erzeugen würde. Dies könnte die Form eines meta-entwickelten GP zur Herstellung menschlicher Gehalgorithmen sein, die dann verwendet wird, um menschliches Laufen, Springen usw. zu entwickeln. Das auf die Meta-GP angewendete Fitness-Kriterium wäre einfach eine der Effizienz. Siehe auch Bio-inspired Computing Covariance Matrix Adaptation Evolution Strategy (CMA-ES)Fitness Approximation Genetische Verbesserung Genetische Darstellung Grammatikalische Evolution Induktive Programmierung Lineare genetische Programmierung Multi Expression Programmierung Propagation of schema Referenzen Externe Links Aymen S Saket & Mark C Sinclair Genetische Programmierung und Evolvable Machines, ein Journal Evo2 für genetische Programmierung GP bibliographie Der Hitch-Hiker's Guide to Evolutionary Computation Riccardo Poli, William B. Langdon,Nicholae 2008